{
  "version": 3,
  "sources": ["../../.pnpm/base-x@5.0.1/node_modules/base-x/src/esm/index.js", "../../.pnpm/bs58@6.0.0/node_modules/bs58/src/esm/index.js", "../../.pnpm/@iota+bcs@1.1.0/node_modules/@iota/bcs/src/b58.ts", "../../.pnpm/@iota+bcs@1.1.0/node_modules/@iota/bcs/src/b64.ts", "../../.pnpm/@iota+bcs@1.1.0/node_modules/@iota/bcs/src/hex.ts", "../../.pnpm/@iota+bcs@1.1.0/node_modules/@iota/bcs/src/uleb.ts", "../../.pnpm/@iota+bcs@1.1.0/node_modules/@iota/bcs/src/reader.ts", "../../.pnpm/@iota+bcs@1.1.0/node_modules/@iota/bcs/src/utils.ts", "../../.pnpm/@iota+bcs@1.1.0/node_modules/@iota/bcs/src/writer.ts", "../../.pnpm/@iota+bcs@1.1.0/node_modules/@iota/bcs/src/bcs-type.ts", "../../.pnpm/@iota+bcs@1.1.0/node_modules/@iota/bcs/src/bcs.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/utils/iota-types.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/bcs/type-tag-serializer.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/bcs/bcs.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/bcs/effects.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/bcs/index.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/utils/format.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/utils/constants.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/serializer.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/Inputs.ts", "../../.pnpm/valibot@0.36.0/node_modules/valibot/dist/index.js", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/data/internal.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/Commands.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/data/v1.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/data/v2.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/json-rpc-resolver.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/object.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/pure.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/crypto.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/utils.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/_blake.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/_md.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/_u64.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/blake2.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/blake2b.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/hash.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/TransactionData.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/utils.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/Transaction.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/ObjectCache.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/executor/caching.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/executor/queue.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/executor/serial.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/executor/parallel.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/intents/CoinWithBalance.ts", "../../.pnpm/@iota+iota-sdk@1.4.0_typescript@5.8.3/node_modules/@iota/iota-sdk/src/transactions/Arguments.ts"],
  "sourcesContent": ["// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  const BASE_MAP = new Uint8Array(256)\n  for (let j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i)\n    const xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  const BASE = ALPHABET.length\n  const LEADER = ALPHABET.charAt(0)\n  const FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  const iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    // eslint-disable-next-line no-empty\n    if (source instanceof Uint8Array) { } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    const pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    const b58 = new Uint8Array(size)\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = source[pbegin]\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    let psz = 0\n    // Skip and count leading '1's.\n    let zeroes = 0\n    let length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size)\n    // Process the characters.\n    while (psz < source.length) {\n      // Find code of next character\n      const charCode = source.charCodeAt(psz)\n      // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n      // Decode character\n      let carry = BASE_MAP[charCode]\n      // Invalid character\n      if (carry === 255) { return }\n      let i = 0\n      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n    // Skip leading zeroes in b256.\n    let it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    const vch = new Uint8Array(zeroes + (size - it4))\n    let j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    const buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode,\n    decodeUnsafe,\n    decode\n  }\n}\nexport default base\n", "import basex from 'base-x';\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport default basex(ALPHABET);\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport bs58 from 'bs58';\n\nexport const toB58 = (buffer: Uint8Array) => bs58.encode(buffer);\nexport const fromB58 = (str: string) => bs58.decode(str);\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromB64(base64String: string): Uint8Array {\n    return Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\n\nconst CHUNK_SIZE = 8192;\nexport function toB64(bytes: Uint8Array): string {\n    // Special-case the simple case for speed's sake.\n    if (bytes.length < CHUNK_SIZE) {\n        return btoa(String.fromCharCode(...bytes));\n    }\n\n    let output = '';\n    for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {\n        const chunk = bytes.slice(i, i + CHUNK_SIZE);\n        output += String.fromCharCode(...chunk);\n    }\n\n    return btoa(output);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHEX(hexStr: string): Uint8Array {\n    const normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n    const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n    const intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n    return Uint8Array.from(intArr);\n}\n\nexport function toHEX(bytes: Uint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n    const arr = [];\n    let len = 0;\n\n    if (num === 0) {\n        return [0];\n    }\n\n    while (num > 0) {\n        arr[len] = num & 0x7f;\n        if ((num >>= 7)) {\n            arr[len] |= 0x80;\n        }\n        len += 1;\n    }\n\n    return arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n    value: number;\n    length: number;\n} {\n    let total = 0;\n    let shift = 0;\n    let len = 0;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const byte = arr[len];\n        len += 1;\n        total |= (byte & 0x7f) << shift;\n        if ((byte & 0x80) === 0) {\n            break;\n        }\n        shift += 7;\n    }\n\n    return {\n        value: total,\n        length: len,\n    };\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n    private dataView: DataView;\n    private bytePosition: number = 0;\n\n    /**\n     * @param {Uint8Array} data Data to use as a buffer.\n     */\n    constructor(data: Uint8Array) {\n        this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    }\n    /**\n     * Shift current cursor position by `bytes`.\n     *\n     * @param {Number} bytes Number of bytes to\n     * @returns {this} Self for possible chaining.\n     */\n    shift(bytes: number) {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n     * Read U8 value from the buffer and shift cursor by 1.\n     * @returns\n     */\n    read8(): number {\n        const value = this.dataView.getUint8(this.bytePosition);\n        this.shift(1);\n        return value;\n    }\n    /**\n     * Read U16 value from the buffer and shift cursor by 2.\n     * @returns\n     */\n    read16(): number {\n        const value = this.dataView.getUint16(this.bytePosition, true);\n        this.shift(2);\n        return value;\n    }\n    /**\n     * Read U32 value from the buffer and shift cursor by 4.\n     * @returns\n     */\n    read32(): number {\n        const value = this.dataView.getUint32(this.bytePosition, true);\n        this.shift(4);\n        return value;\n    }\n    /**\n     * Read U64 value from the buffer and shift cursor by 8.\n     * @returns\n     */\n    read64(): string {\n        const value1 = this.read32();\n        const value2 = this.read32();\n\n        const result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read U128 value from the buffer and shift cursor by 16.\n     */\n    read128(): string {\n        const value1 = BigInt(this.read64());\n        const value2 = BigInt(this.read64());\n        const result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read U128 value from the buffer and shift cursor by 32.\n     * @returns\n     */\n    read256(): string {\n        const value1 = BigInt(this.read128());\n        const value2 = BigInt(this.read128());\n        const result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read `num` number of bytes from the buffer and shift cursor by `num`.\n     * @param num Number of bytes to read.\n     */\n    readBytes(num: number): Uint8Array {\n        const start = this.bytePosition + this.dataView.byteOffset;\n        const value = new Uint8Array(this.dataView.buffer, start, num);\n\n        this.shift(num);\n\n        return value;\n    }\n    /**\n     * Read ULEB value - an integer of varying size. Used for enum indexes and\n     * vector lengths.\n     * @returns {Number} The ULEB value.\n     */\n    readULEB(): number {\n        const start = this.bytePosition + this.dataView.byteOffset;\n        const buffer = new Uint8Array(this.dataView.buffer, start);\n        const { value, length } = ulebDecode(buffer);\n\n        this.shift(length);\n\n        return value;\n    }\n    /**\n     * Read a BCS vector: read a length and then apply function `cb` X times\n     * where X is the length of the vector, defined as ULEB in BCS bytes.\n     * @param cb Callback to process elements of vector.\n     * @returns {Array<Any>} Array of the resulting values, returned by callback.\n     */\n    readVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n        const length = this.readULEB();\n        const result = [];\n        for (let i = 0; i < length; i++) {\n            result.push(cb(this, i, length));\n        }\n        return result;\n    }\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58.js';\nimport { fromB64, toB64 } from './b64.js';\nimport { fromHEX, toHEX } from './hex.js';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n    switch (encoding) {\n        case 'base58':\n            return toB58(data);\n        case 'base64':\n            return toB64(data);\n        case 'hex':\n            return toHEX(data);\n        default:\n            throw new Error('Unsupported encoding, supported values are: base64, hex');\n    }\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n    switch (encoding) {\n        case 'base58':\n            return fromB58(data);\n        case 'base64':\n            return fromB64(data);\n        case 'hex':\n            return fromHEX(data);\n        default:\n            throw new Error('Unsupported encoding, supported values are: base64, hex');\n    }\n}\n\nexport function splitGenericParameters(\n    str: string,\n    genericSeparators: [string, string] = ['<', '>'],\n) {\n    const [left, right] = genericSeparators;\n    const tok = [];\n    let word = '';\n    let nestedAngleBrackets = 0;\n\n    for (let i = 0; i < str.length; i++) {\n        const char = str[i];\n        if (char === left) {\n            nestedAngleBrackets++;\n        }\n        if (char === right) {\n            nestedAngleBrackets--;\n        }\n        if (nestedAngleBrackets === 0 && char === ',') {\n            tok.push(word.trim());\n            word = '';\n            continue;\n        }\n        word += char;\n    }\n\n    tok.push(word.trim());\n\n    return tok;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n    /** The initial size (in bytes) of the buffer that will be allocated */\n    initialSize?: number;\n    /** The maximum size (in bytes) that the buffer is allowed to grow to */\n    maxSize?: number;\n    /** The amount of bytes that will be allocated whenever additional memory is required */\n    allocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n    private dataView: DataView;\n    private bytePosition: number = 0;\n    private size: number;\n    private maxSize: number;\n    private allocateSize: number;\n\n    constructor({\n        initialSize = 1024,\n        maxSize = Infinity,\n        allocateSize = 1024,\n    }: BcsWriterOptions = {}) {\n        this.size = initialSize;\n        this.maxSize = maxSize;\n        this.allocateSize = allocateSize;\n        this.dataView = new DataView(new ArrayBuffer(initialSize));\n    }\n\n    private ensureSizeOrGrow(bytes: number) {\n        const requiredSize = this.bytePosition + bytes;\n        if (requiredSize > this.size) {\n            const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n            if (requiredSize > nextSize) {\n                throw new Error(\n                    `SizeLimitExceeded: Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n                );\n            }\n\n            this.size = nextSize;\n            const nextBuffer = new ArrayBuffer(this.size);\n            new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n            this.dataView = new DataView(nextBuffer);\n        }\n    }\n\n    /**\n     * Shift current cursor position by `bytes`.\n     *\n     * @param {Number} bytes Number of bytes to\n     * @returns {this} Self for possible chaining.\n     */\n    shift(bytes: number): this {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n     * Write a U8 value into a buffer and shift cursor position by 1.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write8(value: number | bigint): this {\n        this.ensureSizeOrGrow(1);\n        this.dataView.setUint8(this.bytePosition, Number(value));\n        return this.shift(1);\n    }\n    /**\n     * Write a U16 value into a buffer and shift cursor position by 2.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write16(value: number | bigint): this {\n        this.ensureSizeOrGrow(2);\n        this.dataView.setUint16(this.bytePosition, Number(value), true);\n        return this.shift(2);\n    }\n    /**\n     * Write a U32 value into a buffer and shift cursor position by 4.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write32(value: number | bigint): this {\n        this.ensureSizeOrGrow(4);\n        this.dataView.setUint32(this.bytePosition, Number(value), true);\n        return this.shift(4);\n    }\n    /**\n     * Write a U64 value into a buffer and shift cursor position by 8.\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write64(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a U128 value into a buffer and shift cursor position by 16.\n     *\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write128(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a U256 value into a buffer and shift cursor position by 16.\n     *\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write256(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a ULEB value into a buffer and shift cursor position by number of bytes\n     * written.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    writeULEB(value: number): this {\n        ulebEncode(value).forEach((el) => this.write8(el));\n        return this;\n    }\n    /**\n     * Write a vector into a buffer by first writing the vector length and then calling\n     * a callback on each passed value.\n     *\n     * @param {Array<Any>} vector Array of elements to write.\n     * @param {WriteVecCb} cb Callback to call on each element of the vector.\n     * @returns {this}\n     */\n    writeVec(\n        vector: any[],\n        cb: (writer: BcsWriter, el: any, i: number, len: number) => void,\n    ): this {\n        this.writeULEB(vector.length);\n        Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n        return this;\n    }\n\n    /**\n     * Adds support for iterations over the object.\n     * @returns {Uint8Array}\n     */\n    *[Symbol.iterator](): Iterator<number, Iterable<number>> {\n        for (let i = 0; i < this.bytePosition; i++) {\n            yield this.dataView.getUint8(i);\n        }\n        return this.toBytes();\n    }\n\n    /**\n     * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n     * @returns {Uint8Array} Resulting bcs.\n     */\n    toBytes(): Uint8Array {\n        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n    }\n\n    /**\n     * Represent data as 'hex' or 'base64'\n     * @param encoding Encoding to use: 'base64' or 'hex'\n     */\n    toString(encoding: Encoding): string {\n        return encodeStr(this.toBytes(), encoding);\n    }\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n    const result = new Uint8Array(size);\n    let i = 0;\n    while (bigint > 0) {\n        result[i] = Number(bigint % BigInt(256));\n        bigint = bigint / BigInt(256);\n        i += 1;\n    }\n    return result;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58.js';\nimport { fromB64, toB64 } from './b64.js';\nimport { fromHEX, toHEX } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n    name?: string;\n    validate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n    $inferType!: T;\n    $inferInput!: Input;\n    name: string;\n    read: (reader: BcsReader) => T;\n    serializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n    validate: (value: Input) => void;\n    #write: (value: Input, writer: BcsWriter) => void;\n    #serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n    constructor(\n        options: {\n            name: string;\n            read: (reader: BcsReader) => T;\n            write: (value: Input, writer: BcsWriter) => void;\n            serialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n            serializedSize?: (value: Input) => number | null;\n            validate?: (value: Input) => void;\n        } & BcsTypeOptions<T, Input>,\n    ) {\n        this.name = options.name;\n        this.read = options.read;\n        this.serializedSize = options.serializedSize ?? (() => null);\n        this.#write = options.write;\n        this.#serialize =\n            options.serialize ??\n            ((value, options) => {\n                const writer = new BcsWriter({\n                    initialSize: this.serializedSize(value) ?? undefined,\n                    ...options,\n                });\n                this.#write(value, writer);\n                return writer.toBytes();\n            });\n\n        this.validate = options.validate ?? (() => {});\n    }\n\n    write(value: Input, writer: BcsWriter) {\n        this.validate(value);\n        this.#write(value, writer);\n    }\n\n    serialize(value: Input, options?: BcsWriterOptions) {\n        this.validate(value);\n        return new SerializedBcs(this, this.#serialize(value, options));\n    }\n\n    parse(bytes: Uint8Array): T {\n        const reader = new BcsReader(bytes);\n        return this.read(reader);\n    }\n\n    fromHex(hex: string) {\n        return this.parse(fromHEX(hex));\n    }\n\n    fromBase58(b64: string) {\n        return this.parse(fromB58(b64));\n    }\n\n    fromBase64(b64: string) {\n        return this.parse(fromB64(b64));\n    }\n\n    transform<T2 = T, Input2 = Input>({\n        name,\n        input,\n        output,\n        validate,\n    }: {\n        input?: (val: Input2) => Input;\n        output?: (value: T) => T2;\n    } & BcsTypeOptions<T2, Input2>) {\n        return new BcsType<T2, Input2>({\n            name: name ?? this.name,\n            read: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n            write: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n            serializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n            serialize: (value, options) =>\n                this.#serialize(input ? input(value) : (value as never), options),\n            validate: (value) => {\n                validate?.(value);\n                this.validate(input ? input(value) : (value as never));\n            },\n        });\n    }\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@iota/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n    return !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n    #schema: BcsType<T, Input>;\n    #bytes: Uint8Array;\n\n    // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n    // of the @iota/bcs package are installed\n    get [SERIALIZED_BCS_BRAND]() {\n        return true;\n    }\n\n    constructor(type: BcsType<T, Input>, schema: Uint8Array) {\n        this.#schema = type;\n        this.#bytes = schema;\n    }\n\n    toBytes() {\n        return this.#bytes;\n    }\n\n    toHex() {\n        return toHEX(this.#bytes);\n    }\n\n    toBase64() {\n        return toB64(this.#bytes);\n    }\n\n    toBase58() {\n        return toB58(this.#bytes);\n    }\n\n    parse() {\n        return this.#schema.parse(this.#bytes);\n    }\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n    size,\n    ...options\n}: {\n    name: string;\n    size: number;\n    read: (reader: BcsReader) => T;\n    write: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n    return new BcsType<T, Input>({\n        ...options,\n        serializedSize: () => size,\n    });\n}\n\nexport function uIntBcsType({\n    readMethod,\n    writeMethod,\n    ...options\n}: {\n    name: string;\n    size: number;\n    readMethod: `read${8 | 16 | 32}`;\n    writeMethod: `write${8 | 16 | 32}`;\n    maxValue: number;\n} & BcsTypeOptions<number, number>) {\n    return fixedSizeBcsType<number>({\n        ...options,\n        read: (reader) => reader[readMethod](),\n        write: (value, writer) => writer[writeMethod](value),\n        validate: (value) => {\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(\n                    `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n                );\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function bigUIntBcsType({\n    readMethod,\n    writeMethod,\n    ...options\n}: {\n    name: string;\n    size: number;\n    readMethod: `read${64 | 128 | 256}`;\n    writeMethod: `write${64 | 128 | 256}`;\n    maxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n    return fixedSizeBcsType<string, string | number | bigint>({\n        ...options,\n        read: (reader) => reader[readMethod](),\n        write: (value, writer) => writer[writeMethod](BigInt(value)),\n        validate: (val) => {\n            const value = BigInt(val);\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(\n                    `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n                );\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n    serialize,\n    ...options\n}: {\n    name: string;\n    read: (reader: BcsReader) => T;\n    serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n    const type = new BcsType<T, Input>({\n        ...options,\n        serialize,\n        write: (value, writer) => {\n            for (const byte of type.serialize(value).toBytes()) {\n                writer.write8(byte);\n            }\n        },\n    });\n\n    return type;\n}\n\nexport function stringLikeBcsType({\n    toBytes,\n    fromBytes,\n    ...options\n}: {\n    name: string;\n    toBytes: (value: string) => Uint8Array;\n    fromBytes: (bytes: Uint8Array) => string;\n    serializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n    return new BcsType<string>({\n        ...options,\n        read: (reader) => {\n            const length = reader.readULEB();\n            const bytes = reader.readBytes(length);\n\n            return fromBytes(bytes);\n        },\n        write: (hex, writer) => {\n            const bytes = toBytes(hex);\n            writer.writeULEB(bytes.length);\n            for (let i = 0; i < bytes.length; i++) {\n                writer.write8(bytes[i]);\n            }\n        },\n        serialize: (value) => {\n            const bytes = toBytes(value);\n            const size = ulebEncode(bytes.length);\n            const result = new Uint8Array(size.length + bytes.length);\n            result.set(size, 0);\n            result.set(bytes, size.length);\n\n            return result;\n        },\n        validate: (value) => {\n            if (typeof value !== 'string') {\n                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n    let lazyType: BcsType<T, Input> | null = null;\n    function getType() {\n        if (!lazyType) {\n            lazyType = cb();\n        }\n        return lazyType;\n    }\n\n    return new BcsType<T, Input>({\n        name: 'lazy' as never,\n        read: (data) => getType().read(data),\n        serializedSize: (value) => getType().serializedSize(value),\n        write: (value, writer) => getType().write(value, writer),\n        serialize: (value, options) => getType().serialize(value, options).toBytes(),\n    });\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n    BcsType,\n    bigUIntBcsType,\n    dynamicSizeBcsType,\n    fixedSizeBcsType,\n    lazyBcsType,\n    stringLikeBcsType,\n    uIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n    /**\n     * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n     * @example\n     * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n     */\n    u8(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u8',\n            readMethod: 'read8',\n            writeMethod: 'write8',\n            size: 1,\n            maxValue: 2 ** 8 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n     * @example\n     * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n     */\n    u16(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u16',\n            readMethod: 'read16',\n            writeMethod: 'write16',\n            size: 2,\n            maxValue: 2 ** 16 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n     * @example\n     * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n     */\n    u32(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u32',\n            readMethod: 'read32',\n            writeMethod: 'write32',\n            size: 4,\n            maxValue: 2 ** 32 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n     * @example\n     * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n     */\n    u64(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u64',\n            readMethod: 'read64',\n            writeMethod: 'write64',\n            size: 8,\n            maxValue: 2n ** 64n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n     * @example\n     * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n     */\n    u128(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u128',\n            readMethod: 'read128',\n            writeMethod: 'write128',\n            size: 16,\n            maxValue: 2n ** 128n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n     * @example\n     * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n     */\n    u256(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u256',\n            readMethod: 'read256',\n            writeMethod: 'write256',\n            size: 32,\n            maxValue: 2n ** 256n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write boolean values.\n     * @example\n     * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n     */\n    bool(options?: BcsTypeOptions<boolean>) {\n        return fixedSizeBcsType<boolean>({\n            name: 'bool',\n            size: 1,\n            read: (reader) => reader.read8() === 1,\n            write: (value, writer) => writer.write8(value ? 1 : 0),\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'boolean') {\n                    throw new TypeError(`Expected boolean, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n     * @example\n     *\n     */\n    uleb128(options?: BcsTypeOptions<number>) {\n        return dynamicSizeBcsType<number>({\n            name: 'uleb128',\n            read: (reader) => reader.readULEB(),\n            serialize: (value) => {\n                return Uint8Array.from(ulebEncode(value));\n            },\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a fixed length byte array\n     * @param size The number of bytes this types represents\n     * @example\n     * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n     */\n    bytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n        return fixedSizeBcsType<Uint8Array>({\n            name: `bytes[${size}]`,\n            size,\n            read: (reader) => reader.readBytes(size),\n            write: (value, writer) => {\n                for (let i = 0; i < size; i++) {\n                    writer.write8(value[i] ?? 0);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a variable length byte array\n     *\n     * @example\n     * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n     */\n    byteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n        return new BcsType<Uint8Array, Iterable<number>>({\n            name: `bytesVector`,\n            read: (reader) => {\n                const length = reader.readULEB();\n\n                return reader.readBytes(length);\n            },\n            write: (value, writer) => {\n                const array = new Uint8Array(value);\n                writer.writeULEB(array.length);\n                for (let i = 0; i < array.length; i++) {\n                    writer.write8(array[i] ?? 0);\n                }\n            },\n            ...options,\n            serializedSize: (value) => {\n                const length = 'length' in value ? (value.length as number) : null;\n                return length == null ? null : ulebEncode(length).length + length;\n            },\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n     * @example\n     * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n     */\n    string(options?: BcsTypeOptions<string>) {\n        return stringLikeBcsType({\n            name: 'string',\n            toBytes: (value) => new TextEncoder().encode(value),\n            fromBytes: (bytes) => new TextDecoder().decode(bytes),\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that represents a fixed length array of a given type\n     * @param size The number of elements in the array\n     * @param type The BcsType of each element in the array\n     * @example\n     * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n     */\n    fixedArray<T, Input>(\n        size: number,\n        type: BcsType<T, Input>,\n        options?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n    ) {\n        return new BcsType<T[], Iterable<Input> & { length: number }>({\n            name: `${type.name}[${size}]`,\n            read: (reader) => {\n                const result: T[] = new Array(size);\n                for (let i = 0; i < size; i++) {\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer) => {\n                for (const item of value) {\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing an optional value\n     * @param type The BcsType of the optional value\n     * @example\n     * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n     * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n     */\n    option<T, Input>(type: BcsType<T, Input>) {\n        return bcs\n            .enum(`Option<${type.name}>`, {\n                None: null,\n                Some: type,\n            })\n            .transform({\n                input: (value: Input | null | undefined) => {\n                    if (value == null) {\n                        return { None: true };\n                    }\n\n                    return { Some: value };\n                },\n                output: (value) => {\n                    if (value.$kind === 'Some') {\n                        return value.Some;\n                    }\n\n                    return null;\n                },\n            });\n    },\n\n    /**\n     * Creates a BcsType representing a variable length vector of a given type\n     * @param type The BcsType of each element in the vector\n     *\n     * @example\n     * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n     */\n    vector<T, Input>(\n        type: BcsType<T, Input>,\n        options?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n    ) {\n        return new BcsType<T[], Iterable<Input> & { length: number }>({\n            name: `vector<${type.name}>`,\n            read: (reader) => {\n                const length = reader.readULEB();\n                const result: T[] = new Array(length);\n                for (let i = 0; i < length; i++) {\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer) => {\n                writer.writeULEB(value.length);\n                for (const item of value) {\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a tuple of a given set of types\n     * @param types The BcsTypes for each element in the tuple\n     *\n     * @example\n     * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n     * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n     */\n    tuple<const Types extends readonly BcsType<any>[]>(\n        types: Types,\n        options?: BcsTypeOptions<\n            {\n                -readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n            },\n            {\n                [K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n            }\n        >,\n    ) {\n        return new BcsType<\n            {\n                -readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n            },\n            {\n                [K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n            }\n        >({\n            name: `(${types.map((t) => t.name).join(', ')})`,\n            serializedSize: (values) => {\n                let total = 0;\n                for (let i = 0; i < types.length; i++) {\n                    const size = types[i].serializedSize(values[i]);\n                    if (size == null) {\n                        return null;\n                    }\n\n                    total += size;\n                }\n\n                return total;\n            },\n            read: (reader) => {\n                const result: unknown[] = [];\n                for (const type of types) {\n                    result.push(type.read(reader));\n                }\n                return result as never;\n            },\n            write: (value, writer) => {\n                for (let i = 0; i < types.length; i++) {\n                    types[i].write(value[i], writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!Array.isArray(value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== types.length) {\n                    throw new TypeError(\n                        `Expected array of length ${types.length}, found ${value.length}`,\n                    );\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a struct of a given set of fields\n     * @param name The name of the struct\n     * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n     *\n     * @example\n     * const struct = bcs.struct('MyStruct', {\n     *  a: bcs.u8(),\n     *  b: bcs.string(),\n     * })\n     * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n     */\n    struct<T extends Record<string, BcsType<any>>>(\n        name: string,\n        fields: T,\n        options?: Omit<\n            BcsTypeOptions<\n                {\n                    [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n                },\n                {\n                    [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n                }\n            >,\n            'name'\n        >,\n    ) {\n        const canonicalOrder = Object.entries(fields);\n\n        return new BcsType<\n            {\n                [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n            },\n            {\n                [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n            }\n        >({\n            name,\n            serializedSize: (values) => {\n                let total = 0;\n                for (const [field, type] of canonicalOrder) {\n                    const size = type.serializedSize(values[field]);\n                    if (size == null) {\n                        return null;\n                    }\n\n                    total += size;\n                }\n\n                return total;\n            },\n            read: (reader) => {\n                const result: Record<string, unknown> = {};\n                for (const [field, type] of canonicalOrder) {\n                    result[field] = type.read(reader);\n                }\n\n                return result as never;\n            },\n            write: (value, writer) => {\n                for (const [field, type] of canonicalOrder) {\n                    type.write(value[field], writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'object' || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing an enum of a given set of options\n     * @param name The name of the enum\n     * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n     * null can be used to represent a variant with no data.\n     *\n     * @example\n     * const enum = bcs.enum('MyEnum', {\n     *   A: bcs.u8(),\n     *   B: bcs.string(),\n     *   C: null,\n     * })\n     * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n     * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n     * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n     */\n    enum<T extends Record<string, BcsType<any> | null>>(\n        name: string,\n        values: T,\n        options?: Omit<\n            BcsTypeOptions<\n                EnumOutputShape<{\n                    [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n                }>,\n                EnumInputShape<{\n                    [K in keyof T]: T[K] extends BcsType<any, infer U>\n                        ? U\n                        : boolean | object | null;\n                }>\n            >,\n            'name'\n        >,\n    ) {\n        const canonicalOrder = Object.entries(values as object);\n        return new BcsType<\n            EnumOutputShape<{\n                [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n            }>,\n            EnumInputShape<{\n                [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n            }>\n        >({\n            name,\n            read: (reader) => {\n                const index = reader.readULEB();\n\n                const enumEntry = canonicalOrder[index];\n                if (!enumEntry) {\n                    throw new TypeError(`Unknown value ${index} for enum ${name}`);\n                }\n\n                const [kind, type] = enumEntry;\n\n                return {\n                    [kind]: type?.read(reader) ?? true,\n                    $kind: kind,\n                } as never;\n            },\n            write: (value, writer) => {\n                const [name, val] = Object.entries(value).filter(([name]) =>\n                    Object.hasOwn(values, name),\n                )[0];\n\n                for (let i = 0; i < canonicalOrder.length; i++) {\n                    const [optionName, optionType] = canonicalOrder[i];\n                    if (optionName === name) {\n                        writer.writeULEB(i);\n                        optionType?.write(val, writer);\n                        return;\n                    }\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'object' || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n\n                const keys = Object.keys(value).filter(\n                    (k) => value[k] !== undefined && Object.hasOwn(values, k),\n                );\n\n                if (keys.length !== 1) {\n                    throw new TypeError(\n                        `Expected object with one key, but found ${keys.length} for type ${name}}`,\n                    );\n                }\n\n                const [variant] = keys;\n\n                if (!Object.hasOwn(values, variant)) {\n                    throw new TypeError(`Invalid enum variant ${variant}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a map of a given key and value type\n     * @param keyType The BcsType of the key\n     * @param valueType The BcsType of the value\n     * @example\n     * const map = bcs.map(bcs.u8(), bcs.string())\n     * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n     */\n    map<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n        return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n            name: `Map<${keyType.name}, ${valueType.name}>`,\n            input: (value: Map<InputK, InputV>) => {\n                return [...value.entries()];\n            },\n            output: (value) => {\n                const result = new Map<K, V>();\n                for (const [key, val] of value) {\n                    result.set(key, val);\n                }\n                return result;\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n     * @param cb A callback that returns the BcsType\n     */\n    lazy<T extends BcsType<any>>(cb: () => T): T {\n        return lazyBcsType(cb) as T;\n    },\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, splitGenericParameters } from '@iota/bcs';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n    try {\n        const buffer = fromB58(value);\n        return buffer.length === TX_DIGEST_LENGTH;\n    } catch (e) {\n        return false;\n    }\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/iotaledger/iota/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/iota-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const IOTA_ADDRESS_LENGTH = 32;\nexport function isValidIotaAddress(value: string): value is string {\n    return isHex(value) && getHexByteLength(value) === IOTA_ADDRESS_LENGTH;\n}\n\nexport function isValidIotaObjectId(value: string): boolean {\n    return isValidIotaAddress(value);\n}\n\ntype StructTag = {\n    address: string;\n    module: string;\n    name: string;\n    typeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n    if (!type.includes('::')) return type;\n\n    return parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n    const [address, module] = type.split('::');\n\n    const rest = type.slice(address.length + module.length + 4);\n    const name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n    const typeParams = rest.includes('<')\n        ? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n              (typeParam) => parseTypeTag(typeParam.trim()),\n          )\n        : [];\n\n    return {\n        address: normalizeIotaAddress(address),\n        module,\n        name,\n        typeParams,\n    };\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n    const { address, module, name, typeParams } =\n        typeof type === 'string' ? parseStructTag(type) : type;\n\n    const formattedTypeParams =\n        typeParams?.length > 0\n            ? `<${typeParams\n                  .map((typeParam) =>\n                      typeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n                  )\n                  .join(',')}>`\n            : '';\n\n    return `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Normalize an IOTA address to ensure consistent format.\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `IOTA_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n * @param value The address to normalize\n * @param forceAdd0x Whether to add 0x prefix without removing any existing 0x prefixes\n * @param validate Whether to validate the return address\n * @returns The normalized address\n * @throws Error if flag `validate` enabled and the address contains invalid hex characters\n */\nexport function normalizeIotaAddress(\n    value: string,\n    forceAdd0x: boolean = false,\n    validate: boolean = false,\n): string {\n    let address = value.toLowerCase().replace(/ /g, '');\n    if (!forceAdd0x && address.startsWith('0x')) {\n        address = address.slice(2);\n    }\n    address = `0x${address.padStart(IOTA_ADDRESS_LENGTH * 2, '0')}`;\n    if (validate && !isValidIotaAddress(address)) {\n        throw new Error(`Invalid IOTA address: ${value}`);\n    } else {\n        return address;\n    }\n}\n\nexport function normalizeIotaObjectId(\n    value: string,\n    forceAdd0x: boolean = false,\n    validate: boolean = false,\n): string {\n    return normalizeIotaAddress(value, forceAdd0x, validate);\n}\n\nfunction isHex(value: string): boolean {\n    return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n    return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@iota/bcs';\n\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n    static parseFromStr(str: string, normalizeAddress = false): TypeTag {\n        if (str === 'address') {\n            return { address: null };\n        } else if (str === 'bool') {\n            return { bool: null };\n        } else if (str === 'u8') {\n            return { u8: null };\n        } else if (str === 'u16') {\n            return { u16: null };\n        } else if (str === 'u32') {\n            return { u32: null };\n        } else if (str === 'u64') {\n            return { u64: null };\n        } else if (str === 'u128') {\n            return { u128: null };\n        } else if (str === 'u256') {\n            return { u256: null };\n        } else if (str === 'signer') {\n            return { signer: null };\n        }\n\n        const vectorMatch = str.match(VECTOR_REGEX);\n        if (vectorMatch) {\n            return {\n                vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n            };\n        }\n\n        const structMatch = str.match(STRUCT_REGEX);\n        if (structMatch) {\n            const address = normalizeAddress\n                ? normalizeIotaAddress(structMatch[1])\n                : structMatch[1];\n            return {\n                struct: {\n                    address,\n                    module: structMatch[2],\n                    name: structMatch[3],\n                    typeParams:\n                        structMatch[5] === undefined\n                            ? []\n                            : TypeTagSerializer.parseStructTypeArgs(\n                                  structMatch[5],\n                                  normalizeAddress,\n                              ),\n                },\n            };\n        }\n\n        throw new Error(`Encountered unexpected token when parsing type args for ${str}`);\n    }\n\n    static parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n        return splitGenericParameters(str).map((tok) =>\n            TypeTagSerializer.parseFromStr(tok, normalizeAddress),\n        );\n    }\n\n    static tagToString(tag: TypeTag): string {\n        if ('bool' in tag) {\n            return 'bool';\n        }\n        if ('u8' in tag) {\n            return 'u8';\n        }\n        if ('u16' in tag) {\n            return 'u16';\n        }\n        if ('u32' in tag) {\n            return 'u32';\n        }\n        if ('u64' in tag) {\n            return 'u64';\n        }\n        if ('u128' in tag) {\n            return 'u128';\n        }\n        if ('u256' in tag) {\n            return 'u256';\n        }\n        if ('address' in tag) {\n            return 'address';\n        }\n        if ('signer' in tag) {\n            return 'signer';\n        }\n        if ('vector' in tag) {\n            return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n        }\n        if ('struct' in tag) {\n            const struct = tag.struct;\n            const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n            return `${struct.address}::${struct.module}::${struct.name}${\n                typeParams ? `<${typeParams}>` : ''\n            }`;\n        }\n        throw new Error('Invalid TypeTag');\n    }\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@iota/bcs';\nimport { bcs, fromB58, fromB64, fromHEX, toB58, toB64, toHEX } from '@iota/bcs';\n\nimport {\n    isValidIotaAddress,\n    normalizeIotaAddress,\n    IOTA_ADDRESS_LENGTH,\n} from '../utils/iota-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n    return bcs\n        .u64({\n            name: 'unsafe_u64',\n            ...(options as object),\n        })\n        .transform({\n            input: (val: number | string) => val,\n            output: (val) => Number(val),\n        });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n    return bcs.enum('Option', {\n        None: null,\n        Some: type,\n    });\n}\n\nexport const Address = bcs.bytes(IOTA_ADDRESS_LENGTH).transform({\n    validate: (val) => {\n        const address = typeof val === 'string' ? val : toHEX(val);\n        if (!address || !isValidIotaAddress(normalizeIotaAddress(address))) {\n            throw new Error(`Invalid IOTA address ${address}`);\n        }\n    },\n    input: (val: string | Uint8Array) =>\n        typeof val === 'string' ? fromHEX(normalizeIotaAddress(val)) : val,\n    output: (val) => normalizeIotaAddress(toHEX(val)),\n});\n\nexport const ObjectDigest = bcs.vector(bcs.u8()).transform({\n    name: 'ObjectDigest',\n    input: (value: string) => fromB58(value),\n    output: (value) => toB58(new Uint8Array(value)),\n    validate: (value) => {\n        if (fromB58(value).length !== 32) {\n            throw new Error('ObjectDigest must be 32 bytes');\n        }\n    },\n});\n\nexport const IotaObjectRef = bcs.struct('IotaObjectRef', {\n    objectId: Address,\n    version: bcs.u64(),\n    digest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n    objectId: Address,\n    initialSharedVersion: bcs.u64(),\n    mutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n    ImmOrOwnedObject: IotaObjectRef,\n    SharedObject: SharedObjectRef,\n    Receiving: IotaObjectRef,\n});\n\nexport const Owner = bcs.enum('Owner', {\n    AddressOwner: Address,\n    ObjectOwner: Address,\n    Shared: bcs.struct('Shared', {\n        initialSharedVersion: bcs.u64(),\n    }),\n    Immutable: null,\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n    Pure: bcs.struct('Pure', {\n        bytes: bcs.vector(bcs.u8()).transform({\n            input: (val: string | Uint8Array) => (typeof val === 'string' ? fromB64(val) : val),\n            output: (val) => toB64(new Uint8Array(val)),\n        }),\n    }),\n    Object: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n    bool: null,\n    u8: null,\n    u64: null,\n    u128: null,\n    address: null,\n    signer: null,\n    vector: bcs.lazy(() => InnerTypeTag),\n    struct: bcs.lazy(() => StructTag),\n    u16: null,\n    u32: null,\n    u256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n    input: (typeTag: string | TypeTagType) =>\n        typeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n    output: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n    GasCoin: null,\n    Input: bcs.u16(),\n    Result: bcs.u16(),\n    NestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n    package: Address,\n    module: bcs.string(),\n    function: bcs.string(),\n    typeArguments: bcs.vector(TypeTag),\n    arguments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n    /**\n     * A Move Call - any public Move function can be called via\n     * this transaction. The results can be used that instant to pass\n     * into the next transaction.\n     */\n    MoveCall: ProgrammableMoveCall,\n    /**\n     * Transfer vector of objects to a receiver.\n     */\n    TransferObjects: bcs.struct('TransferObjects', {\n        objects: bcs.vector(Argument),\n        address: Argument,\n    }),\n    // /**\n    //  * Split `amount` from a `coin`.\n    //  */\n    SplitCoins: bcs.struct('SplitCoins', {\n        coin: Argument,\n        amounts: bcs.vector(Argument),\n    }),\n    // /**\n    //  * Merge Vector of Coins (`sources`) into a `destination`.\n    //  */\n    MergeCoins: bcs.struct('MergeCoins', {\n        destination: Argument,\n        sources: bcs.vector(Argument),\n    }),\n    // /**\n    //  * Publish a Move module.\n    //  */\n    Publish: bcs.struct('Publish', {\n        modules: bcs.vector(\n            bcs.vector(bcs.u8()).transform({\n                input: (val: string | Uint8Array) => (typeof val === 'string' ? fromB64(val) : val),\n                output: (val) => toB64(new Uint8Array(val)),\n            }),\n        ),\n        dependencies: bcs.vector(Address),\n    }),\n    // /**\n    //  * Build a vector of objects using the input arguments.\n    //  * It is impossible to export construct a `vector<T: key>` otherwise,\n    //  * so this call serves a utility function.\n    //  */\n    MakeMoveVec: bcs.struct('MakeMoveVec', {\n        type: optionEnum(TypeTag).transform({\n            input: (val: string | null) =>\n                val === null\n                    ? {\n                          None: true,\n                      }\n                    : {\n                          Some: val,\n                      },\n            output: (val) => val.Some ?? null,\n        }),\n        elements: bcs.vector(Argument),\n    }),\n    Upgrade: bcs.struct('Upgrade', {\n        modules: bcs.vector(\n            bcs.vector(bcs.u8()).transform({\n                input: (val: string | Uint8Array) => (typeof val === 'string' ? fromB64(val) : val),\n                output: (val) => toB64(new Uint8Array(val)),\n            }),\n        ),\n        dependencies: bcs.vector(Address),\n        package: Address,\n        ticket: Argument,\n    }),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n    inputs: bcs.vector(CallArg),\n    commands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n    ProgrammableTransaction: ProgrammableTransaction,\n    ChangeEpoch: null,\n    Genesis: null,\n    ConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n    None: null,\n    Epoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n    address: Address,\n    module: bcs.string(),\n    name: bcs.string(),\n    typeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n    payment: bcs.vector(IotaObjectRef),\n    owner: Address,\n    price: bcs.u64(),\n    budget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n    kind: TransactionKind,\n    sender: Address,\n    gasData: GasData,\n    expiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n    V1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n    TransactionData: null,\n    TransactionEffects: null,\n    CheckpointSummary: null,\n    PersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n    V0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n    Iota: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n    scope: IntentScope,\n    version: IntentVersion,\n    appId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n    return bcs.struct(`IntentMessage<${T.name}>`, {\n        intent: Intent,\n        value: T,\n    });\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n    ED25519: bcs.fixedArray(64, bcs.u8()),\n    Secp256k1: bcs.fixedArray(64, bcs.u8()),\n    Secp256r1: bcs.fixedArray(64, bcs.u8()),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n    ED25519: bcs.fixedArray(32, bcs.u8()),\n    Secp256k1: bcs.fixedArray(33, bcs.u8()),\n    Secp256r1: bcs.fixedArray(33, bcs.u8()),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n    pubKey: PublicKey,\n    weight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n    pk_map: bcs.vector(MultiSigPkMap),\n    threshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n    sigs: bcs.vector(CompressedSignature),\n    bitmap: bcs.u16(),\n    multisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.vector(bcs.u8()).transform({\n    input: (val: string | Uint8Array) => (typeof val === 'string' ? fromB64(val) : val),\n    output: (val) => toB64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n    intentMessage: IntentMessage(TransactionData),\n    txSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n    name: 'SenderSignedData',\n});\n\nexport const PasskeyAuthenticator = bcs.struct('PasskeyAuthenticator', {\n    authenticatorData: bcs.vector(bcs.u8()),\n    clientDataJson: bcs.string(),\n    userSignature: bcs.vector(bcs.u8()),\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@iota/bcs';\n\nimport { Address, ObjectDigest, Owner } from './bcs.js';\n\nconst PackageUpgradeError = bcs.enum('PackageUpgradeError', {\n    UnableToFetchPackage: bcs.struct('UnableToFetchPackage', { packageId: Address }),\n    NotAPackage: bcs.struct('NotAPackage', { objectId: Address }),\n    IncompatibleUpgrade: null,\n    DigestDoesNotMatch: bcs.struct('DigestDoesNotMatch', { digest: bcs.vector(bcs.u8()) }),\n    UnknownUpgradePolicy: bcs.struct('UnknownUpgradePolicy', { policy: bcs.u8() }),\n    PackageIDDoesNotMatch: bcs.struct('PackageIDDoesNotMatch', {\n        packageId: Address,\n        ticketId: Address,\n    }),\n});\n\nconst ModuleId = bcs.struct('ModuleId', {\n    address: Address,\n    name: bcs.string(),\n});\nconst MoveLocation = bcs.struct('MoveLocation', {\n    module: ModuleId,\n    function: bcs.u16(),\n    instruction: bcs.u16(),\n    functionName: bcs.option(bcs.string()),\n});\n\nconst CommandArgumentError = bcs.enum('CommandArgumentError', {\n    TypeMismatch: null,\n    InvalidBCSBytes: null,\n    InvalidUsageOfPureArg: null,\n    InvalidArgumentToPrivateEntryFunction: null,\n    IndexOutOfBounds: bcs.struct('IndexOutOfBounds', { idx: bcs.u16() }),\n    SecondaryIndexOutOfBounds: bcs.struct('SecondaryIndexOutOfBounds', {\n        resultIdx: bcs.u16(),\n        secondaryIdx: bcs.u16(),\n    }),\n    InvalidResultArity: bcs.struct('InvalidResultArity', { resultIdx: bcs.u16() }),\n    InvalidGasCoinUsage: null,\n    InvalidValueUsage: null,\n    InvalidObjectByValue: null,\n    InvalidObjectByMutRef: null,\n    SharedObjectOperationNotAllowed: null,\n});\n\nconst TypeArgumentError = bcs.enum('TypeArgumentError', {\n    TypeNotFound: null,\n    ConstraintNotSatisfied: null,\n});\n\nconst ExecutionFailureStatus = bcs.enum('ExecutionFailureStatus', {\n    InsufficientGas: null,\n    InvalidGasObject: null,\n    InvariantViolation: null,\n    FeatureNotYetSupported: null,\n    MoveObjectTooBig: bcs.struct('MoveObjectTooBig', {\n        objectSize: bcs.u64(),\n        maxObjectSize: bcs.u64(),\n    }),\n    MovePackageTooBig: bcs.struct('MovePackageTooBig', {\n        objectSize: bcs.u64(),\n        maxObjectSize: bcs.u64(),\n    }),\n    CircularObjectOwnership: bcs.struct('CircularObjectOwnership', { object: Address }),\n    InsufficientCoinBalance: null,\n    CoinBalanceOverflow: null,\n    PublishErrorNonZeroAddress: null,\n    IotaMoveVerificationError: null,\n    MovePrimitiveRuntimeError: bcs.option(MoveLocation),\n    MoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n    VMVerificationOrDeserializationError: null,\n    VMInvariantViolation: null,\n    FunctionNotFound: null,\n    ArityMismatch: null,\n    TypeArityMismatch: null,\n    NonEntryFunctionInvoked: null,\n    CommandArgumentError: bcs.struct('CommandArgumentError', {\n        argIdx: bcs.u16(),\n        kind: CommandArgumentError,\n    }),\n    TypeArgumentError: bcs.struct('TypeArgumentError', {\n        argumentIdx: bcs.u16(),\n        kind: TypeArgumentError,\n    }),\n    UnusedValueWithoutDrop: bcs.struct('UnusedValueWithoutDrop', {\n        resultIdx: bcs.u16(),\n        secondaryIdx: bcs.u16(),\n    }),\n    InvalidPublicFunctionReturnType: bcs.struct('InvalidPublicFunctionReturnType', {\n        idx: bcs.u16(),\n    }),\n    InvalidTransferObject: null,\n    EffectsTooLarge: bcs.struct('EffectsTooLarge', { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n    PublishUpgradeMissingDependency: null,\n    PublishUpgradeDependencyDowngrade: null,\n    PackageUpgradeError: bcs.struct('PackageUpgradeError', { upgradeError: PackageUpgradeError }),\n    WrittenObjectsTooLarge: bcs.struct('WrittenObjectsTooLarge', {\n        currentSize: bcs.u64(),\n        maxSize: bcs.u64(),\n    }),\n    CertificateDenied: null,\n    IotaMoveVerificationTimedout: null,\n    SharedObjectOperationNotAllowed: null,\n    InputObjectDeleted: null,\n});\n\nconst ExecutionStatus = bcs.enum('ExecutionStatus', {\n    Success: null,\n    Failed: bcs.struct('ExecutionFailed', {\n        error: ExecutionFailureStatus,\n        command: bcs.option(bcs.u64()),\n    }),\n});\n\nconst GasCostSummary = bcs.struct('GasCostSummary', {\n    computationCost: bcs.u64(),\n    computationCostBurned: bcs.u64(),\n    storageCost: bcs.u64(),\n    storageRebate: bcs.u64(),\n    nonRefundableStorageFee: bcs.u64(),\n});\n\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\n\nconst ObjectIn = bcs.enum('ObjectIn', {\n    NotExist: null,\n    Exist: bcs.tuple([VersionDigest, Owner]),\n});\n\nexport const ObjectOut = bcs.enum('ObjectOut', {\n    NotExist: null,\n    ObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n    PackageWrite: VersionDigest,\n});\n\nconst IDOperation = bcs.enum('IDOperation', {\n    None: null,\n    Created: null,\n    Deleted: null,\n});\n\nconst EffectsObjectChange = bcs.struct('EffectsObjectChange', {\n    inputState: ObjectIn,\n    outputState: ObjectOut,\n    idOperation: IDOperation,\n});\n\nconst UnchangedSharedKind = bcs.enum('UnchangedSharedKind', {\n    ReadOnlyRoot: VersionDigest,\n    MutateDeleted: bcs.u64(),\n    ReadDeleted: bcs.u64(),\n    Cancelled: bcs.u64(),\n    PerEpochConfig: null,\n});\n\nconst TransactionEffectsV1 = bcs.struct('TransactionEffectsV1', {\n    status: ExecutionStatus,\n    executedEpoch: bcs.u64(),\n    gasUsed: GasCostSummary,\n    transactionDigest: ObjectDigest,\n    gasObjectIndex: bcs.option(bcs.u32()),\n    eventsDigest: bcs.option(ObjectDigest),\n    dependencies: bcs.vector(ObjectDigest),\n    lamportVersion: bcs.u64(),\n    changedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n    unchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n    auxDataDigest: bcs.option(ObjectDigest),\n});\n\nexport const TransactionEffects = bcs.enum('TransactionEffects', {\n    V1: TransactionEffectsV1,\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@iota/bcs';\n\nimport {\n    Address,\n    AppId,\n    Argument,\n    CallArg,\n    Command,\n    CompressedSignature,\n    GasData,\n    Intent,\n    IntentMessage,\n    IntentScope,\n    IntentVersion,\n    MultiSig,\n    MultiSigPkMap,\n    MultiSigPublicKey,\n    ObjectArg,\n    ObjectDigest,\n    Owner,\n    ProgrammableMoveCall,\n    ProgrammableTransaction,\n    PublicKey,\n    SenderSignedData,\n    SenderSignedTransaction,\n    SharedObjectRef,\n    StructTag,\n    IotaObjectRef,\n    TransactionData,\n    TransactionDataV1,\n    TransactionExpiration,\n    TransactionKind,\n    TypeTag,\n    PasskeyAuthenticator,\n} from './bcs.js';\nimport { TransactionEffects } from './effects.js';\n\nexport type { TypeTag } from './types.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\nexport { BcsType, type BcsTypeOptions } from '@iota/bcs';\n\nconst iotaBcs = {\n    ...bcs,\n    U8: bcs.u8(),\n    U16: bcs.u16(),\n    U32: bcs.u32(),\n    U64: bcs.u64(),\n    U128: bcs.u128(),\n    U256: bcs.u256(),\n    ULEB128: bcs.uleb128(),\n    Bool: bcs.bool(),\n    String: bcs.string(),\n    Address,\n    AppId,\n    Argument,\n    CallArg,\n    CompressedSignature,\n    GasData,\n    Intent,\n    IntentMessage,\n    IntentScope,\n    IntentVersion,\n    MultiSig,\n    MultiSigPkMap,\n    MultiSigPublicKey,\n    ObjectArg,\n    ObjectDigest,\n    Owner,\n    ProgrammableMoveCall,\n    ProgrammableTransaction,\n    PublicKey,\n    SenderSignedData,\n    SenderSignedTransaction,\n    SharedObjectRef,\n    StructTag,\n    IotaObjectRef,\n    Command,\n    TransactionData,\n    TransactionDataV1,\n    TransactionExpiration,\n    TransactionKind,\n    TypeTag,\n    TransactionEffects,\n    PasskeyAuthenticator,\n};\n\nexport { iotaBcs as bcs };\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isValidIotaAddress, isValidIotaObjectId, IOTA_ADDRESS_LENGTH } from './iota-types.js';\n\nconst ELLIPSIS = '\\u{2026}';\n\nexport function formatAddress(address: string) {\n    if (address.length <= 6) {\n        return address;\n    }\n\n    const offset = address.startsWith('0x') ? 2 : 0;\n\n    return `0x${address.slice(offset, offset + 4)}${ELLIPSIS}${address.slice(-4)}`;\n}\n\nexport function formatDigest(digest: string) {\n    // Use 10 first characters\n    return `${digest.slice(0, 10)}${ELLIPSIS}`;\n}\n\nexport function formatType(type: string) {\n    const objectAddressPattern = new RegExp(`0x[a-fA-F0-9]{${IOTA_ADDRESS_LENGTH * 2}}`, 'g');\n    const matches = type.match(objectAddressPattern) ?? [];\n    for (const match of matches) {\n        if (isValidIotaAddress(match) || isValidIotaObjectId(match)) {\n            type = type.replace(match, formatAddress(match));\n        }\n    }\n    return type;\n}\n\nconst ADDRESS_TRIM_MAX_LENGTH = 8;\n\nexport function trimAddress(address: string): string {\n    const addr = address.toLowerCase().replace(/^0x/, '');\n    const shortened = addr.replace(/^0+/, '') || '0';\n    return `0x${shortened}`;\n}\n\nexport function trimOrFormatAddress(address: string): string {\n    if (address.length <= 6) {\n        return address;\n    }\n\n    const trimmedAddress = trimAddress(address);\n\n    if (trimmedAddress.length <= ADDRESS_TRIM_MAX_LENGTH) {\n        return trimmedAddress;\n    }\n\n    return formatAddress(address);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { normalizeIotaObjectId } from './iota-types.js';\n\nexport const IOTA_DECIMALS = 9;\nexport const NANOS_PER_IOTA = BigInt(1000000000);\n\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const IOTA_FRAMEWORK_ADDRESS = '0x2';\nexport const IOTA_SYSTEM_ADDRESS = '0x3';\nexport const IOTA_CLOCK_OBJECT_ID = normalizeIotaObjectId('0x6');\nexport const IOTA_SYSTEM_MODULE_NAME = 'iota_system';\nexport const IOTA_TYPE_ARG = `${IOTA_FRAMEWORK_ADDRESS}::iota::IOTA`;\nexport const IOTA_SYSTEM_STATE_OBJECT_ID: string = normalizeIotaObjectId('0x5');\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@iota/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { IotaMoveNormalizedType } from '../client/index.js';\nimport { MOVE_STDLIB_ADDRESS, IOTA_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { OpenMoveTypeSignature, OpenMoveTypeSignatureBody } from './data/internal.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nexport function isTxContext(param: OpenMoveTypeSignature): boolean {\n    const struct =\n        typeof param.body === 'object' && 'datatype' in param.body ? param.body.datatype : null;\n\n    return (\n        !!struct &&\n        normalizeIotaAddress(struct.package) === normalizeIotaAddress('0x2') &&\n        struct.module === 'tx_context' &&\n        struct.type === 'TxContext'\n    );\n}\n\nexport function getPureBcsSchema(typeSignature: OpenMoveTypeSignatureBody): BcsType<any> | null {\n    if (typeof typeSignature === 'string') {\n        switch (typeSignature) {\n            case 'address':\n                return bcs.Address;\n            case 'bool':\n                return bcs.Bool;\n            case 'u8':\n                return bcs.U8;\n            case 'u16':\n                return bcs.U16;\n            case 'u32':\n                return bcs.U32;\n            case 'u64':\n                return bcs.U64;\n            case 'u128':\n                return bcs.U128;\n            case 'u256':\n                return bcs.U256;\n            default:\n                throw new Error(`Unknown type signature ${typeSignature}`);\n        }\n    }\n\n    if ('vector' in typeSignature) {\n        if (typeSignature.vector === 'u8') {\n            return bcs.vector(bcs.U8).transform({\n                input: (val: string | Uint8Array) =>\n                    typeof val === 'string' ? new TextEncoder().encode(val) : val,\n                output: (val) => val,\n            });\n        }\n        const type = getPureBcsSchema(typeSignature.vector);\n        return type ? bcs.vector(type) : null;\n    }\n\n    if ('datatype' in typeSignature) {\n        const pkg = normalizeIotaAddress(typeSignature.datatype.package);\n\n        if (pkg === normalizeIotaAddress(MOVE_STDLIB_ADDRESS)) {\n            if (\n                typeSignature.datatype.module === STD_ASCII_MODULE_NAME &&\n                typeSignature.datatype.type === STD_ASCII_STRUCT_NAME\n            ) {\n                return bcs.String;\n            }\n\n            if (\n                typeSignature.datatype.module === STD_UTF8_MODULE_NAME &&\n                typeSignature.datatype.type === STD_UTF8_STRUCT_NAME\n            ) {\n                return bcs.String;\n            }\n\n            if (\n                typeSignature.datatype.module === STD_OPTION_MODULE_NAME &&\n                typeSignature.datatype.type === STD_OPTION_STRUCT_NAME\n            ) {\n                const type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);\n                return type ? bcs.vector(type) : null;\n            }\n        }\n\n        if (\n            pkg === normalizeIotaAddress(IOTA_FRAMEWORK_ADDRESS) &&\n            typeSignature.datatype.module === OBJECT_MODULE_NAME &&\n            typeSignature.datatype.type === ID_STRUCT_NAME\n        ) {\n            return bcs.Address;\n        }\n    }\n\n    return null;\n}\n\nexport function normalizedTypeToMoveTypeSignature(\n    type: IotaMoveNormalizedType,\n): OpenMoveTypeSignature {\n    if (typeof type === 'object' && 'Reference' in type) {\n        return {\n            ref: '&',\n            body: normalizedTypeToMoveTypeSignatureBody(type.Reference),\n        };\n    }\n    if (typeof type === 'object' && 'MutableReference' in type) {\n        return {\n            ref: '&mut',\n            body: normalizedTypeToMoveTypeSignatureBody(type.MutableReference),\n        };\n    }\n\n    return {\n        ref: null,\n        body: normalizedTypeToMoveTypeSignatureBody(type),\n    };\n}\n\nfunction normalizedTypeToMoveTypeSignatureBody(\n    type: IotaMoveNormalizedType,\n): OpenMoveTypeSignatureBody {\n    if (typeof type === 'string') {\n        switch (type) {\n            case 'Address':\n                return 'address';\n            case 'Bool':\n                return 'bool';\n            case 'U8':\n                return 'u8';\n            case 'U16':\n                return 'u16';\n            case 'U32':\n                return 'u32';\n            case 'U64':\n                return 'u64';\n            case 'U128':\n                return 'u128';\n            case 'U256':\n                return 'u256';\n            default:\n                throw new Error(`Unexpected type ${type}`);\n        }\n    }\n\n    if ('Vector' in type) {\n        return { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };\n    }\n\n    if ('Struct' in type) {\n        return {\n            datatype: {\n                package: type.Struct.address,\n                module: type.Struct.module,\n                type: type.Struct.name,\n                typeParameters: type.Struct.typeArguments.map(\n                    normalizedTypeToMoveTypeSignatureBody,\n                ),\n            },\n        };\n    }\n\n    if ('TypeParameter' in type) {\n        return { typeParameter: type.TypeParameter };\n    }\n\n    throw new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\n\nexport function pureBcsSchemaFromOpenMoveTypeSignatureBody(\n    typeSignature: OpenMoveTypeSignatureBody,\n): BcsType<any> {\n    if (typeof typeSignature === 'string') {\n        switch (typeSignature) {\n            case 'address':\n                return bcs.Address;\n            case 'bool':\n                return bcs.Bool;\n            case 'u8':\n                return bcs.U8;\n            case 'u16':\n                return bcs.U16;\n            case 'u32':\n                return bcs.U32;\n            case 'u64':\n                return bcs.U64;\n            case 'u128':\n                return bcs.U128;\n            case 'u256':\n                return bcs.U256;\n            default:\n                throw new Error(`Unknown type signature ${typeSignature}`);\n        }\n    }\n\n    if ('vector' in typeSignature) {\n        return bcs.vector(pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature.vector));\n    }\n\n    throw new Error(`Expected pure typeSignature, but got ${JSON.stringify(typeSignature)}`);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@iota/bcs';\nimport type { SerializedBcs } from '@iota/bcs';\n\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { CallArg, ObjectRef } from './data/internal.js';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction Pure(data: Uint8Array | SerializedBcs<any>): Extract<CallArg, { Pure: unknown }> {\n    return {\n        $kind: 'Pure',\n        Pure: {\n            bytes: data instanceof Uint8Array ? toB64(data) : data.toBase64(),\n        },\n    };\n}\n\nexport const Inputs = {\n    Pure,\n    ObjectRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n        return {\n            $kind: 'Object',\n            Object: {\n                $kind: 'ImmOrOwnedObject',\n                ImmOrOwnedObject: {\n                    digest,\n                    version,\n                    objectId: normalizeIotaAddress(objectId),\n                },\n            },\n        };\n    },\n    SharedObjectRef({\n        objectId,\n        mutable,\n        initialSharedVersion,\n    }: {\n        objectId: string;\n        mutable: boolean;\n        initialSharedVersion: number | string;\n    }): Extract<CallArg, { Object: unknown }> {\n        return {\n            $kind: 'Object',\n            Object: {\n                $kind: 'SharedObject',\n                SharedObject: {\n                    mutable,\n                    initialSharedVersion,\n                    objectId: normalizeIotaAddress(objectId),\n                },\n            },\n        };\n    },\n    ReceivingRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n        return {\n            $kind: 'Object',\n            Object: {\n                $kind: 'Receiving',\n                Receiving: {\n                    digest,\n                    version,\n                    objectId: normalizeIotaAddress(objectId),\n                },\n            },\n        };\n    },\n};\n", "// src/actions/await/awaitAsync.ts\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async _run(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(?:0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    // @ts-expect-error\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? // @ts-expect-error\n  context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? message(issue) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * The error issues.\n   */\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/bic/bic.ts\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value > this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: requirement.map((option) => `\"${option}\"`).join(\" | \") || \"never\",\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value < this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    _run(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    _run(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async _run(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    _run(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async _run(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    _run(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async _run(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/config/config.ts\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    _run(dataset, config_) {\n      return schema._run(dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? { typed: true, value: getFallback(this, dataset, config2) } : dataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    async _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? (\n        // @ts-expect-error\n        { typed: true, value: await getFallback(this, dataset, config2) }\n      ) : dataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      await action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item._run({ typed: false, value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    _run(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    async _run(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n  const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/file/file.ts\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema._run(\n            { typed: false, value: input },\n            config2\n          );\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map(\n            (schema) => schema._run({ typed: false, value: input }, config2)\n          )\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    _run(dataset, config2) {\n      return this.getter(dataset.value)._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    async _run(dataset, config2) {\n      return (await this.getter(dataset.value))._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key._run(\n            { typed: false, value: inputKey },\n            config2\n          );\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key._run({ typed: false, value: inputKey }, config2),\n              this.value._run({ typed: false, value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"!null & !undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"!null & !undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `${wrapped.expects} | null`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `${wrapped.expects} | null`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/number/number.ts\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const value2 = input[key];\n              const valueDataset = this.rest._run(\n                { typed: false, value: value2 },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal entry\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, schema]) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await schema._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other entries with rest schema\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueDataset] of normalDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `${wrapped.expects} | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `${wrapped.expects} | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key._run(\n              { typed: false, value: entryKey },\n              config2\n            );\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value._run(\n              { typed: false, value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key._run({ typed: false, value: entryKey }, config2),\n              this.value._run({ typed: false, value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value._run(\n                { typed: false, value: inputValue },\n                config2\n              )\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest._run({ typed: false, value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/utils/_discriminators/_discriminators.ts\nfunction _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {\n  for (const schema of options) {\n    if (schema.type === \"variant\") {\n      _discriminators(key, schema.options, set2);\n    } else {\n      set2.add(schema.entries[key].expects);\n    }\n  }\n  return set2;\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            ).issues) {\n              const optionDataset = schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !(await schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            )).issues) {\n              const optionDataset = await schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pipe/pipe.ts\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n          dataset = pipe2[index]._run(dataset, config2);\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    async _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n          dataset = await pipe2[index]._run(dataset, config2);\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  OCTAL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _stringify,\n  any,\n  array,\n  arrayAsync,\n  awaitAsync,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxLength,\n  maxSize,\n  maxValue,\n  mimeType,\n  minBytes,\n  minLength,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape, EnumOutputShape } from '@iota/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n    array,\n    boolean,\n    check,\n    integer,\n    lazy,\n    literal,\n    nullable,\n    nullish,\n    number,\n    object,\n    optional,\n    pipe,\n    record,\n    string,\n    transform,\n    tuple,\n    union,\n    unknown,\n} from 'valibot';\n\nimport { isValidIotaAddress, normalizeIotaAddress } from '../../utils/iota-types.js';\n\ntype Merge<T> = T extends object ? { [K in keyof T]: T[K] } : never;\n\ntype EnumSchema<T extends Record<string, GenericSchema<any>>> = GenericSchema<\n    EnumInputShape<\n        Merge<{\n            [K in keyof T]: InferInput<T[K]>;\n        }>\n    >,\n    EnumOutputShape<\n        Merge<{\n            [K in keyof T]: InferOutput<T[K]>;\n        }>\n    >\n>;\n\nexport function safeEnum<T extends Record<string, GenericSchema<any>>>(options: T): EnumSchema<T> {\n    const unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));\n\n    return pipe(\n        union(unionOptions),\n        transform((value) => ({\n            ...value,\n            $kind: Object.keys(value)[0] as keyof typeof value,\n        })),\n    ) as EnumSchema<T>;\n}\n\nexport const IotaAddress = pipe(\n    string(),\n    transform((value) => normalizeIotaAddress(value)),\n    check(isValidIotaAddress),\n);\nexport const ObjectID = IotaAddress;\nexport const BCSBytes = string();\nexport const JsonU64 = pipe(\n    union([string(), pipe(number(), integer())]),\n\n    check((val) => {\n        try {\n            BigInt(val);\n            return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n        } catch {\n            return false;\n        }\n    }, 'Invalid u64'),\n);\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/base_types.rs#L138\n// Implemented as a tuple in rust\nexport const ObjectRef = object({\n    objectId: IotaAddress,\n    version: JsonU64,\n    digest: string(),\n});\nexport type ObjectRef = InferOutput<typeof ObjectRef>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L690-L702\nexport const Argument = pipe(\n    union([\n        object({ GasCoin: literal(true) }),\n        object({ Input: pipe(number(), integer()), type: optional(literal('pure')) }),\n        object({ Input: pipe(number(), integer()), type: optional(literal('object')) }),\n        object({ Result: pipe(number(), integer()) }),\n        object({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) }),\n    ]),\n    transform((value) => ({\n        ...value,\n        $kind: Object.keys(value)[0] as keyof typeof value,\n    })),\n    // Defined manually to add `type?: 'pure' | 'object'` to Input\n) as GenericSchema<\n    // Input\n    | { GasCoin: true }\n    | { Input: number; type?: 'pure' | 'object' }\n    | { Result: number }\n    | { NestedResult: [number, number] },\n    // Output\n    | { $kind: 'GasCoin'; GasCoin: true }\n    | { $kind: 'Input'; Input: number; type?: 'pure' }\n    | { $kind: 'Input'; Input: number; type?: 'object' }\n    | { $kind: 'Result'; Result: number }\n    | { $kind: 'NestedResult'; NestedResult: [number, number] }\n>;\n\nexport type Argument = InferOutput<typeof Argument>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L1387-L1392\nexport const GasData = object({\n    budget: nullable(JsonU64),\n    price: nullable(JsonU64),\n    owner: nullable(IotaAddress),\n    payment: nullable(array(ObjectRef)),\n});\nexport type GasData = InferOutput<typeof GasData>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag = object({\n    address: string(),\n    module: string(),\n    name: string(),\n    // type_params in rust, should be updated to use camelCase\n    typeParams: array(string()),\n});\nexport type StructTag = InferOutput<typeof StructTag>;\n\n// https://github.com/iotaledger/iota/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/iota-graphql-rpc/schema/current_progress_schema.graphql#L1614-L1627\nexport type OpenMoveTypeSignatureBody =\n    | 'address'\n    | 'bool'\n    | 'u8'\n    | 'u16'\n    | 'u32'\n    | 'u64'\n    | 'u128'\n    | 'u256'\n    | { vector: OpenMoveTypeSignatureBody }\n    | {\n          datatype: {\n              package: string;\n              module: string;\n              type: string;\n              typeParameters: OpenMoveTypeSignatureBody[];\n          };\n      }\n    | { typeParameter: number };\n\nexport const OpenMoveTypeSignatureBody: GenericSchema<OpenMoveTypeSignatureBody> = union([\n    literal('address'),\n    literal('bool'),\n    literal('u8'),\n    literal('u16'),\n    literal('u32'),\n    literal('u64'),\n    literal('u128'),\n    literal('u256'),\n    object({ vector: lazy(() => OpenMoveTypeSignatureBody) }),\n    object({\n        datatype: object({\n            package: string(),\n            module: string(),\n            type: string(),\n            typeParameters: array(lazy(() => OpenMoveTypeSignatureBody)),\n        }),\n    }),\n    object({ typeParameter: pipe(number(), integer()) }),\n]);\n\n// https://github.com/iotaledger/iota/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/iota-graphql-rpc/schema/current_progress_schema.graphql#L1609-L1612\nexport const OpenMoveTypeSignature = object({\n    ref: nullable(union([literal('&'), literal('&mut')])),\n    body: OpenMoveTypeSignatureBody,\n});\nexport type OpenMoveTypeSignature = InferOutput<typeof OpenMoveTypeSignature>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n    package: ObjectID,\n    module: string(),\n    function: string(),\n    // snake case in rust\n    typeArguments: array(string()),\n    arguments: array(Argument),\n    _argumentTypes: optional(nullable(array(OpenMoveTypeSignature))),\n});\nexport type ProgrammableMoveCall = InferOutput<typeof ProgrammableMoveCall>;\n\nexport const $Intent = object({\n    name: string(),\n    inputs: record(string(), union([Argument, array(Argument)])),\n    data: record(string(), unknown()),\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L657-L685\nexport const Command = safeEnum({\n    MoveCall: ProgrammableMoveCall,\n    TransferObjects: object({\n        objects: array(Argument),\n        address: Argument,\n    }),\n    SplitCoins: object({\n        coin: Argument,\n        amounts: array(Argument),\n    }),\n    MergeCoins: object({\n        destination: Argument,\n        sources: array(Argument),\n    }),\n    Publish: object({\n        modules: array(BCSBytes),\n        dependencies: array(ObjectID),\n    }),\n    MakeMoveVec: object({\n        type: nullable(string()),\n        elements: array(Argument),\n    }),\n    Upgrade: object({\n        modules: array(BCSBytes),\n        dependencies: array(ObjectID),\n        package: ObjectID,\n        ticket: Argument,\n    }),\n    $Intent,\n});\n\nexport type Command<Arg = Argument> = EnumOutputShape<{\n    MoveCall: {\n        package: string;\n        module: string;\n        function: string;\n        typeArguments: string[];\n        arguments: Arg[];\n        _argumentTypes?: OpenMoveTypeSignature[] | null;\n    };\n    TransferObjects: {\n        objects: Arg[];\n        address: Arg;\n    };\n    SplitCoins: {\n        coin: Arg;\n        amounts: Arg[];\n    };\n    MergeCoins: {\n        destination: Arg;\n        sources: Arg[];\n    };\n    Publish: {\n        modules: string[];\n        dependencies: string[];\n    };\n    MakeMoveVec: {\n        type: string | null;\n        elements: Arg[];\n    };\n    Upgrade: {\n        modules: string[];\n        dependencies: string[];\n        package: string;\n        ticket: Arg;\n    };\n    $Intent: {\n        name: string;\n        inputs: Record<string, Argument | Argument[]>;\n        data: Record<string, unknown>;\n    };\n}>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L102-L114\nexport const ObjectArg = safeEnum({\n    ImmOrOwnedObject: ObjectRef,\n    SharedObject: object({\n        objectId: ObjectID,\n        // snake case in rust\n        initialSharedVersion: JsonU64,\n        mutable: boolean(),\n    }),\n    Receiving: ObjectRef,\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L75-L80\nconst CallArg = safeEnum({\n    Object: ObjectArg,\n    Pure: object({\n        bytes: BCSBytes,\n    }),\n    UnresolvedPure: object({\n        value: unknown(),\n    }),\n    UnresolvedObject: object({\n        objectId: ObjectID,\n        version: optional(nullable(JsonU64)),\n        digest: optional(nullable(string())),\n        initialSharedVersion: optional(nullable(JsonU64)),\n    }),\n});\nexport type CallArg = InferOutput<typeof CallArg>;\n\nexport const NormalizedCallArg = safeEnum({\n    Object: ObjectArg,\n    Pure: object({\n        bytes: BCSBytes,\n    }),\n});\n\nexport const TransactionExpiration = safeEnum({\n    None: literal(true),\n    Epoch: JsonU64,\n});\n\nexport type TransactionExpiration = InferOutput<typeof TransactionExpiration>;\n\nexport const TransactionData = object({\n    version: literal(2),\n    sender: nullish(IotaAddress),\n    expiration: nullish(TransactionExpiration),\n    gasData: GasData,\n    inputs: array(CallArg),\n    commands: array(Command),\n});\nexport type TransactionData = InferOutput<typeof TransactionData>;\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@iota/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { normalizeIotaObjectId } from '../utils/iota-types.js';\nimport { Argument } from './data/internal.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport type { Transaction } from './Transaction.js';\n\nexport type TransactionArgument =\n    | InferInput<typeof Argument>\n    | ((tx: Transaction) => InferInput<typeof Argument>);\nexport type TransactionInput = CallArg;\n\n// Keep in sync with constants in\n// crates/iota-framework/packages/iota-framework/sources/package.move\nexport enum UpgradePolicy {\n    COMPATIBLE = 0,\n    ADDITIVE = 128,\n    DEP_ONLY = 192,\n}\n\ntype TransactionShape<T extends Command['$kind']> = { $kind: T } & {\n    [K in T]: Extract<Command, { [K in T]: any }>[T];\n};\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Commands = {\n    MoveCall(\n        input:\n            | {\n                  package: string;\n                  module: string;\n                  function: string;\n                  arguments?: Argument[];\n                  typeArguments?: string[];\n              }\n            | {\n                  target: string;\n                  arguments?: Argument[];\n                  typeArguments?: string[];\n              },\n    ): TransactionShape<'MoveCall'> {\n        const [pkg, mod = '', fn = ''] =\n            'target' in input\n                ? input.target.split('::')\n                : [input.package, input.module, input.function];\n\n        return {\n            $kind: 'MoveCall',\n            MoveCall: {\n                package: pkg,\n                module: mod,\n                function: fn,\n                typeArguments: input.typeArguments ?? [],\n                arguments: input.arguments ?? [],\n            },\n        };\n    },\n\n    TransferObjects(\n        objects: InferInput<typeof Argument>[],\n        address: InferInput<typeof Argument>,\n    ): TransactionShape<'TransferObjects'> {\n        return {\n            $kind: 'TransferObjects',\n            TransferObjects: {\n                objects: objects.map((o) => parse(Argument, o)),\n                address: parse(Argument, address),\n            },\n        };\n    },\n    SplitCoins(\n        coin: InferInput<typeof Argument>,\n        amounts: InferInput<typeof Argument>[],\n    ): TransactionShape<'SplitCoins'> {\n        return {\n            $kind: 'SplitCoins',\n            SplitCoins: {\n                coin: parse(Argument, coin),\n                amounts: amounts.map((o) => parse(Argument, o)),\n            },\n        };\n    },\n    MergeCoins(\n        destination: InferInput<typeof Argument>,\n        sources: InferInput<typeof Argument>[],\n    ): TransactionShape<'MergeCoins'> {\n        return {\n            $kind: 'MergeCoins',\n            MergeCoins: {\n                destination: parse(Argument, destination),\n                sources: sources.map((o) => parse(Argument, o)),\n            },\n        };\n    },\n    Publish({\n        modules,\n        dependencies,\n    }: {\n        modules: number[][] | string[];\n        dependencies: string[];\n    }): TransactionShape<'Publish'> {\n        return {\n            $kind: 'Publish',\n            Publish: {\n                modules: modules.map((module) =>\n                    typeof module === 'string' ? module : toB64(new Uint8Array(module)),\n                ),\n                dependencies: dependencies.map((dep) => normalizeIotaObjectId(dep)),\n            },\n        };\n    },\n    Upgrade({\n        modules,\n        dependencies,\n        package: packageId,\n        ticket,\n    }: {\n        modules: number[][] | string[];\n        dependencies: string[];\n        package: string;\n        ticket: InferInput<typeof Argument>;\n    }): TransactionShape<'Upgrade'> {\n        return {\n            $kind: 'Upgrade',\n            Upgrade: {\n                modules: modules.map((module) =>\n                    typeof module === 'string' ? module : toB64(new Uint8Array(module)),\n                ),\n                dependencies: dependencies.map((dep) => normalizeIotaObjectId(dep)),\n                package: packageId,\n                ticket: parse(Argument, ticket),\n            },\n        };\n    },\n    MakeMoveVec({\n        type,\n        elements,\n    }: {\n        type?: string;\n        elements: InferInput<typeof Argument>[];\n    }): TransactionShape<'MakeMoveVec'> {\n        return {\n            $kind: 'MakeMoveVec',\n            MakeMoveVec: {\n                type: type ?? null,\n                elements: elements.map((o) => parse(Argument, o)),\n            },\n        };\n    },\n    Intent({\n        name,\n        inputs = {},\n        data = {},\n    }: {\n        name: string;\n        inputs?: Record<string, InferInput<typeof Argument> | InferInput<typeof Argument>[]>;\n        data?: Record<string, unknown>;\n    }): TransactionShape<'$Intent'> {\n        return {\n            $kind: '$Intent',\n            $Intent: {\n                name,\n                inputs: Object.fromEntries(\n                    Object.entries(inputs).map(([key, value]) => [\n                        key,\n                        Array.isArray(value)\n                            ? value.map((o) => parse(Argument, o))\n                            : parse(Argument, value),\n                    ]),\n                ),\n                data,\n            },\n        };\n    },\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@iota/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n    array,\n    bigint,\n    boolean,\n    check,\n    integer,\n    is,\n    lazy,\n    literal,\n    nullable,\n    nullish,\n    number,\n    object,\n    optional,\n    parse,\n    pipe,\n    string,\n    union,\n    unknown,\n} from 'valibot';\n\nimport { TypeTagSerializer } from '../../bcs/index.js';\nimport type { StructTag as StructTagType, TypeTag as TypeTagType } from '../../bcs/types.js';\nimport { JsonU64, ObjectID, safeEnum, TransactionData } from './internal.js';\nimport type { Argument } from './internal.js';\n\nexport const ObjectRef = object({\n    digest: string(),\n    objectId: string(),\n    version: union([pipe(number(), integer()), string(), bigint()]),\n});\n\nconst ObjectArg = safeEnum({\n    ImmOrOwned: ObjectRef,\n    Shared: object({\n        objectId: ObjectID,\n        initialSharedVersion: JsonU64,\n        mutable: boolean(),\n    }),\n    Receiving: ObjectRef,\n});\n\nexport const NormalizedCallArg = safeEnum({\n    Object: ObjectArg,\n    Pure: array(pipe(number(), integer())),\n});\n\nconst TransactionInput = union([\n    object({\n        kind: literal('Input'),\n        index: pipe(number(), integer()),\n        value: unknown(),\n        type: optional(literal('object')),\n    }),\n    object({\n        kind: literal('Input'),\n        index: pipe(number(), integer()),\n        value: unknown(),\n        type: literal('pure'),\n    }),\n]);\n\nconst TransactionExpiration = union([\n    object({ Epoch: pipe(number(), integer()) }),\n    object({ None: nullable(literal(true)) }),\n]);\n\nconst StringEncodedBigint = pipe(\n    union([number(), string(), bigint()]),\n    check((val) => {\n        if (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n        try {\n            BigInt(val as string);\n            return true;\n        } catch {\n            return false;\n        }\n    }),\n);\n\nexport const TypeTag: GenericSchema<TypeTagType> = union([\n    object({ bool: nullable(literal(true)) }),\n    object({ u8: nullable(literal(true)) }),\n    object({ u64: nullable(literal(true)) }),\n    object({ u128: nullable(literal(true)) }),\n    object({ address: nullable(literal(true)) }),\n    object({ signer: nullable(literal(true)) }),\n    object({ vector: lazy(() => TypeTag) }),\n    object({ struct: lazy(() => StructTag) }),\n    object({ u16: nullable(literal(true)) }),\n    object({ u32: nullable(literal(true)) }),\n    object({ u256: nullable(literal(true)) }),\n]);\n\n// https://github.com/iotaledger/iota/blob/cea8742e810142a8145fd83c4c142d61e561004a/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag: GenericSchema<StructTagType> = object({\n    address: string(),\n    module: string(),\n    name: string(),\n    typeParams: array(TypeTag),\n});\n\nconst GasConfig = object({\n    budget: optional(StringEncodedBigint),\n    price: optional(StringEncodedBigint),\n    payment: optional(array(ObjectRef)),\n    owner: optional(string()),\n});\n\nconst TransactionArgumentTypes = [\n    TransactionInput,\n    object({ kind: literal('GasCoin') }),\n    object({ kind: literal('Result'), index: pipe(number(), integer()) }),\n    object({\n        kind: literal('NestedResult'),\n        index: pipe(number(), integer()),\n        resultIndex: pipe(number(), integer()),\n    }),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\n\nconst MoveCallTransaction = object({\n    kind: literal('MoveCall'),\n    target: pipe(\n        string(),\n        check((target) => target.split('::').length === 3),\n    ) as GenericSchema<`${string}::${string}::${string}`>,\n    typeArguments: array(string()),\n    arguments: array(TransactionArgument),\n});\n\nconst TransferObjectsTransaction = object({\n    kind: literal('TransferObjects'),\n    objects: array(TransactionArgument),\n    address: TransactionArgument,\n});\n\nconst SplitCoinsTransaction = object({\n    kind: literal('SplitCoins'),\n    coin: TransactionArgument,\n    amounts: array(TransactionArgument),\n});\n\nconst MergeCoinsTransaction = object({\n    kind: literal('MergeCoins'),\n    destination: TransactionArgument,\n    sources: array(TransactionArgument),\n});\n\nconst MakeMoveVecTransaction = object({\n    kind: literal('MakeMoveVec'),\n    type: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),\n    objects: array(TransactionArgument),\n});\n\nconst PublishTransaction = object({\n    kind: literal('Publish'),\n    modules: array(array(pipe(number(), integer()))),\n    dependencies: array(string()),\n});\n\nconst UpgradeTransaction = object({\n    kind: literal('Upgrade'),\n    modules: array(array(pipe(number(), integer()))),\n    dependencies: array(string()),\n    packageId: string(),\n    ticket: TransactionArgument,\n});\n\nconst TransactionTypes = [\n    MoveCallTransaction,\n    TransferObjectsTransaction,\n    SplitCoinsTransaction,\n    MergeCoinsTransaction,\n    PublishTransaction,\n    UpgradeTransaction,\n    MakeMoveVecTransaction,\n] as const;\n\nconst TransactionType = union([...TransactionTypes]);\n\nexport const SerializedTransactionDataV1 = object({\n    version: literal(1),\n    sender: optional(string()),\n    expiration: nullish(TransactionExpiration),\n    gasConfig: GasConfig,\n    inputs: array(TransactionInput),\n    transactions: array(TransactionType),\n});\n\nexport type SerializedTransactionDataV1 = InferOutput<typeof SerializedTransactionDataV1>;\n\nexport function serializeV1TransactionData(\n    transactionData: TransactionData,\n): SerializedTransactionDataV1 {\n    const inputs: InferOutput<typeof TransactionInput>[] = transactionData.inputs.map(\n        (input, index) => {\n            if (input.Object) {\n                return {\n                    kind: 'Input',\n                    index,\n                    value: {\n                        Object: input.Object.ImmOrOwnedObject\n                            ? {\n                                  ImmOrOwned: input.Object.ImmOrOwnedObject,\n                              }\n                            : input.Object.Receiving\n                              ? {\n                                    Receiving: {\n                                        digest: input.Object.Receiving.digest,\n                                        version: input.Object.Receiving.version,\n                                        objectId: input.Object.Receiving.objectId,\n                                    },\n                                }\n                              : {\n                                    Shared: {\n                                        mutable: input.Object.SharedObject.mutable,\n                                        initialSharedVersion:\n                                            input.Object.SharedObject.initialSharedVersion,\n                                        objectId: input.Object.SharedObject.objectId,\n                                    },\n                                },\n                    },\n                    type: 'object',\n                };\n            }\n            if (input.Pure) {\n                return {\n                    kind: 'Input',\n                    index,\n                    value: {\n                        Pure: Array.from(fromB64(input.Pure.bytes)),\n                    },\n                    type: 'pure',\n                };\n            }\n\n            if (input.UnresolvedPure) {\n                return {\n                    kind: 'Input',\n                    type: 'pure',\n                    index,\n                    value: input.UnresolvedPure.value,\n                };\n            }\n\n            if (input.UnresolvedObject) {\n                return {\n                    kind: 'Input',\n                    type: 'object',\n                    index,\n                    value: input.UnresolvedObject.objectId,\n                };\n            }\n\n            throw new Error('Invalid input');\n        },\n    );\n\n    return {\n        version: 1,\n        sender: transactionData.sender ?? undefined,\n        expiration:\n            transactionData.expiration?.$kind === 'Epoch'\n                ? { Epoch: Number(transactionData.expiration.Epoch) }\n                : transactionData.expiration\n                  ? { None: true }\n                  : null,\n        gasConfig: {\n            owner: transactionData.gasData.owner ?? undefined,\n            budget: transactionData.gasData.budget ?? undefined,\n            price: transactionData.gasData.price ?? undefined,\n            payment: transactionData.gasData.payment ?? undefined,\n        },\n        inputs,\n        transactions: transactionData.commands.map(\n            (command): InferOutput<typeof TransactionType> => {\n                if (command.MakeMoveVec) {\n                    return {\n                        kind: 'MakeMoveVec',\n                        type:\n                            command.MakeMoveVec.type === null\n                                ? { None: true }\n                                : {\n                                      Some: TypeTagSerializer.parseFromStr(\n                                          command.MakeMoveVec.type,\n                                      ),\n                                  },\n                        objects: command.MakeMoveVec.elements.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.MergeCoins) {\n                    return {\n                        kind: 'MergeCoins',\n                        destination: convertTransactionArgument(\n                            command.MergeCoins.destination,\n                            inputs,\n                        ),\n                        sources: command.MergeCoins.sources.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.MoveCall) {\n                    return {\n                        kind: 'MoveCall',\n                        target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n                        typeArguments: command.MoveCall.typeArguments,\n                        arguments: command.MoveCall.arguments.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.Publish) {\n                    return {\n                        kind: 'Publish',\n                        modules: command.Publish.modules.map((mod) => Array.from(fromB64(mod))),\n                        dependencies: command.Publish.dependencies,\n                    };\n                }\n                if (command.SplitCoins) {\n                    return {\n                        kind: 'SplitCoins',\n                        coin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n                        amounts: command.SplitCoins.amounts.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.TransferObjects) {\n                    return {\n                        kind: 'TransferObjects',\n                        objects: command.TransferObjects.objects.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                        address: convertTransactionArgument(\n                            command.TransferObjects.address,\n                            inputs,\n                        ),\n                    };\n                }\n\n                if (command.Upgrade) {\n                    return {\n                        kind: 'Upgrade',\n                        modules: command.Upgrade.modules.map((mod) => Array.from(fromB64(mod))),\n                        dependencies: command.Upgrade.dependencies,\n                        packageId: command.Upgrade.package,\n                        ticket: convertTransactionArgument(command.Upgrade.ticket, inputs),\n                    };\n                }\n\n                throw new Error(`Unknown transaction ${Object.keys(command)}`);\n            },\n        ),\n    };\n}\n\nfunction convertTransactionArgument(\n    arg: Argument,\n    inputs: InferOutput<typeof TransactionInput>[],\n): InferOutput<typeof TransactionArgument> {\n    if (arg.$kind === 'GasCoin') {\n        return { kind: 'GasCoin' };\n    }\n    if (arg.$kind === 'Result') {\n        return { kind: 'Result', index: arg.Result };\n    }\n    if (arg.$kind === 'NestedResult') {\n        return {\n            kind: 'NestedResult',\n            index: arg.NestedResult[0],\n            resultIndex: arg.NestedResult[1],\n        };\n    }\n    if (arg.$kind === 'Input') {\n        return inputs[arg.Input];\n    }\n\n    throw new Error(`Invalid argument ${Object.keys(arg)}`);\n}\n\nexport function transactionDataFromV1(data: SerializedTransactionDataV1): TransactionData {\n    return parse(TransactionData, {\n        version: 2,\n        sender: data.sender ?? null,\n        expiration: data.expiration\n            ? 'Epoch' in data.expiration\n                ? { Epoch: data.expiration.Epoch }\n                : { None: true }\n            : null,\n        gasData: {\n            owner: data.gasConfig.owner ?? null,\n            budget: data.gasConfig.budget?.toString() ?? null,\n            price: data.gasConfig.price?.toString() ?? null,\n            payment:\n                data.gasConfig.payment?.map((ref) => ({\n                    digest: ref.digest,\n                    objectId: ref.objectId,\n                    version: ref.version.toString(),\n                })) ?? null,\n        },\n        inputs: data.inputs.map((input) => {\n            if (input.kind === 'Input') {\n                if (is(NormalizedCallArg, input.value)) {\n                    const value = parse(NormalizedCallArg, input.value);\n\n                    if (value.Object) {\n                        if (value.Object.ImmOrOwned) {\n                            return {\n                                Object: {\n                                    ImmOrOwnedObject: {\n                                        objectId: value.Object.ImmOrOwned.objectId,\n                                        version: String(value.Object.ImmOrOwned.version),\n                                        digest: value.Object.ImmOrOwned.digest,\n                                    },\n                                },\n                            };\n                        }\n                        if (value.Object.Shared) {\n                            return {\n                                Object: {\n                                    SharedObject: {\n                                        mutable: value.Object.Shared.mutable ?? null,\n                                        initialSharedVersion:\n                                            value.Object.Shared.initialSharedVersion,\n                                        objectId: value.Object.Shared.objectId,\n                                    },\n                                },\n                            };\n                        }\n                        if (value.Object.Receiving) {\n                            return {\n                                Object: {\n                                    Receiving: {\n                                        digest: value.Object.Receiving.digest,\n                                        version: String(value.Object.Receiving.version),\n                                        objectId: value.Object.Receiving.objectId,\n                                    },\n                                },\n                            };\n                        }\n\n                        throw new Error('Invalid object input');\n                    }\n\n                    return {\n                        Pure: {\n                            bytes: toB64(new Uint8Array(value.Pure)),\n                        },\n                    };\n                }\n\n                if (input.type === 'object') {\n                    return {\n                        UnresolvedObject: {\n                            objectId: input.value as string,\n                        },\n                    };\n                }\n\n                return {\n                    UnresolvedPure: {\n                        value: input.value,\n                    },\n                };\n            }\n\n            throw new Error('Invalid input');\n        }),\n        commands: data.transactions.map((transaction) => {\n            switch (transaction.kind) {\n                case 'MakeMoveVec':\n                    return {\n                        MakeMoveVec: {\n                            type:\n                                'Some' in transaction.type\n                                    ? TypeTagSerializer.tagToString(transaction.type.Some)\n                                    : null,\n                            elements: transaction.objects.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                case 'MergeCoins': {\n                    return {\n                        MergeCoins: {\n                            destination: parseV1TransactionArgument(transaction.destination),\n                            sources: transaction.sources.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                }\n                case 'MoveCall': {\n                    const [pkg, mod, fn] = transaction.target.split('::');\n                    return {\n                        MoveCall: {\n                            package: pkg,\n                            module: mod,\n                            function: fn,\n                            typeArguments: transaction.typeArguments,\n                            arguments: transaction.arguments.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                }\n                case 'Publish': {\n                    return {\n                        Publish: {\n                            modules: transaction.modules.map((mod) => toB64(Uint8Array.from(mod))),\n                            dependencies: transaction.dependencies,\n                        },\n                    };\n                }\n                case 'SplitCoins': {\n                    return {\n                        SplitCoins: {\n                            coin: parseV1TransactionArgument(transaction.coin),\n                            amounts: transaction.amounts.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                }\n                case 'TransferObjects': {\n                    return {\n                        TransferObjects: {\n                            objects: transaction.objects.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                            address: parseV1TransactionArgument(transaction.address),\n                        },\n                    };\n                }\n                case 'Upgrade': {\n                    return {\n                        Upgrade: {\n                            modules: transaction.modules.map((mod) => toB64(Uint8Array.from(mod))),\n                            dependencies: transaction.dependencies,\n                            package: transaction.packageId,\n                            ticket: parseV1TransactionArgument(transaction.ticket),\n                        },\n                    };\n                }\n            }\n\n            throw new Error(`Unknown transaction ${Object.keys(transaction)}`);\n        }),\n    } satisfies InferInput<typeof TransactionData>);\n}\n\nfunction parseV1TransactionArgument(\n    arg: InferOutput<typeof TransactionArgument>,\n): InferInput<typeof Argument> {\n    switch (arg.kind) {\n        case 'GasCoin': {\n            return { GasCoin: true };\n        }\n        case 'Result':\n            return { Result: arg.index };\n        case 'NestedResult': {\n            return { NestedResult: [arg.index, arg.resultIndex] };\n        }\n        case 'Input': {\n            return { Input: arg.index };\n        }\n    }\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape } from '@iota/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n    array,\n    boolean,\n    integer,\n    literal,\n    nullable,\n    nullish,\n    number,\n    object,\n    optional,\n    pipe,\n    record,\n    string,\n    tuple,\n    union,\n    unknown,\n} from 'valibot';\n\nimport { BCSBytes, JsonU64, ObjectID, ObjectRef, IotaAddress } from './internal.js';\n\ntype Merge<T> = T extends object ? { [K in keyof T]: T[K] } : never;\n\nfunction enumUnion<T extends Record<string, GenericSchema<any>>>(options: T) {\n    return union(\n        Object.entries(options).map(([key, value]) => object({ [key]: value })),\n    ) as GenericSchema<\n        EnumInputShape<\n            Merge<{\n                [K in keyof T]: InferInput<T[K]>;\n            }>\n        >\n    >;\n}\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L690-L702\nconst Argument = enumUnion({\n    GasCoin: literal(true),\n    Input: pipe(number(), integer()),\n    Result: pipe(number(), integer()),\n    NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]),\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L1387-L1392\nconst GasData = object({\n    budget: nullable(JsonU64),\n    price: nullable(JsonU64),\n    owner: nullable(IotaAddress),\n    payment: nullable(array(ObjectRef)),\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n    package: ObjectID,\n    module: string(),\n    function: string(),\n    // snake case in rust\n    typeArguments: array(string()),\n    arguments: array(Argument),\n});\n\nconst $Intent = object({\n    name: string(),\n    inputs: record(string(), union([Argument, array(Argument)])),\n    data: record(string(), unknown()),\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L657-L685\nconst Command = enumUnion({\n    MoveCall: ProgrammableMoveCall,\n    TransferObjects: object({\n        objects: array(Argument),\n        address: Argument,\n    }),\n    SplitCoins: object({\n        coin: Argument,\n        amounts: array(Argument),\n    }),\n    MergeCoins: object({\n        destination: Argument,\n        sources: array(Argument),\n    }),\n    Publish: object({\n        modules: array(BCSBytes),\n        dependencies: array(ObjectID),\n    }),\n    MakeMoveVec: object({\n        type: nullable(string()),\n        elements: array(Argument),\n    }),\n    Upgrade: object({\n        modules: array(BCSBytes),\n        dependencies: array(ObjectID),\n        package: ObjectID,\n        ticket: Argument,\n    }),\n    $Intent,\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L102-L114\nconst ObjectArg = enumUnion({\n    ImmOrOwnedObject: ObjectRef,\n    SharedObject: object({\n        objectId: ObjectID,\n        // snake case in rust\n        initialSharedVersion: JsonU64,\n        mutable: boolean(),\n    }),\n    Receiving: ObjectRef,\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L75-L80\nconst CallArg = enumUnion({\n    Object: ObjectArg,\n    Pure: object({\n        bytes: BCSBytes,\n    }),\n    UnresolvedPure: object({\n        value: unknown(),\n    }),\n    UnresolvedObject: object({\n        objectId: ObjectID,\n        version: optional(nullable(JsonU64)),\n        digest: optional(nullable(string())),\n        initialSharedVersion: optional(nullable(JsonU64)),\n    }),\n});\n\nconst TransactionExpiration = enumUnion({\n    None: literal(true),\n    Epoch: JsonU64,\n});\n\nexport const SerializedTransactionDataV2 = object({\n    version: literal(2),\n    sender: nullish(IotaAddress),\n    expiration: nullish(TransactionExpiration),\n    gasData: GasData,\n    inputs: array(CallArg),\n    commands: array(Command),\n});\n\nexport type SerializedTransactionDataV2 = InferOutput<typeof SerializedTransactionDataV2>;\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\n\nimport type { BcsType } from '../bcs/index.js';\nimport { bcs } from '../bcs/index.js';\nimport type { IotaClient } from '../client/client.js';\nimport { normalizeIotaAddress, normalizeIotaObjectId, IOTA_TYPE_ARG } from '../utils/index.js';\nimport { ObjectRef } from './data/internal.js';\nimport type { Argument, CallArg, Command, OpenMoveTypeSignature } from './data/internal.js';\nimport { Inputs } from './Inputs.js';\nimport { getPureBcsSchema, isTxContext, normalizedTypeToMoveTypeSignature } from './serializer.js';\nimport type { TransactionDataBuilder } from './TransactionData.js';\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 50_000_000_000;\n\nexport interface BuildTransactionOptions {\n    client?: IotaClient;\n    onlyTransactionKind?: boolean;\n    maxSizeBytes?: number;\n}\n\nexport interface SerializeTransactionOptions extends BuildTransactionOptions {\n    supportedIntents?: string[];\n}\n\nexport type TransactionPlugin = (\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n    next: () => Promise<void>,\n) => Promise<void>;\n\nexport async function resolveTransactionData(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n    next: () => Promise<void>,\n) {\n    await normalizeInputs(transactionData, options);\n    await resolveObjectReferences(transactionData, options);\n\n    if (!options.onlyTransactionKind) {\n        await setGasPrice(transactionData, options);\n        await setGasBudget(transactionData, options);\n        await setGasPayment(transactionData, options);\n    }\n    await validate(transactionData);\n    return await next();\n}\n\nasync function setGasPrice(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    if (!transactionData.gasConfig.price) {\n        transactionData.gasConfig.price = String(await getClient(options).getReferenceGasPrice());\n    }\n}\n\nasync function setGasBudget(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    if (transactionData.gasConfig.budget) {\n        return;\n    }\n\n    const dryRunResult = await getClient(options).dryRunTransactionBlock({\n        transactionBlock: transactionData.build({\n            overrides: {\n                gasData: {\n                    budget: String(MAX_GAS),\n                    payment: [],\n                },\n            },\n        }),\n    });\n\n    if (dryRunResult.effects.status.status !== 'success') {\n        throw new Error(\n            `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n            { cause: dryRunResult },\n        );\n    }\n\n    const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n\n    const baseComputationCostWithOverhead =\n        BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n    const gasBudget =\n        baseComputationCostWithOverhead +\n        BigInt(dryRunResult.effects.gasUsed.storageCost) -\n        BigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n    transactionData.gasConfig.budget = String(\n        gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n    );\n}\n\n// The current default is just picking _all_ coins we can which may not be ideal.\nasync function setGasPayment(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    if (!transactionData.gasConfig.payment) {\n        const coins = await getClient(options).getCoins({\n            owner: transactionData.gasConfig.owner || transactionData.sender!,\n            coinType: IOTA_TYPE_ARG,\n        });\n\n        const paymentCoins = coins.data\n            // Filter out coins that are also used as input:\n            .filter((coin) => {\n                const matchingInput = transactionData.inputs.find((input) => {\n                    if (input.Object?.ImmOrOwnedObject) {\n                        return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n                    }\n\n                    return false;\n                });\n\n                return !matchingInput;\n            })\n            .map((coin) => ({\n                objectId: coin.coinObjectId,\n                digest: coin.digest,\n                version: coin.version,\n            }));\n\n        if (!paymentCoins.length) {\n            throw new Error('No valid gas coins found for the transaction.');\n        }\n\n        transactionData.gasConfig.payment = paymentCoins.map((payment) =>\n            parse(ObjectRef, payment),\n        );\n    }\n}\n\nasync function resolveObjectReferences(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    // Keep track of the object references that will need to be resolved at the end of the transaction.\n    // We keep the input by-reference to avoid needing to re-resolve it:\n    const objectsToResolve = transactionData.inputs.filter((input) => {\n        return (\n            input.UnresolvedObject &&\n            !(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion)\n        );\n    }) as Extract<CallArg, { UnresolvedObject: unknown }>[];\n\n    const dedupedIds = [\n        ...new Set(\n            objectsToResolve.map((input) => normalizeIotaObjectId(input.UnresolvedObject.objectId)),\n        ),\n    ];\n\n    const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n\n    const resolvedObjects = new Map();\n    const erroredObjects = new Map();\n\n    await Promise.all(\n        objectChunks.map(async (chunk) => {\n            const chunkObjects = await getClient(options).multiGetObjects({\n                ids: chunk,\n                options: { showOwner: true },\n            });\n\n            for (const object of chunkObjects) {\n                const objectId = object.data?.objectId;\n                if (objectId) {\n                    if (object.error || !object.data) {\n                        erroredObjects.set(objectId, object.error);\n                        return;\n                    }\n                    const owner = object.data.owner;\n                    const initialSharedVersion =\n                        owner && typeof owner === 'object' && 'Shared' in owner\n                            ? owner.Shared.initial_shared_version\n                            : null;\n\n                    resolvedObjects.set(objectId, {\n                        objectId,\n                        digest: object.data.digest,\n                        version: object.data.version,\n                        initialSharedVersion,\n                    });\n                }\n            }\n        }),\n    );\n\n    if (erroredObjects.size > 0) {\n        throw new Error(\n            `The following input objects are invalid: ${Array.from(erroredObjects).join(', ')}`,\n        );\n    }\n\n    for (const [index, input] of transactionData.inputs.entries()) {\n        if (!input.UnresolvedObject) {\n            continue;\n        }\n\n        let updated: CallArg | undefined;\n        const id = normalizeIotaAddress(input.UnresolvedObject.objectId);\n        const object = resolvedObjects.get(id);\n\n        if (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n            updated = Inputs.SharedObjectRef({\n                objectId: id,\n                initialSharedVersion:\n                    input.UnresolvedObject.initialSharedVersion ||\n                    (object?.initialSharedVersion as string),\n                mutable: isUsedAsMutable(transactionData, index),\n            });\n        } else if (isUsedAsReceiving(transactionData, index)) {\n            updated = Inputs.ReceivingRef(\n                {\n                    objectId: id,\n                    digest: input.UnresolvedObject.digest ?? (object?.digest as string),\n                    version: input.UnresolvedObject.version ?? (object?.version as string),\n                }!,\n            );\n        }\n\n        transactionData.inputs[transactionData.inputs.indexOf(input)] =\n            updated ??\n            Inputs.ObjectRef({\n                objectId: id,\n                digest: input.UnresolvedObject.digest ?? (object?.digest as string),\n                version: input.UnresolvedObject.version ?? (object?.version as string),\n            });\n    }\n}\n\nasync function normalizeInputs(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    const { inputs, commands } = transactionData;\n    const moveCallsToResolve: Extract<Command, { MoveCall: unknown }>['MoveCall'][] = [];\n    const moveFunctionsToResolve = new Set<string>();\n\n    commands.forEach((command) => {\n        // Special case move call:\n        if (command.MoveCall) {\n            // Determine if any of the arguments require encoding.\n            // - If they don't, then this is good to go.\n            // - If they do, then we need to fetch the normalized move module.\n\n            // If we already know the argument types, we don't need to resolve them again\n            if (command.MoveCall._argumentTypes) {\n                return;\n            }\n\n            const inputs = command.MoveCall.arguments.map((arg) => {\n                if (arg.$kind === 'Input') {\n                    return transactionData.inputs[arg.Input];\n                }\n                return null;\n            });\n            const needsResolution = inputs.some(\n                (input) => input?.UnresolvedPure || input?.UnresolvedObject,\n            );\n\n            if (needsResolution) {\n                const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n                moveFunctionsToResolve.add(functionName);\n                moveCallsToResolve.push(command.MoveCall);\n            }\n        }\n\n        // Special handling for values that where previously encoded using the wellKnownEncoding pattern.\n        // This should only happen when transaction data was hydrated from an old version of the SDK\n        switch (command.$kind) {\n            case 'SplitCoins':\n                command.SplitCoins.amounts.forEach((amount) => {\n                    normalizeRawArgument(amount, bcs.U64, transactionData);\n                });\n                break;\n            case 'TransferObjects':\n                normalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n                break;\n        }\n    });\n\n    const moveFunctionParameters = new Map<string, OpenMoveTypeSignature[]>();\n    if (moveFunctionsToResolve.size > 0) {\n        const client = getClient(options);\n        await Promise.all(\n            [...moveFunctionsToResolve].map(async (functionName) => {\n                const [packageId, moduleId, functionId] = functionName.split('::');\n                const def = await client.getNormalizedMoveFunction({\n                    package: packageId,\n                    module: moduleId,\n                    function: functionId,\n                });\n\n                moveFunctionParameters.set(\n                    functionName,\n                    def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param)),\n                );\n            }),\n        );\n    }\n\n    if (moveCallsToResolve.length) {\n        await Promise.all(\n            moveCallsToResolve.map(async (moveCall) => {\n                const parameters = moveFunctionParameters.get(\n                    `${moveCall.package}::${moveCall.module}::${moveCall.function}`,\n                );\n\n                if (!parameters) {\n                    return;\n                }\n\n                // Entry functions can have a mutable reference to an instance of the TxContext\n                // struct defined in the TxContext module as the last parameter. The caller of\n                // the function does not need to pass it in as an argument.\n                const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1)!);\n                const params = hasTxContext\n                    ? parameters.slice(0, parameters.length - 1)\n                    : parameters;\n\n                moveCall._argumentTypes = params;\n            }),\n        );\n    }\n\n    commands.forEach((command) => {\n        if (!command.MoveCall) {\n            return;\n        }\n\n        const moveCall = command.MoveCall;\n        const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n        const params = moveCall._argumentTypes;\n\n        if (!params) {\n            return;\n        }\n\n        if (params.length !== command.MoveCall.arguments.length) {\n            throw new Error(`Incorrect number of arguments for ${fnName}`);\n        }\n\n        params.forEach((param, i) => {\n            const arg = moveCall.arguments[i];\n            if (arg.$kind !== 'Input') return;\n            const input = inputs[arg.Input];\n\n            // Skip if the input is already resolved\n            if (!input.UnresolvedPure && !input.UnresolvedObject) {\n                return;\n            }\n\n            const inputValue =\n                input.UnresolvedPure?.value ?? (input.UnresolvedObject?.objectId as string);\n\n            const inputIndex = inputs.indexOf(input);\n\n            const schema = getPureBcsSchema(param.body);\n            if (schema) {\n                arg.type = 'pure';\n                inputs[inputIndex] = Inputs.Pure(schema.serialize(inputValue));\n                return;\n            }\n\n            if (typeof inputValue !== 'string') {\n                throw new Error(\n                    `Expect the argument to be an object id string, got ${JSON.stringify(\n                        inputValue,\n                        null,\n                        2,\n                    )}`,\n                );\n            }\n\n            arg.type = 'object';\n            const unresolvedObject: typeof input = input.UnresolvedPure\n                ? {\n                      $kind: 'UnresolvedObject',\n                      UnresolvedObject: {\n                          objectId: inputValue,\n                      },\n                  }\n                : input;\n\n            inputs[inputIndex] = unresolvedObject;\n        });\n    });\n}\n\nfunction validate(transactionData: TransactionDataBuilder) {\n    transactionData.inputs.forEach((input, index) => {\n        if (input.$kind !== 'Object' && input.$kind !== 'Pure') {\n            throw new Error(\n                `Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n                    input,\n                )}`,\n            );\n        }\n    });\n}\n\nfunction normalizeRawArgument(\n    arg: Argument,\n    schema: BcsType<any>,\n    transactionData: TransactionDataBuilder,\n) {\n    if (arg.$kind !== 'Input') {\n        return;\n    }\n    const input = transactionData.inputs[arg.Input];\n\n    if (input.$kind !== 'UnresolvedPure') {\n        return;\n    }\n\n    transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\n\nfunction isUsedAsMutable(transactionData: TransactionDataBuilder, index: number) {\n    let usedAsMutable = false;\n\n    transactionData.getInputUses(index, (arg, tx) => {\n        if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n            const argIndex = tx.MoveCall.arguments.indexOf(arg);\n            usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== '&' || usedAsMutable;\n        }\n\n        if (tx.$kind === 'MakeMoveVec' || tx.$kind === 'MergeCoins' || tx.$kind === 'SplitCoins') {\n            usedAsMutable = true;\n        }\n    });\n\n    return usedAsMutable;\n}\n\nfunction isUsedAsReceiving(transactionData: TransactionDataBuilder, index: number) {\n    let usedAsReceiving = false;\n\n    transactionData.getInputUses(index, (arg, tx) => {\n        if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n            const argIndex = tx.MoveCall.arguments.indexOf(arg);\n            usedAsReceiving =\n                isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n        }\n    });\n\n    return usedAsReceiving;\n}\n\nfunction isReceivingType(type: OpenMoveTypeSignature): boolean {\n    if (typeof type.body !== 'object' || !('datatype' in type.body)) {\n        return false;\n    }\n\n    return (\n        type.body.datatype.package === '0x2' &&\n        type.body.datatype.module === 'transfer' &&\n        type.body.datatype.type === 'Receiving'\n    );\n}\n\nexport function getClient(options: BuildTransactionOptions): IotaClient {\n    if (!options.client) {\n        throw new Error(\n            `No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n        );\n    }\n\n    return options.client;\n}\n\nfunction chunk<T>(arr: T[], size: number): T[][] {\n    return Array.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n        arr.slice(i * size, i * size + size),\n    );\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { TransactionObjectInput } from './Transaction.js';\n\nexport function createObjectMethods<T>(makeObject: (value: TransactionObjectInput) => T) {\n    function object(value: TransactionObjectInput) {\n        return makeObject(value);\n    }\n\n    object.system = () => object('0x5');\n    object.clock = () => object('0x6');\n    object.random = () => object('0x8');\n    object.denyList = () => object('0x403');\n\n    return object;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isSerializedBcs } from '@iota/bcs';\nimport type { BcsType, SerializedBcs } from '@iota/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { Argument } from './data/internal.js';\n\nexport function createPure<T>(makePure: (value: SerializedBcs<any, any> | Uint8Array) => T) {\n    function pure<T extends PureTypeName>(\n        type: T extends PureTypeName ? ValidPureTypeName<T> : T,\n        value: ShapeFromPureTypeName<T>,\n    ): T;\n\n    function pure(\n        /**\n         * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n         * is assumed to be raw bytes, and will be used directly.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        value: SerializedBcs<any, any> | Uint8Array,\n    ): T;\n\n    function pure(\n        typeOrSerializedValue?: PureTypeName | SerializedBcs<any, any> | Uint8Array,\n        value?: unknown,\n    ): T {\n        if (typeof typeOrSerializedValue === 'string') {\n            return makePure(schemaFromName(typeOrSerializedValue).serialize(value as never));\n        }\n\n        if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n            return makePure(typeOrSerializedValue);\n        }\n\n        throw new Error('tx.pure must be called either a bcs type name, or a serialized bcs value');\n    }\n\n    pure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n    pure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n    pure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n    pure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n    pure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n    pure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n    pure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n    pure.string = (value: string) => makePure(bcs.String.serialize(value));\n    pure.address = (value: string) => makePure(bcs.Address.serialize(value));\n    pure.id = pure.address;\n    pure.vector = <Type extends PureTypeName>(\n        type: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n        value: Iterable<ShapeFromPureTypeName<Type>> & { length: number },\n    ) => {\n        return makePure(bcs.vector(schemaFromName(type as BasePureType)).serialize(value as never));\n    };\n    pure.option = <Type extends PureTypeName>(\n        type: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n        value: ShapeFromPureTypeName<Type> | null | undefined,\n    ) => {\n        return makePure(bcs.option(schemaFromName(type)).serialize(value as never));\n    };\n\n    return pure;\n}\n\nexport type BasePureType =\n    | 'u8'\n    | 'u16'\n    | 'u32'\n    | 'u64'\n    | 'u128'\n    | 'u256'\n    | 'bool'\n    | 'id'\n    | 'string'\n    | 'address';\n\nexport type PureTypeName = BasePureType | `vector<${string}>` | `option<${string}>`;\nexport type ValidPureTypeName<T extends string> = T extends BasePureType\n    ? PureTypeName\n    : T extends `vector<${infer U}>`\n      ? ValidPureTypeName<U>\n      : T extends `option<${infer U}>`\n        ? ValidPureTypeName<U>\n        : PureTypeValidationError<T>;\n\ntype ShapeFromPureTypeName<T extends PureTypeName> = T extends BasePureType\n    ? Parameters<ReturnType<typeof createPure<Argument>>[T]>[0]\n    : T extends `vector<${infer U extends PureTypeName}>`\n      ? ShapeFromPureTypeName<U>[]\n      : T extends `option<${infer U extends PureTypeName}>`\n        ? ShapeFromPureTypeName<U> | null\n        : never;\n\ntype PureTypeValidationError<T extends string> = T & {\n    error: `Invalid Pure type name: ${T}`;\n};\n\nfunction schemaFromName<T extends PureTypeName>(\n    name: T extends PureTypeName ? ValidPureTypeName<T> : T,\n): BcsType<ShapeFromPureTypeName<T>> {\n    switch (name) {\n        case 'u8':\n            return bcs.u8() as never;\n        case 'u16':\n            return bcs.u16() as never;\n        case 'u32':\n            return bcs.u32() as never;\n        case 'u64':\n            return bcs.u64() as never;\n        case 'u128':\n            return bcs.u128() as never;\n        case 'u256':\n            return bcs.u256() as never;\n        case 'bool':\n            return bcs.bool() as never;\n        case 'string':\n            return bcs.string() as never;\n        case 'id':\n        case 'address':\n            return bcs.Address as never;\n    }\n\n    const generic = name.match(/^(vector|option)<(.+)>$/);\n    if (generic) {\n        const [kind, inner] = generic.slice(1);\n        if (kind === 'vector') {\n            return bcs.vector(schemaFromName(inner as PureTypeName)) as never;\n        } else {\n            return bcs.option(schemaFromName(inner as PureTypeName)) as never;\n        }\n    }\n\n    throw new Error(`Invalid Pure type name: ${name}`);\n}\n", "/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "/**\n * Internal helpers for blake hash.\n * @module\n */\nimport { rotr } from './utils.ts';\n\n/**\n * Internal blake variable.\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n */\n// prettier-ignore\nexport const BSIGMA: Uint8Array = /* @__PURE__ */ Uint8Array.from([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  // Blake1, unused in others\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n]);\n\n// prettier-ignore\nexport type Num4 = { a: number; b: number; c: number; d: number; };\n\n// Mixing function G splitted in two halfs\nexport function G1s(a: number, b: number, c: number, d: number, x: number): Num4 {\n  a = (a + b + x) | 0;\n  d = rotr(d ^ a, 16);\n  c = (c + d) | 0;\n  b = rotr(b ^ c, 12);\n  return { a, b, c, d };\n}\n\nexport function G2s(a: number, b: number, c: number, d: number, x: number): Num4 {\n  a = (a + b + x) | 0;\n  d = rotr(d ^ a, 8);\n  c = (c + d) | 0;\n  b = rotr(b ^ c, 7);\n  return { a, b, c, d };\n}\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * blake2b (64-bit) & blake2s (8 to 32-bit) hash functions.\n * b could have been faster, but there is no fast u64 in js, so s is 1.5x faster.\n * @module\n */\nimport { BSIGMA, G1s, G2s } from './_blake.ts';\nimport { SHA256_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createOptHasher, Hash, swap32IfBE, swap8IfBE, toBytes, u32,\n  type CHashO, type Input\n} from './utils.ts';\n\n/** Blake hash options. dkLen is output length. key is used in MAC mode. salt is used in KDF mode. */\nexport type Blake2Opts = {\n  dkLen?: number;\n  key?: Input;\n  salt?: Input;\n  personalization?: Input;\n};\n\n// Same as SHA512_IV, but swapped endianness: LE instead of BE. iv[1] is iv[0], etc.\nconst B2B_IV = /* @__PURE__ */ Uint32Array.from([\n  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n  0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19,\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n\n// Mixing function G splitted in two halfs\nfunction G1b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 32)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 24)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nfunction G2b(a: number, b: number, c: number, d: number, msg: Uint32Array, x: number) {\n  // NOTE: V is LE here\n  const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  let ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 16)\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\n  // v[c] = (v[c] + v[d]) | 0;\n  ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n  // v[b] = rotr(v[b] ^ v[c], 63)\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });\n  (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n  (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n  (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n  (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\n\nfunction checkBlake2Opts(\n  outputLen: number,\n  opts: Blake2Opts | undefined = {},\n  keyLen: number,\n  saltLen: number,\n  persLen: number\n) {\n  anumber(keyLen);\n  if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n  const { key, salt, personalization } = opts;\n  if (key !== undefined && (key.length < 1 || key.length > keyLen))\n    throw new Error('key length must be undefined or 1..' + keyLen);\n  if (salt !== undefined && salt.length !== saltLen)\n    throw new Error('salt must be undefined or ' + saltLen);\n  if (personalization !== undefined && personalization.length !== persLen)\n    throw new Error('personalization must be undefined or ' + persLen);\n}\n\n/** Class, from which others are subclassed. */\nexport abstract class BLAKE2<T extends BLAKE2<T>> extends Hash<T> {\n  protected abstract compress(msg: Uint32Array, offset: number, isLast: boolean): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected buffer: Uint8Array;\n  protected buffer32: Uint32Array;\n  protected finished = false;\n  protected destroyed = false;\n  protected length: number = 0;\n  protected pos: number = 0;\n  readonly blockLen: number;\n  readonly outputLen: number;\n\n  constructor(blockLen: number, outputLen: number) {\n    super();\n    anumber(blockLen);\n    anumber(outputLen);\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.buffer = new Uint8Array(blockLen);\n    this.buffer32 = u32(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const { blockLen, buffer, buffer32 } = this;\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len; ) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        swap32IfBE(buffer32);\n        this.compress(buffer32, 0, false);\n        swap32IfBE(buffer32);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        swap32IfBE(data32);\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        swap32IfBE(data32);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    const { pos, buffer32 } = this;\n    this.finished = true;\n    // Padding\n    clean(this.buffer.subarray(pos));\n    swap32IfBE(buffer32);\n    this.compress(buffer32, 0, true);\n    swap32IfBE(buffer32);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => (out32[i] = swap8IfBE(v)));\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    const { buffer, length, finished, destroyed, outputLen, pos } = this;\n    to ||= new (this.constructor as any)({ dkLen: outputLen }) as T;\n    to.set(...this.get());\n    to.buffer.set(buffer);\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    // @ts-ignore\n    to.outputLen = outputLen;\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\nexport class BLAKE2b extends BLAKE2<BLAKE2b> {\n  // Same as SHA-512, but LE\n  private v0l = B2B_IV[0] | 0;\n  private v0h = B2B_IV[1] | 0;\n  private v1l = B2B_IV[2] | 0;\n  private v1h = B2B_IV[3] | 0;\n  private v2l = B2B_IV[4] | 0;\n  private v2h = B2B_IV[5] | 0;\n  private v3l = B2B_IV[6] | 0;\n  private v3h = B2B_IV[7] | 0;\n  private v4l = B2B_IV[8] | 0;\n  private v4h = B2B_IV[9] | 0;\n  private v5l = B2B_IV[10] | 0;\n  private v5h = B2B_IV[11] | 0;\n  private v6l = B2B_IV[12] | 0;\n  private v6h = B2B_IV[13] | 0;\n  private v7l = B2B_IV[14] | 0;\n  private v7h = B2B_IV[15] | 0;\n\n  constructor(opts: Blake2Opts = {}) {\n    const olen = opts.dkLen === undefined ? 64 : opts.dkLen;\n    super(128, olen);\n    checkBlake2Opts(olen, opts, 64, 16, 16);\n    let { key, personalization, salt } = opts;\n    let keyLength = 0;\n    if (key !== undefined) {\n      key = toBytes(key);\n      keyLength = key.length;\n    }\n    this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (salt !== undefined) {\n      salt = toBytes(salt);\n      const slt = u32(salt);\n      this.v4l ^= swap8IfBE(slt[0]);\n      this.v4h ^= swap8IfBE(slt[1]);\n      this.v5l ^= swap8IfBE(slt[2]);\n      this.v5h ^= swap8IfBE(slt[3]);\n    }\n    if (personalization !== undefined) {\n      personalization = toBytes(personalization);\n      const pers = u32(personalization);\n      this.v6l ^= swap8IfBE(pers[0]);\n      this.v6h ^= swap8IfBE(pers[1]);\n      this.v7l ^= swap8IfBE(pers[2]);\n      this.v7h ^= swap8IfBE(pers[3]);\n    }\n    if (key !== undefined) {\n      // Pad to blockLen and update\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(key);\n      this.update(tmp);\n    }\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n  }\n  // prettier-ignore\n  protected set(\n    v0l: number, v0h: number, v1l: number, v1h: number,\n    v2l: number, v2h: number, v3l: number, v3h: number,\n    v4l: number, v4h: number, v5l: number, v5h: number,\n    v6l: number, v6h: number, v7l: number, v7h: number\n  ): void {\n    this.v0l = v0l | 0;\n    this.v0h = v0h | 0;\n    this.v1l = v1l | 0;\n    this.v1h = v1h | 0;\n    this.v2l = v2l | 0;\n    this.v2h = v2h | 0;\n    this.v3l = v3l | 0;\n    this.v3h = v3h | 0;\n    this.v4l = v4l | 0;\n    this.v4h = v4h | 0;\n    this.v5l = v5l | 0;\n    this.v5h = v5h | 0;\n    this.v6l = v6l | 0;\n    this.v6h = v6h | 0;\n    this.v7l = v7l | 0;\n    this.v7h = v7h | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\n    this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n    BBUF.set(B2B_IV, 16); // Second half from IV.\n    let { h, l } = u64.fromBig(BigInt(this.length));\n    BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n    BBUF[25] = B2B_IV[9] ^ h; // High word.\n    // Invert all bits for last block\n    if (isLast) {\n      BBUF[28] = ~BBUF[28];\n      BBUF[29] = ~BBUF[29];\n    }\n    let j = 0;\n    const s = BSIGMA;\n    for (let i = 0; i < 12; i++) {\n      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n\n      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n    }\n    this.v0l ^= BBUF[0] ^ BBUF[16];\n    this.v0h ^= BBUF[1] ^ BBUF[17];\n    this.v1l ^= BBUF[2] ^ BBUF[18];\n    this.v1h ^= BBUF[3] ^ BBUF[19];\n    this.v2l ^= BBUF[4] ^ BBUF[20];\n    this.v2h ^= BBUF[5] ^ BBUF[21];\n    this.v3l ^= BBUF[6] ^ BBUF[22];\n    this.v3h ^= BBUF[7] ^ BBUF[23];\n    this.v4l ^= BBUF[8] ^ BBUF[24];\n    this.v4h ^= BBUF[9] ^ BBUF[25];\n    this.v5l ^= BBUF[10] ^ BBUF[26];\n    this.v5h ^= BBUF[11] ^ BBUF[27];\n    this.v6l ^= BBUF[12] ^ BBUF[28];\n    this.v6h ^= BBUF[13] ^ BBUF[29];\n    this.v7l ^= BBUF[14] ^ BBUF[30];\n    this.v7h ^= BBUF[15] ^ BBUF[31];\n    clean(BBUF);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer32);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2b: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2b, Blake2Opts>(\n  (opts) => new BLAKE2b(opts)\n);\n\n// =================\n// Blake2S\n// =================\n\n// prettier-ignore\nexport type Num16 = {\n  v0: number; v1: number; v2: number; v3: number;\n  v4: number; v5: number; v6: number; v7: number;\n  v8: number; v9: number; v10: number; v11: number;\n  v12: number; v13: number; v14: number; v15: number;\n};\n\n// prettier-ignore\nexport function compress(s: Uint8Array, offset: number, msg: Uint32Array, rounds: number,\n  v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number,\n  v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number,\n): Num16 {\n  let j = 0;\n  for (let i = 0; i < rounds; i++) {\n    ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));\n    ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));\n    ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));\n    ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));\n    ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s[j++]]));\n    ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s[j++]]));\n    ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset + s[j++]]));\n    ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset + s[j++]]));\n\n    ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset + s[j++]]));\n    ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset + s[j++]]));\n    ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));\n    ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));\n    ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));\n    ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));\n    ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset + s[j++]]));\n    ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset + s[j++]]));\n  }\n  return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };\n}\n\nconst B2S_IV = SHA256_IV;\nexport class BLAKE2s extends BLAKE2<BLAKE2s> {\n  // Internal state, same as SHA-256\n  private v0 = B2S_IV[0] | 0;\n  private v1 = B2S_IV[1] | 0;\n  private v2 = B2S_IV[2] | 0;\n  private v3 = B2S_IV[3] | 0;\n  private v4 = B2S_IV[4] | 0;\n  private v5 = B2S_IV[5] | 0;\n  private v6 = B2S_IV[6] | 0;\n  private v7 = B2S_IV[7] | 0;\n\n  constructor(opts: Blake2Opts = {}) {\n    const olen = opts.dkLen === undefined ? 32 : opts.dkLen;\n    super(64, olen);\n    checkBlake2Opts(olen, opts, 32, 8, 8);\n    let { key, personalization, salt } = opts;\n    let keyLength = 0;\n    if (key !== undefined) {\n      key = toBytes(key);\n      keyLength = key.length;\n    }\n    this.v0 ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n    if (salt !== undefined) {\n      salt = toBytes(salt);\n      const slt = u32(salt as Uint8Array);\n      this.v4 ^= swap8IfBE(slt[0]);\n      this.v5 ^= swap8IfBE(slt[1]);\n    }\n    if (personalization !== undefined) {\n      personalization = toBytes(personalization);\n      const pers = u32(personalization as Uint8Array);\n      this.v6 ^= swap8IfBE(pers[0]);\n      this.v7 ^= swap8IfBE(pers[1]);\n    }\n    if (key !== undefined) {\n      // Pad to blockLen and update\n      abytes(key);\n      const tmp = new Uint8Array(this.blockLen);\n      tmp.set(key);\n      this.update(tmp);\n    }\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;\n    return [v0, v1, v2, v3, v4, v5, v6, v7];\n  }\n  // prettier-ignore\n  protected set(\n    v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number\n  ): void {\n    this.v0 = v0 | 0;\n    this.v1 = v1 | 0;\n    this.v2 = v2 | 0;\n    this.v3 = v3 | 0;\n    this.v4 = v4 | 0;\n    this.v5 = v5 | 0;\n    this.v6 = v6 | 0;\n    this.v7 = v7 | 0;\n  }\n  protected compress(msg: Uint32Array, offset: number, isLast: boolean): void {\n    const { h, l } = u64.fromBig(BigInt(this.length));\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        BSIGMA, offset, msg, 10,\n        this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7,\n        B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]\n      );\n    this.v0 ^= v0 ^ v8;\n    this.v1 ^= v1 ^ v9;\n    this.v2 ^= v2 ^ v10;\n    this.v3 ^= v3 ^ v11;\n    this.v4 ^= v4 ^ v12;\n    this.v5 ^= v5 ^ v13;\n    this.v6 ^= v6 ^ v14;\n    this.v7 ^= v7 ^ v15;\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer32);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * Blake2s hash function. Focuses on 8-bit to 32-bit platforms. 1.5x faster than blake2b in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2s: CHashO = /* @__PURE__ */ createOptHasher<BLAKE2s, Blake2Opts>(\n  (opts) => new BLAKE2s(opts)\n);\n", "/**\n * Blake2b hash function. Focuses on 64-bit platforms, but in JS speed different from Blake2s is negligible.\n * @module\n * @deprecated\n */\nimport { BLAKE2b as B2B, blake2b as b2b } from './blake2.ts';\n/** @deprecated Use import from `noble/hashes/blake2` module */\nexport const BLAKE2b: typeof B2B = B2B;\n/** @deprecated Use import from `noble/hashes/blake2` module */\nexport const blake2b: typeof b2b = b2b;\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\n\n/**\n * Generates a Blake2b hash of typed data as a base64 string.\n *\n * @param typeTag type tag (e.g. TransactionData, SenderSignedData)\n * @param data data to hash\n */\nexport function hashTypedData(typeTag: string, data: Uint8Array): Uint8Array {\n    const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n\n    const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n    dataWithTag.set(typeTagBytes);\n    dataWithTag.set(data, typeTagBytes.length);\n\n    return blake2b(dataWithTag, { dkLen: 32 });\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB58 } from '@iota/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type {\n    Argument,\n    CallArg,\n    Command,\n    GasData,\n    TransactionExpiration,\n} from './data/internal.js';\nimport { TransactionData } from './data/internal.js';\nimport { transactionDataFromV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV2 } from './data/v2.js';\nimport { hashTypedData } from './hash.js';\n\nfunction prepareIotaAddress(address: string) {\n    return normalizeIotaAddress(address).replace('0x', '');\n}\n\nexport class TransactionDataBuilder implements TransactionData {\n    static fromKindBytes(bytes: Uint8Array) {\n        const kind = bcs.TransactionKind.parse(bytes);\n\n        const programmableTx = kind.ProgrammableTransaction;\n        if (!programmableTx) {\n            throw new Error('Unable to deserialize from bytes.');\n        }\n\n        return TransactionDataBuilder.restore({\n            version: 2,\n            sender: null,\n            expiration: null,\n            gasData: {\n                budget: null,\n                owner: null,\n                payment: null,\n                price: null,\n            },\n            inputs: programmableTx.inputs,\n            commands: programmableTx.commands,\n        });\n    }\n\n    static fromBytes(bytes: Uint8Array) {\n        const rawData = bcs.TransactionData.parse(bytes);\n        const data = rawData?.V1;\n        const programmableTx = data.kind.ProgrammableTransaction;\n\n        if (!data || !programmableTx) {\n            throw new Error('Unable to deserialize from bytes.');\n        }\n\n        return TransactionDataBuilder.restore({\n            version: 2,\n            sender: data.sender,\n            expiration: data.expiration,\n            gasData: data.gasData,\n            inputs: programmableTx.inputs,\n            commands: programmableTx.commands,\n        });\n    }\n\n    static restore(\n        data:\n            | InferInput<typeof SerializedTransactionDataV2>\n            | InferInput<typeof SerializedTransactionDataV1>,\n    ) {\n        if (data.version === 2) {\n            return new TransactionDataBuilder(parse(TransactionData, data));\n        } else {\n            return new TransactionDataBuilder(parse(TransactionData, transactionDataFromV1(data)));\n        }\n    }\n\n    /**\n     * Generate transaction digest.\n     *\n     * @param bytes BCS serialized transaction data\n     * @returns transaction digest.\n     */\n    static getDigestFromBytes(bytes: Uint8Array) {\n        const hash = hashTypedData('TransactionData', bytes);\n        return toB58(hash);\n    }\n\n    // @deprecated use gasData instead\n    get gasConfig() {\n        return this.gasData;\n    }\n    // @deprecated use gasData instead\n    set gasConfig(value) {\n        this.gasData = value;\n    }\n\n    version = 2 as const;\n    sender: string | null;\n    expiration: TransactionExpiration | null;\n    gasData: GasData;\n    inputs: CallArg[];\n    commands: Command[];\n\n    constructor(clone?: TransactionData) {\n        this.sender = clone?.sender ?? null;\n        this.expiration = clone?.expiration ?? null;\n        this.inputs = clone?.inputs ?? [];\n        this.commands = clone?.commands ?? [];\n        this.gasData = clone?.gasData ?? {\n            budget: null,\n            price: null,\n            owner: null,\n            payment: null,\n        };\n    }\n\n    build({\n        maxSizeBytes = Infinity,\n        overrides,\n        onlyTransactionKind,\n    }: {\n        maxSizeBytes?: number;\n        overrides?: {\n            expiration?: TransactionExpiration;\n            sender?: string;\n            // @deprecated use gasData instead\n            gasConfig?: Partial<GasData>;\n            gasData?: Partial<GasData>;\n        };\n        onlyTransactionKind?: boolean;\n    } = {}) {\n        // TODO validate that inputs and intents are actually resolved\n        const inputs = this.inputs as (typeof bcs.CallArg.$inferInput)[];\n        const commands = this.commands as Extract<\n            Command<Exclude<Argument, { IntentResult: unknown } | { NestedIntentResult: unknown }>>,\n            { Upgrade: unknown }\n        >[];\n\n        const kind = {\n            ProgrammableTransaction: {\n                inputs,\n                commands,\n            },\n        };\n\n        if (onlyTransactionKind) {\n            return bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n        }\n\n        const expiration = overrides?.expiration ?? this.expiration;\n        const sender = overrides?.sender ?? this.sender;\n        const gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n\n        if (!sender) {\n            throw new Error('Missing transaction sender');\n        }\n\n        if (!gasData.budget) {\n            throw new Error('Missing gas budget');\n        }\n\n        if (!gasData.payment) {\n            throw new Error('Missing gas payment');\n        }\n\n        if (!gasData.price) {\n            throw new Error('Missing gas price');\n        }\n\n        const transactionData = {\n            sender: prepareIotaAddress(sender),\n            expiration: expiration ? expiration : { None: true },\n            gasData: {\n                payment: gasData.payment,\n                owner: prepareIotaAddress(this.gasData.owner ?? sender),\n                price: BigInt(gasData.price),\n                budget: BigInt(gasData.budget),\n            },\n            kind: {\n                ProgrammableTransaction: {\n                    inputs,\n                    commands,\n                },\n            },\n        };\n\n        return bcs.TransactionData.serialize(\n            { V1: transactionData },\n            { maxSize: maxSizeBytes },\n        ).toBytes();\n    }\n\n    addInput<T extends 'object' | 'pure'>(type: T, arg: CallArg) {\n        const index = this.inputs.length;\n        this.inputs.push(arg);\n        return { Input: index, type, $kind: 'Input' as const };\n    }\n\n    getInputUses(index: number, fn: (arg: Argument, command: Command) => void) {\n        this.mapArguments((arg, command) => {\n            if (arg.$kind === 'Input' && arg.Input === index) {\n                fn(arg, command);\n            }\n\n            return arg;\n        });\n    }\n\n    mapArguments(fn: (arg: Argument, command: Command) => Argument) {\n        for (const command of this.commands) {\n            switch (command.$kind) {\n                case 'MoveCall':\n                    command.MoveCall.arguments = command.MoveCall.arguments.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'TransferObjects':\n                    command.TransferObjects.objects = command.TransferObjects.objects.map((arg) =>\n                        fn(arg, command),\n                    );\n                    command.TransferObjects.address = fn(command.TransferObjects.address, command);\n                    break;\n                case 'SplitCoins':\n                    command.SplitCoins.coin = fn(command.SplitCoins.coin, command);\n                    command.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'MergeCoins':\n                    command.MergeCoins.destination = fn(command.MergeCoins.destination, command);\n                    command.MergeCoins.sources = command.MergeCoins.sources.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'MakeMoveVec':\n                    command.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'Upgrade':\n                    command.Upgrade.ticket = fn(command.Upgrade.ticket, command);\n                    break;\n                case '$Intent':\n                    const inputs = command.$Intent.inputs;\n                    command.$Intent.inputs = {};\n\n                    for (const [key, value] of Object.entries(inputs)) {\n                        command.$Intent.inputs[key] = Array.isArray(value)\n                            ? value.map((arg) => fn(arg, command))\n                            : fn(value, command);\n                    }\n\n                    break;\n                case 'Publish':\n                    break;\n                default:\n                    throw new Error(\n                        `Unexpected transaction kind: ${(command as { $kind: unknown }).$kind}`,\n                    );\n            }\n        }\n    }\n\n    replaceCommand(index: number, replacement: Command | Command[]) {\n        if (!Array.isArray(replacement)) {\n            this.commands[index] = replacement;\n            return;\n        }\n\n        const sizeDiff = replacement.length - 1;\n        this.commands.splice(index, 1, ...replacement);\n\n        if (sizeDiff !== 0) {\n            this.mapArguments((arg) => {\n                switch (arg.$kind) {\n                    case 'Result':\n                        if (arg.Result > index) {\n                            arg.Result += sizeDiff;\n                        }\n                        break;\n\n                    case 'NestedResult':\n                        if (arg.NestedResult[0] > index) {\n                            arg.NestedResult[0] += sizeDiff;\n                        }\n                        break;\n                }\n                return arg;\n            });\n        }\n    }\n\n    getDigest() {\n        const bytes = this.build({ onlyTransactionKind: false });\n        return TransactionDataBuilder.getDigestFromBytes(bytes);\n    }\n\n    snapshot(): TransactionData {\n        return parse(TransactionData, this);\n    }\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { IotaMoveNormalizedType } from '../client/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { CallArg } from './data/internal.js';\n\nexport function extractMutableReference(\n    normalizedType: IotaMoveNormalizedType,\n): IotaMoveNormalizedType | undefined {\n    return typeof normalizedType === 'object' && 'MutableReference' in normalizedType\n        ? normalizedType.MutableReference\n        : undefined;\n}\n\nexport function extractReference(\n    normalizedType: IotaMoveNormalizedType,\n): IotaMoveNormalizedType | undefined {\n    return typeof normalizedType === 'object' && 'Reference' in normalizedType\n        ? normalizedType.Reference\n        : undefined;\n}\n\nexport function extractStructTag(\n    normalizedType: IotaMoveNormalizedType,\n): Extract<IotaMoveNormalizedType, { Struct: unknown }> | undefined {\n    if (typeof normalizedType === 'object' && 'Struct' in normalizedType) {\n        return normalizedType;\n    }\n\n    const ref = extractReference(normalizedType);\n    const mutRef = extractMutableReference(normalizedType);\n\n    if (typeof ref === 'object' && 'Struct' in ref) {\n        return ref;\n    }\n\n    if (typeof mutRef === 'object' && 'Struct' in mutRef) {\n        return mutRef;\n    }\n    return undefined;\n}\n\nexport function getIdFromCallArg(arg: string | CallArg) {\n    if (typeof arg === 'string') {\n        return normalizeIotaAddress(arg);\n    }\n\n    if (arg.Object) {\n        if (arg.Object.ImmOrOwnedObject) {\n            return normalizeIotaAddress(arg.Object.ImmOrOwnedObject.objectId);\n        }\n\n        if (arg.Object.Receiving) {\n            return normalizeIotaAddress(arg.Object.Receiving.objectId);\n        }\n\n        return normalizeIotaAddress(arg.Object.SharedObject.objectId);\n    }\n\n    if (arg.UnresolvedObject) {\n        return normalizeIotaAddress(arg.UnresolvedObject.objectId);\n    }\n\n    return undefined;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@iota/bcs';\nimport { fromB64, isSerializedBcs } from '@iota/bcs';\nimport type { InferInput } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { IotaClient } from '../client/index.js';\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport { Argument, NormalizedCallArg, ObjectRef, TransactionExpiration } from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2 } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport type {\n    BuildTransactionOptions,\n    SerializeTransactionOptions,\n    TransactionPlugin,\n} from './json-rpc-resolver.js';\nimport { resolveTransactionData } from './json-rpc-resolver.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\n\nexport type TransactionObjectArgument =\n    | Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>\n    | ((\n          tx: Transaction,\n      ) => Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>);\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n    Extract<Argument, { NestedResult: unknown }>[];\n\nfunction createTransactionResult(index: number) {\n    const baseResult = { $kind: 'Result' as const, Result: index };\n\n    const nestedResults: {\n        $kind: 'NestedResult';\n        NestedResult: [number, number];\n    }[] = [];\n    const nestedResultFor = (\n        resultIndex: number,\n    ): {\n        $kind: 'NestedResult';\n        NestedResult: [number, number];\n    } =>\n        (nestedResults[resultIndex] ??= {\n            $kind: 'NestedResult' as const,\n            NestedResult: [index, resultIndex],\n        });\n\n    return new Proxy(baseResult, {\n        set() {\n            throw new Error(\n                'The transaction result is a proxy, and does not support setting properties directly',\n            );\n        },\n        // TODO: Instead of making this return a concrete argument, we should ideally\n        // make it reference-based (so that this gets resolved at build-time), which\n        // allows re-ordering transactions.\n        get(target, property) {\n            // This allows this transaction argument to be used in the singular form:\n            if (property in target) {\n                return Reflect.get(target, property);\n            }\n\n            // Support destructuring:\n            if (property === Symbol.iterator) {\n                return function* () {\n                    let i = 0;\n                    while (true) {\n                        yield nestedResultFor(i);\n                        i++;\n                    }\n                };\n            }\n\n            if (typeof property === 'symbol') return;\n\n            const resultIndex = parseInt(property, 10);\n            if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n            return nestedResultFor(resultIndex);\n        },\n    }) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@iota/transaction') as never;\n\ninterface SignOptions extends BuildTransactionOptions {\n    signer: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is Transaction {\n    return !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\nconst modulePluginRegistry = {\n    buildPlugins: [] as TransactionPlugin[],\n    serializationPlugins: [] as TransactionPlugin[],\n};\n\nconst TRANSACTION_REGISTRY_KEY = Symbol.for('@iota/transaction/registry');\nfunction getGlobalPluginRegistry() {\n    try {\n        const target = globalThis as {\n            [TRANSACTION_REGISTRY_KEY]?: {\n                buildPlugins: TransactionPlugin[];\n                serializationPlugins: TransactionPlugin[];\n            };\n        };\n\n        if (!target[TRANSACTION_REGISTRY_KEY]) {\n            target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n        }\n\n        return target[TRANSACTION_REGISTRY_KEY];\n    } catch (e) {\n        return modulePluginRegistry;\n    }\n}\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n    #serializationPlugins: TransactionPlugin[];\n    #buildPlugins: TransactionPlugin[];\n    #intentResolvers = new Map<string, TransactionPlugin>();\n\n    /**\n     * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n     * Supports either a byte array, or base64-encoded bytes.\n     */\n    static fromKind(serialized: string | Uint8Array) {\n        const tx = new Transaction();\n\n        tx.#data = TransactionDataBuilder.fromKindBytes(\n            typeof serialized === 'string' ? fromB64(serialized) : serialized,\n        );\n\n        return tx;\n    }\n\n    /**\n     * Converts from a serialized transaction format to a `Transaction` class.\n     * There are two supported serialized formats:\n     * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n     * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n     */\n    static from(transaction: string | Uint8Array | Transaction) {\n        const newTransaction = new Transaction();\n\n        if (isTransaction(transaction)) {\n            newTransaction.#data = new TransactionDataBuilder(transaction.getData());\n        } else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n            newTransaction.#data = TransactionDataBuilder.fromBytes(\n                typeof transaction === 'string' ? fromB64(transaction) : transaction,\n            );\n        } else {\n            newTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n        }\n\n        return newTransaction;\n    }\n\n    static registerGlobalSerializationPlugin(step: TransactionPlugin) {\n        getGlobalPluginRegistry().serializationPlugins.push(step);\n    }\n\n    static registerGlobalBuildPlugin(step: TransactionPlugin) {\n        getGlobalPluginRegistry().buildPlugins.push(step);\n    }\n\n    addSerializationPlugin(step: TransactionPlugin) {\n        this.#serializationPlugins.push(step);\n    }\n\n    addBuildPlugin(step: TransactionPlugin) {\n        this.#buildPlugins.push(step);\n    }\n\n    addIntentResolver(intent: string, resolver: TransactionPlugin) {\n        if (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n            throw new Error(`Intent resolver for ${intent} already exists`);\n        }\n\n        this.#intentResolvers.set(intent, resolver);\n    }\n\n    setSender(sender: string) {\n        this.#data.sender = sender;\n    }\n    /**\n     * Sets the sender only if it has not already been set.\n     * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n     */\n    setSenderIfNotSet(sender: string) {\n        if (!this.#data.sender) {\n            this.#data.sender = sender;\n        }\n    }\n    setExpiration(expiration?: InferInput<typeof TransactionExpiration> | null) {\n        this.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n    }\n    setGasPrice(price: number | bigint) {\n        this.#data.gasConfig.price = String(price);\n    }\n    setGasBudget(budget: number | bigint) {\n        this.#data.gasConfig.budget = String(budget);\n    }\n\n    setGasBudgetIfNotSet(budget: number | bigint) {\n        if (this.#data.gasData.budget == null) {\n            this.#data.gasConfig.budget = String(budget);\n        }\n    }\n\n    setGasOwner(owner: string) {\n        this.#data.gasConfig.owner = owner;\n    }\n    setGasPayment(payments: ObjectRef[]) {\n        this.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));\n    }\n\n    #data: TransactionDataBuilder;\n\n    /** @deprecated Use `getData()` instead. */\n    get blockData() {\n        return serializeV1TransactionData(this.#data.snapshot());\n    }\n\n    /** Get a snapshot of the transaction data, in JSON form: */\n    getData() {\n        return this.#data.snapshot();\n    }\n\n    // Used to brand transaction classes so that they can be identified, even between multiple copies\n    // of the builder.\n    get [TRANSACTION_BRAND]() {\n        return true;\n    }\n\n    // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n    get pure(): ReturnType<typeof createPure<Argument>> {\n        Object.defineProperty(this, 'pure', {\n            enumerable: false,\n            value: createPure<Argument>((value): Argument => {\n                if (isSerializedBcs(value)) {\n                    return this.#data.addInput('pure', {\n                        $kind: 'Pure',\n                        Pure: {\n                            bytes: value.toBase64(),\n                        },\n                    });\n                }\n\n                // TODO: we can also do some deduplication here\n                return this.#data.addInput(\n                    'pure',\n                    is(NormalizedCallArg, value)\n                        ? parse(NormalizedCallArg, value)\n                        : value instanceof Uint8Array\n                          ? Inputs.Pure(value)\n                          : { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n                );\n            }),\n        });\n\n        return this.pure;\n    }\n\n    constructor() {\n        const globalPlugins = getGlobalPluginRegistry();\n        this.#data = new TransactionDataBuilder();\n        this.#buildPlugins = [...globalPlugins.buildPlugins];\n        this.#serializationPlugins = [...globalPlugins.serializationPlugins];\n    }\n\n    /** Returns an argument for the gas coin, to be used in a transaction. */\n    get gas() {\n        return { $kind: 'GasCoin' as const, GasCoin: true as const };\n    }\n\n    /**\n     * Add a new object input to the transaction.\n     */\n    object = createObjectMethods(\n        (value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } => {\n            if (typeof value === 'function') {\n                return this.object(value(this));\n            }\n\n            if (typeof value === 'object' && is(Argument, value)) {\n                return value as { $kind: 'Input'; Input: number; type?: 'object' };\n            }\n\n            const id = getIdFromCallArg(value);\n\n            const inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n            // Upgrade shared object inputs to mutable if needed:\n            if (\n                inserted?.Object?.SharedObject &&\n                typeof value === 'object' &&\n                value.Object?.SharedObject\n            ) {\n                inserted.Object.SharedObject.mutable =\n                    inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n            }\n\n            return inserted\n                ? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n                : this.#data.addInput(\n                      'object',\n                      typeof value === 'string'\n                          ? {\n                                $kind: 'UnresolvedObject',\n                                UnresolvedObject: { objectId: normalizeIotaAddress(value) },\n                            }\n                          : value,\n                  );\n        },\n    );\n\n    /**\n     * Add a new object input to the transaction using the fully-resolved object reference.\n     * If you only have an object ID, use `builder.object(id)` instead.\n     */\n    objectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n        return this.object(Inputs.ObjectRef(...args));\n    }\n\n    /**\n     * Add a new receiving input to the transaction using the fully-resolved object reference.\n     * If you only have an object ID, use `builder.object(id)` instead.\n     */\n    receivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n        return this.object(Inputs.ReceivingRef(...args));\n    }\n\n    /**\n     * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n     * If you only have an object ID, use `builder.object(id)` instead.\n     */\n    sharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n        return this.object(Inputs.SharedObjectRef(...args));\n    }\n\n    /** Add a transaction to the transaction */\n    add<T = TransactionResult>(command: Command | ((tx: Transaction) => T)): T {\n        if (typeof command === 'function') {\n            return command(this);\n        }\n\n        const index = this.#data.commands.push(command);\n\n        return createTransactionResult(index - 1) as T;\n    }\n\n    #normalizeTransactionArgument(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        arg: TransactionArgument | SerializedBcs<any>,\n    ) {\n        if (isSerializedBcs(arg)) {\n            return this.pure(arg);\n        }\n\n        return this.#resolveArgument(arg as TransactionArgument);\n    }\n\n    #resolveArgument(arg: TransactionArgument): Argument {\n        if (typeof arg === 'function') {\n            return parse(Argument, arg(this));\n        }\n\n        return parse(Argument, arg);\n    }\n\n    // Method shorthands:\n\n    splitCoins(\n        coin: TransactionObjectArgument | string,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        amounts: (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n    ) {\n        return this.add(\n            Commands.SplitCoins(\n                typeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n                amounts.map((amount) =>\n                    typeof amount === 'number' ||\n                    typeof amount === 'bigint' ||\n                    typeof amount === 'string'\n                        ? this.pure.u64(amount)\n                        : this.#normalizeTransactionArgument(amount),\n                ),\n            ),\n        );\n    }\n    mergeCoins(\n        destination: TransactionObjectArgument | string,\n        sources: (TransactionObjectArgument | string)[],\n    ) {\n        return this.add(\n            Commands.MergeCoins(\n                this.object(destination),\n                sources.map((src) => this.object(src)),\n            ),\n        );\n    }\n    publish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n        return this.add(\n            Commands.Publish({\n                modules,\n                dependencies,\n            }),\n        );\n    }\n    upgrade({\n        modules,\n        dependencies,\n        package: packageId,\n        ticket,\n    }: {\n        modules: number[][] | string[];\n        dependencies: string[];\n        package: string;\n        ticket: TransactionObjectArgument | string;\n    }) {\n        return this.add(\n            Commands.Upgrade({\n                modules,\n                dependencies,\n                package: packageId,\n                ticket: this.object(ticket),\n            }),\n        );\n    }\n    moveCall({\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        arguments: args,\n        ...input\n    }:\n        | {\n              package: string;\n              module: string;\n              function: string;\n              arguments?: (TransactionArgument | SerializedBcs<any>)[];\n              typeArguments?: string[];\n          }\n        | {\n              target: string;\n              arguments?: (TransactionArgument | SerializedBcs<any>)[];\n              typeArguments?: string[];\n          }) {\n        return this.add(\n            Commands.MoveCall({\n                ...input,\n                arguments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n            } as Parameters<typeof Commands.MoveCall>[0]),\n        );\n    }\n    transferObjects(\n        objects: (TransactionObjectArgument | string)[],\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        address: TransactionArgument | SerializedBcs<any> | string,\n    ) {\n        return this.add(\n            Commands.TransferObjects(\n                objects.map((obj) => this.object(obj)),\n                typeof address === 'string'\n                    ? this.pure.address(address)\n                    : this.#normalizeTransactionArgument(address),\n            ),\n        );\n    }\n    makeMoveVec({\n        type,\n        elements,\n    }: {\n        elements: (TransactionObjectArgument | string)[];\n        type?: string;\n    }) {\n        return this.add(\n            Commands.MakeMoveVec({\n                type,\n                elements: elements.map((obj) => this.object(obj)),\n            }),\n        );\n    }\n\n    /**\n     * @deprecated Use toJSON instead.\n     * For synchronous serialization, you can use `getData()`\n     * */\n    serialize() {\n        return JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n    }\n\n    async toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n        await this.prepareForSerialization(options);\n        return JSON.stringify(\n            parse(SerializedTransactionDataV2, this.#data.snapshot()),\n            (_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n            2,\n        );\n    }\n\n    /** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n    async sign(options: SignOptions): Promise<SignatureWithBytes> {\n        const { signer, ...buildOptions } = options;\n        const bytes = await this.build(buildOptions);\n        return signer.signTransaction(bytes);\n    }\n\n    /** Build the transaction to BCS bytes. */\n    async build(options: BuildTransactionOptions = {}): Promise<Uint8Array> {\n        await this.prepareForSerialization(options);\n        await this.#prepareBuild(options);\n        return this.#data.build({\n            maxSizeBytes: options.maxSizeBytes,\n            onlyTransactionKind: options.onlyTransactionKind,\n        });\n    }\n\n    /** Derive transaction digest */\n    async getDigest(\n        options: {\n            client?: IotaClient;\n        } = {},\n    ): Promise<string> {\n        await this.#prepareBuild(options);\n        return this.#data.getDigest();\n    }\n\n    /**\n     * Prepare the transaction by validating the transaction data and resolving all inputs\n     * so that it can be built into bytes.\n     */\n    async #prepareBuild(options: BuildTransactionOptions) {\n        if (!options.onlyTransactionKind && !this.#data.sender) {\n            throw new Error('Missing transaction sender');\n        }\n\n        await this.#runPlugins([...this.#buildPlugins, resolveTransactionData], options);\n    }\n\n    async #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n        const createNext = (i: number) => {\n            if (i >= plugins.length) {\n                return () => {};\n            }\n            const plugin = plugins[i];\n\n            return async () => {\n                const next = createNext(i + 1);\n                let calledNext = false;\n                let nextResolved = false;\n\n                await plugin(this.#data, options, async () => {\n                    if (calledNext) {\n                        throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n                    }\n\n                    calledNext = true;\n\n                    await next();\n\n                    nextResolved = true;\n                });\n\n                if (!calledNext) {\n                    throw new Error(`next() was not called in TransactionPlugin ${i}`);\n                }\n\n                if (!nextResolved) {\n                    throw new Error(`next() was not awaited in TransactionPlugin ${i}`);\n                }\n            };\n        };\n\n        await createNext(0)();\n    }\n\n    async prepareForSerialization(options: SerializeTransactionOptions) {\n        const intents = new Set<string>();\n        for (const command of this.#data.commands) {\n            if (command.$Intent) {\n                intents.add(command.$Intent.name);\n            }\n        }\n\n        const steps = [...this.#serializationPlugins];\n\n        for (const intent of intents) {\n            if (options.supportedIntents?.includes(intent)) {\n                continue;\n            }\n\n            if (!this.#intentResolvers.has(intent)) {\n                throw new Error(`Missing intent resolver for ${intent}`);\n            }\n\n            steps.push(this.#intentResolvers.get(intent)!);\n        }\n\n        await this.#runPlugins(steps, options);\n    }\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { bcs } from '../bcs/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { OpenMoveTypeSignature } from './data/internal.js';\nimport type { TransactionPlugin } from './json-rpc-resolver.js';\n\nexport interface ObjectCacheEntry {\n    objectId: string;\n    version: string;\n    digest: string;\n    owner: string | null;\n    initialSharedVersion: string | null;\n}\n\nexport interface MoveFunctionCacheEntry {\n    package: string;\n    module: string;\n    function: string;\n    parameters: OpenMoveTypeSignature[];\n}\n\nexport interface CacheEntryTypes {\n    OwnedObject: ObjectCacheEntry;\n    SharedOrImmutableObject: ObjectCacheEntry;\n    MoveFunction: MoveFunctionCacheEntry;\n    Custom: unknown;\n}\nexport abstract class AsyncCache {\n    protected abstract get<T extends keyof CacheEntryTypes>(\n        type: T,\n        key: string,\n    ): Promise<CacheEntryTypes[T] | null>;\n    protected abstract set<T extends keyof CacheEntryTypes>(\n        type: T,\n        key: string,\n        value: CacheEntryTypes[T],\n    ): Promise<void>;\n    protected abstract delete<T extends keyof CacheEntryTypes>(type: T, key: string): Promise<void>;\n    abstract clear<T extends keyof CacheEntryTypes>(type?: T): Promise<void>;\n\n    async getObject(id: string) {\n        const [owned, shared] = await Promise.all([\n            this.get('OwnedObject', id),\n            this.get('SharedOrImmutableObject', id),\n        ]);\n\n        return owned ?? shared ?? null;\n    }\n\n    async getObjects(ids: string[]) {\n        return Promise.all([...ids.map((id) => this.getObject(id))]);\n    }\n\n    async addObject(object: ObjectCacheEntry) {\n        if (object.owner) {\n            await this.set('OwnedObject', object.objectId, object);\n        } else {\n            await this.set('SharedOrImmutableObject', object.objectId, object);\n        }\n\n        return object;\n    }\n\n    async addObjects(objects: ObjectCacheEntry[]) {\n        await Promise.all(objects.map(async (object) => this.addObject(object)));\n    }\n\n    async deleteObject(id: string) {\n        await Promise.all([\n            this.delete('OwnedObject', id),\n            this.delete('SharedOrImmutableObject', id),\n        ]);\n    }\n\n    async deleteObjects(ids: string[]) {\n        await Promise.all(ids.map((id) => this.deleteObject(id)));\n    }\n\n    async getMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n        const functionName = `${normalizeIotaAddress(ref.package)}::${ref.module}::${ref.function}`;\n        return this.get('MoveFunction', functionName);\n    }\n\n    async addMoveFunctionDefinition(functionEntry: MoveFunctionCacheEntry) {\n        const pkg = normalizeIotaAddress(functionEntry.package);\n        const functionName = `${pkg}::${functionEntry.module}::${functionEntry.function}`;\n        const entry = {\n            ...functionEntry,\n            package: pkg,\n        };\n\n        await this.set('MoveFunction', functionName, entry);\n\n        return entry;\n    }\n\n    async deleteMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n        const functionName = `${normalizeIotaAddress(ref.package)}::${ref.module}::${ref.function}`;\n        await this.delete('MoveFunction', functionName);\n    }\n\n    async getCustom<T>(key: string) {\n        return this.get('Custom', key) as Promise<T | null>;\n    }\n\n    async setCustom<T>(key: string, value: T) {\n        return this.set('Custom', key, value);\n    }\n\n    async deleteCustom(key: string) {\n        return this.delete('Custom', key);\n    }\n}\n\nexport class InMemoryCache extends AsyncCache {\n    #caches = {\n        OwnedObject: new Map<string, ObjectCacheEntry>(),\n        SharedOrImmutableObject: new Map<string, ObjectCacheEntry>(),\n        MoveFunction: new Map<string, MoveFunctionCacheEntry>(),\n        Custom: new Map<string, unknown>(),\n    };\n\n    protected async get<T extends keyof CacheEntryTypes>(type: T, key: string) {\n        return (this.#caches[type].get(key) as CacheEntryTypes[T]) ?? null;\n    }\n\n    protected async set<T extends keyof CacheEntryTypes>(\n        type: T,\n        key: string,\n        value: CacheEntryTypes[T],\n    ) {\n        (this.#caches[type] as Map<string, typeof value>).set(key, value as never);\n    }\n\n    protected async delete<T extends keyof CacheEntryTypes>(type: T, key: string) {\n        this.#caches[type].delete(key);\n    }\n\n    async clear<T extends keyof CacheEntryTypes>(type?: T) {\n        if (type) {\n            this.#caches[type].clear();\n        } else {\n            for (const cache of Object.values(this.#caches)) {\n                cache.clear();\n            }\n        }\n    }\n}\n\nexport interface ObjectCacheOptions {\n    cache?: AsyncCache;\n}\n\nexport class ObjectCache {\n    #cache: AsyncCache;\n\n    constructor({ cache = new InMemoryCache() }: ObjectCacheOptions) {\n        this.#cache = cache;\n    }\n\n    asPlugin(): TransactionPlugin {\n        return async (transactionData, _options, next) => {\n            const unresolvedObjects = transactionData.inputs\n                .filter((input) => input.UnresolvedObject)\n                .map((input) => input.UnresolvedObject!.objectId);\n\n            const cached = (await this.#cache.getObjects(unresolvedObjects)).filter(\n                (obj) => obj !== null,\n            );\n\n            const byId = new Map(cached.map((obj) => [obj!.objectId, obj]));\n\n            for (const input of transactionData.inputs) {\n                if (!input.UnresolvedObject) {\n                    continue;\n                }\n\n                const cached = byId.get(input.UnresolvedObject.objectId);\n\n                if (!cached) {\n                    continue;\n                }\n\n                if (cached.initialSharedVersion && !input.UnresolvedObject.initialSharedVersion) {\n                    input.UnresolvedObject.initialSharedVersion = cached.initialSharedVersion;\n                } else {\n                    if (cached.version && !input.UnresolvedObject.version) {\n                        input.UnresolvedObject.version = cached.version;\n                    }\n\n                    if (cached.digest && !input.UnresolvedObject.digest) {\n                        input.UnresolvedObject.digest = cached.digest;\n                    }\n                }\n            }\n\n            await Promise.all(\n                transactionData.commands.map(async (commands) => {\n                    if (commands.MoveCall) {\n                        const def = await this.getMoveFunctionDefinition({\n                            package: commands.MoveCall.package,\n                            module: commands.MoveCall.module,\n                            function: commands.MoveCall.function,\n                        });\n\n                        if (def) {\n                            commands.MoveCall._argumentTypes = def.parameters;\n                        }\n                    }\n                }),\n            );\n\n            await next();\n\n            await Promise.all(\n                transactionData.commands.map(async (commands) => {\n                    if (commands.MoveCall?._argumentTypes) {\n                        await this.#cache.addMoveFunctionDefinition({\n                            package: commands.MoveCall.package,\n                            module: commands.MoveCall.module,\n                            function: commands.MoveCall.function,\n                            parameters: commands.MoveCall._argumentTypes,\n                        });\n                    }\n                }),\n            );\n        };\n    }\n\n    async clear() {\n        await this.#cache.clear();\n    }\n\n    async getMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n        return this.#cache.getMoveFunctionDefinition(ref);\n    }\n\n    async getObjects(ids: string[]) {\n        return this.#cache.getObjects(ids);\n    }\n\n    async deleteObjects(ids: string[]) {\n        return this.#cache.deleteObjects(ids);\n    }\n\n    async clearOwnedObjects() {\n        await this.#cache.clear('OwnedObject');\n    }\n\n    async clearCustom() {\n        await this.#cache.clear('Custom');\n    }\n\n    async getCustom<T>(key: string) {\n        return this.#cache.getCustom<T>(key);\n    }\n\n    async setCustom<T>(key: string, value: T) {\n        return this.#cache.setCustom(key, value);\n    }\n\n    async deleteCustom(key: string) {\n        return this.#cache.deleteCustom(key);\n    }\n\n    async applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n        if (!effects.V1) {\n            throw new Error(`Unsupported transaction effects version ${effects.$kind}`);\n        }\n\n        const { lamportVersion, changedObjects } = effects.V1;\n\n        const deletedIds: string[] = [];\n        const addedObjects: ObjectCacheEntry[] = [];\n\n        changedObjects.map(async ([id, change]) => {\n            if (change.outputState.NotExist) {\n                await this.#cache.deleteObject(id);\n            } else if (change.outputState.ObjectWrite) {\n                const [digest, owner] = change.outputState.ObjectWrite;\n\n                addedObjects.push({\n                    objectId: id,\n                    digest,\n                    version: lamportVersion,\n                    owner: owner.AddressOwner ?? owner.ObjectOwner ?? null,\n                    initialSharedVersion: owner.Shared?.initialSharedVersion ?? null,\n                });\n            }\n        });\n\n        await Promise.all([\n            this.#cache.addObjects(addedObjects),\n            this.#cache.deleteObjects(deletedIds),\n        ]);\n    }\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '../../bcs/index.js';\nimport type { ExecuteTransactionBlockParams, IotaClient } from '../../client/index.js';\nimport type { Signer } from '../../cryptography/keypair.js';\nimport type { BuildTransactionOptions } from '../json-rpc-resolver.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { ObjectCache } from '../ObjectCache.js';\nimport type { Transaction } from '../Transaction.js';\nimport { isTransaction } from '../Transaction.js';\n\nexport class CachingTransactionExecutor {\n    #client: IotaClient;\n    #lastDigest: string | null = null;\n    cache: ObjectCache;\n\n    constructor({\n        client,\n        ...options\n    }: ObjectCacheOptions & {\n        client: IotaClient;\n    }) {\n        this.#client = client;\n        this.cache = new ObjectCache(options);\n    }\n\n    /**\n     * Clears all Owned objects\n     * Immutable objects, Shared objects, and Move function definitions will be preserved\n     */\n    async reset() {\n        await Promise.all([\n            this.cache.clearOwnedObjects(),\n            this.cache.clearCustom(),\n            this.waitForLastTransaction(),\n        ]);\n    }\n\n    async buildTransaction({\n        transaction,\n        ...options\n    }: { transaction: Transaction } & BuildTransactionOptions) {\n        transaction.addBuildPlugin(this.cache.asPlugin());\n        return transaction.build({\n            client: this.#client,\n            ...options,\n        });\n    }\n\n    async executeTransaction({\n        transaction,\n        options,\n        ...input\n    }: {\n        transaction: Transaction | Uint8Array;\n    } & Omit<ExecuteTransactionBlockParams, 'transactionBlock'>) {\n        const bytes = isTransaction(transaction)\n            ? await this.buildTransaction({ transaction })\n            : transaction;\n\n        const results = await this.#client.executeTransactionBlock({\n            ...input,\n            transactionBlock: bytes,\n            options: {\n                ...options,\n                showRawEffects: true,\n            },\n        });\n\n        if (results.rawEffects) {\n            const effects = bcs.TransactionEffects.parse(Uint8Array.from(results.rawEffects));\n            await this.applyEffects(effects);\n        }\n\n        return results;\n    }\n\n    async signAndExecuteTransaction({\n        options,\n        transaction,\n        ...input\n    }: {\n        transaction: Transaction;\n\n        signer: Signer;\n    } & Omit<ExecuteTransactionBlockParams, 'transactionBlock' | 'signature'>) {\n        transaction.setSenderIfNotSet(input.signer.toIotaAddress());\n        const bytes = await this.buildTransaction({ transaction });\n        const { signature } = await input.signer.signTransaction(bytes);\n        const results = await this.executeTransaction({\n            transaction: bytes,\n            signature,\n            options,\n        });\n\n        return results;\n    }\n\n    async applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n        this.#lastDigest = effects.V1?.transactionDigest ?? null;\n        await this.cache.applyEffects(effects);\n    }\n\n    async waitForLastTransaction() {\n        if (this.#lastDigest) {\n            await this.#client.waitForTransaction({ digest: this.#lastDigest });\n            this.#lastDigest = null;\n        }\n    }\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport class SerialQueue {\n    #queue: Array<() => void> = [];\n\n    async runTask<T>(task: () => Promise<T>): Promise<T> {\n        return new Promise((resolve, reject) => {\n            this.#queue.push(() => {\n                task()\n                    .finally(() => {\n                        this.#queue.shift();\n                        if (this.#queue.length > 0) {\n                            this.#queue[0]();\n                        }\n                    })\n                    .then(resolve, reject);\n            });\n\n            if (this.#queue.length === 1) {\n                this.#queue[0]();\n            }\n        });\n    }\n}\n\nexport class ParallelQueue {\n    #queue: Array<() => void> = [];\n    activeTasks = 0;\n    maxTasks: number;\n\n    constructor(maxTasks: number) {\n        this.maxTasks = maxTasks;\n    }\n\n    runTask<T>(task: () => Promise<T>): Promise<T> {\n        return new Promise<T>((resolve, reject) => {\n            if (this.activeTasks < this.maxTasks) {\n                this.activeTasks++;\n\n                task()\n                    .finally(() => {\n                        if (this.#queue.length > 0) {\n                            this.#queue.shift()!();\n                        } else {\n                            this.activeTasks--;\n                        }\n                    })\n                    .then(resolve, reject);\n            } else {\n                this.#queue.push(() => {\n                    task()\n                        .finally(() => {\n                            if (this.#queue.length > 0) {\n                                this.#queue.shift()!();\n                            } else {\n                                this.activeTasks--;\n                            }\n                        })\n                        .then(resolve, reject);\n                });\n            }\n        });\n    }\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@iota/bcs';\n\nimport { bcs } from '../../bcs/index.js';\nimport type { IotaClient, IotaTransactionBlockResponseOptions } from '../../client/index.js';\nimport type { Signer } from '../../cryptography/keypair.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { isTransaction, Transaction } from '../Transaction.js';\nimport { CachingTransactionExecutor } from './caching.js';\nimport { SerialQueue } from './queue.js';\n\nexport class SerialTransactionExecutor {\n    #queue = new SerialQueue();\n    #signer: Signer;\n    #cache: CachingTransactionExecutor;\n    #defaultGasBudget: bigint;\n\n    constructor({\n        signer,\n        defaultGasBudget = 50_000_000n,\n        ...options\n    }: Omit<ObjectCacheOptions, 'address'> & {\n        client: IotaClient;\n        signer: Signer;\n        /** The gasBudget to use if the transaction has not defined it's own gasBudget, defaults to `50_000_000n` */\n        defaultGasBudget?: bigint;\n    }) {\n        this.#signer = signer;\n        this.#defaultGasBudget = defaultGasBudget;\n        this.#cache = new CachingTransactionExecutor({\n            client: options.client,\n            cache: options.cache,\n        });\n    }\n\n    async applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n        return Promise.all([this.#cacheGasCoin(effects), this.#cache.cache.applyEffects(effects)]);\n    }\n\n    #cacheGasCoin = async (effects: typeof bcs.TransactionEffects.$inferType) => {\n        if (!effects.V1) {\n            return;\n        }\n\n        const gasCoin = getGasCoinFromEffects(effects).ref;\n        if (gasCoin) {\n            this.#cache.cache.setCustom('gasCoin', gasCoin);\n        } else {\n            this.#cache.cache.deleteCustom('gasCoin');\n        }\n    };\n\n    async buildTransaction(transaction: Transaction) {\n        return this.#queue.runTask(() => this.#buildTransaction(transaction));\n    }\n\n    #buildTransaction = async (transaction: Transaction) => {\n        const gasCoin = await this.#cache.cache.getCustom<{\n            objectId: string;\n            version: string;\n            digest: string;\n        }>('gasCoin');\n\n        const copy = Transaction.from(transaction);\n        if (gasCoin) {\n            copy.setGasPayment([gasCoin]);\n        }\n\n        copy.setGasBudgetIfNotSet(this.#defaultGasBudget);\n        copy.setSenderIfNotSet(this.#signer.toIotaAddress());\n\n        return this.#cache.buildTransaction({ transaction: copy });\n    };\n\n    resetCache() {\n        return this.#cache.reset();\n    }\n\n    waitForLastTransaction() {\n        return this.#cache.waitForLastTransaction();\n    }\n\n    executeTransaction(\n        transaction: Transaction | Uint8Array,\n        options?: IotaTransactionBlockResponseOptions,\n    ) {\n        return this.#queue.runTask(async () => {\n            const bytes = isTransaction(transaction)\n                ? await this.#buildTransaction(transaction)\n                : transaction;\n\n            const { signature } = await this.#signer.signTransaction(bytes);\n            const results = await this.#cache\n                .executeTransaction({\n                    signature,\n                    transaction: bytes,\n                    options,\n                })\n                .catch(async (error) => {\n                    await this.resetCache();\n                    throw error;\n                });\n\n            const effectsBytes = Uint8Array.from(results.rawEffects!);\n            const effects = bcs.TransactionEffects.parse(effectsBytes);\n            await this.applyEffects(effects);\n\n            return {\n                digest: results.digest,\n                effects: toB64(effectsBytes),\n            };\n        });\n    }\n}\n\nexport function getGasCoinFromEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n    if (!effects.V1) {\n        throw new Error('Unexpected effects version');\n    }\n\n    const gasObjectChange = effects.V1.changedObjects[effects.V1.gasObjectIndex!];\n\n    if (!gasObjectChange) {\n        throw new Error('Gas object not found in effects');\n    }\n\n    const [objectId, { outputState }] = gasObjectChange;\n\n    if (!outputState.ObjectWrite) {\n        throw new Error('Unexpected gas object state');\n    }\n\n    const [digest, owner] = outputState.ObjectWrite;\n\n    return {\n        ref: {\n            objectId,\n            digest,\n            version: effects.V1.lamportVersion,\n        },\n        owner: owner.AddressOwner || owner.ObjectOwner!,\n    };\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@iota/bcs';\n\nimport { bcs } from '../../bcs/index.js';\nimport type { IotaObjectRef } from '../../bcs/types.js';\nimport type { IotaClient, IotaTransactionBlockResponseOptions } from '../../client/index.js';\nimport type { Signer } from '../../cryptography/index.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { Transaction } from '../Transaction.js';\nimport { TransactionDataBuilder } from '../TransactionData.js';\nimport { CachingTransactionExecutor } from './caching.js';\nimport { ParallelQueue, SerialQueue } from './queue.js';\nimport { getGasCoinFromEffects } from './serial.js';\n\nconst PARALLEL_EXECUTOR_DEFAULTS = {\n    coinBatchSize: 20,\n    initialCoinBalance: 200_000_000n,\n    minimumCoinBalance: 50_000_000n,\n    maxPoolSize: 50,\n    epochBoundaryWindow: 1_000,\n} satisfies Omit<ParallelTransactionExecutorOptions, 'signer' | 'client'>;\nexport interface ParallelTransactionExecutorOptions extends Omit<ObjectCacheOptions, 'address'> {\n    client: IotaClient;\n    signer: Signer;\n    /** The number of coins to create in a batch when refilling the gas pool */\n    coinBatchSize?: number;\n    /** The initial balance of each coin created for the gas pool */\n    initialCoinBalance?: bigint;\n    /** The minimum balance of a coin that can be reused for future transactions.  If the gasCoin is below this value, it will be used when refilling the gasPool */\n    minimumCoinBalance?: bigint;\n    /** The gasBudget to use if the transaction has not defined it's own gasBudget, defaults to `minimumCoinBalance` */\n    defaultGasBudget?: bigint;\n    /**\n     * Time to wait before/after the expected epoch boundary before re-fetching the gas pool (in milliseconds).\n     * Building transactions will be paused for up to 2x this duration around each epoch boundary to ensure the\n     * gas price is up-to-date for the next epoch.\n     * */\n    epochBoundaryWindow?: number;\n    /** The maximum number of transactions that can be execute in parallel, this also determines the maximum number of gas coins that will be created */\n    maxPoolSize?: number;\n    /** An initial list of coins used to fund the gas pool, uses all owned IOTA coins by default */\n    sourceCoins?: string[];\n}\n\ninterface CoinWithBalance {\n    id: string;\n    version: string;\n    digest: string;\n    balance: bigint;\n}\nexport class ParallelTransactionExecutor {\n    #signer: Signer;\n    #client: IotaClient;\n    #coinBatchSize: number;\n    #initialCoinBalance: bigint;\n    #minimumCoinBalance: bigint;\n    #epochBoundaryWindow: number;\n    #defaultGasBudget: bigint;\n    #maxPoolSize: number;\n    #sourceCoins: Map<string, IotaObjectRef | null> | null;\n    #coinPool: CoinWithBalance[] = [];\n    #cache: CachingTransactionExecutor;\n    #objectIdQueues = new Map<string, (() => void)[]>();\n    #buildQueue = new SerialQueue();\n    #executeQueue: ParallelQueue;\n    #lastDigest: string | null = null;\n    #cacheLock: Promise<void> | null = null;\n    #pendingTransactions = 0;\n    #gasPrice: null | {\n        price: bigint;\n        expiration: number;\n    } = null;\n\n    constructor(options: ParallelTransactionExecutorOptions) {\n        this.#signer = options.signer;\n        this.#client = options.client;\n        this.#coinBatchSize = options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize;\n        this.#initialCoinBalance =\n            options.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance;\n        this.#minimumCoinBalance =\n            options.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance;\n        this.#defaultGasBudget = options.defaultGasBudget ?? this.#minimumCoinBalance;\n        this.#epochBoundaryWindow =\n            options.epochBoundaryWindow ?? PARALLEL_EXECUTOR_DEFAULTS.epochBoundaryWindow;\n        this.#maxPoolSize = options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize;\n        this.#cache = new CachingTransactionExecutor({\n            client: options.client,\n            cache: options.cache,\n        });\n        this.#executeQueue = new ParallelQueue(this.#maxPoolSize);\n        this.#sourceCoins = options.sourceCoins\n            ? new Map(options.sourceCoins.map((id) => [id, null]))\n            : null;\n    }\n\n    resetCache() {\n        this.#gasPrice = null;\n        return this.#updateCache(() => this.#cache.reset());\n    }\n\n    async waitForLastTransaction() {\n        await this.#updateCache(() => this.#waitForLastDigest());\n    }\n\n    async executeTransaction(\n        transaction: Transaction,\n        options?: IotaTransactionBlockResponseOptions,\n    ) {\n        const { promise, resolve, reject } = promiseWithResolvers<{\n            digest: string;\n            effects: string;\n        }>();\n        const usedObjects = await this.#getUsedObjects(transaction);\n\n        const execute = () => {\n            this.#executeQueue.runTask(() => {\n                const promise = this.#execute(transaction, usedObjects, options);\n\n                return promise.then(resolve, reject);\n            });\n        };\n\n        const conflicts = new Set<string>();\n\n        usedObjects.forEach((objectId) => {\n            const queue = this.#objectIdQueues.get(objectId);\n            if (queue) {\n                conflicts.add(objectId);\n                this.#objectIdQueues.get(objectId)!.push(() => {\n                    conflicts.delete(objectId);\n                    if (conflicts.size === 0) {\n                        execute();\n                    }\n                });\n            } else {\n                this.#objectIdQueues.set(objectId, []);\n            }\n        });\n\n        if (conflicts.size === 0) {\n            execute();\n        }\n\n        return promise;\n    }\n\n    async #getUsedObjects(transaction: Transaction) {\n        const usedObjects = new Set<string>();\n        let serialized = false;\n\n        transaction.addSerializationPlugin(async (blockData, _options, next) => {\n            await next();\n\n            if (serialized) {\n                return;\n            }\n            serialized = true;\n\n            blockData.inputs.forEach((input) => {\n                if (input.Object?.ImmOrOwnedObject?.objectId) {\n                    usedObjects.add(input.Object.ImmOrOwnedObject.objectId);\n                } else if (input.Object?.Receiving?.objectId) {\n                    usedObjects.add(input.Object.Receiving.objectId);\n                } else if (\n                    input.UnresolvedObject?.objectId &&\n                    !input.UnresolvedObject.initialSharedVersion\n                ) {\n                    usedObjects.add(input.UnresolvedObject.objectId);\n                }\n            });\n        });\n\n        await transaction.prepareForSerialization({ client: this.#client });\n\n        return usedObjects;\n    }\n\n    async #execute(\n        transaction: Transaction,\n        usedObjects: Set<string>,\n        options?: IotaTransactionBlockResponseOptions,\n    ) {\n        let gasCoin!: CoinWithBalance;\n        try {\n            transaction.setSenderIfNotSet(this.#signer.toIotaAddress());\n\n            await this.#buildQueue.runTask(async () => {\n                const data = transaction.getData();\n\n                if (!data.gasData.price) {\n                    transaction.setGasPrice(await this.#getGasPrice());\n                }\n\n                transaction.setGasBudgetIfNotSet(this.#defaultGasBudget);\n\n                await this.#updateCache();\n                gasCoin = await this.#getGasCoin();\n                this.#pendingTransactions++;\n                transaction.setGasPayment([\n                    {\n                        objectId: gasCoin.id,\n                        version: gasCoin.version,\n                        digest: gasCoin.digest,\n                    },\n                ]);\n\n                // Resolve cached references\n                await this.#cache.buildTransaction({ transaction, onlyTransactionKind: true });\n            });\n\n            const bytes = await transaction.build({ client: this.#client });\n\n            const { signature } = await this.#signer.signTransaction(bytes);\n\n            const results = await this.#cache.executeTransaction({\n                transaction: bytes,\n                signature,\n                options: {\n                    ...options,\n                    showEffects: true,\n                },\n            });\n\n            const effectsBytes = Uint8Array.from(results.rawEffects!);\n            const effects = bcs.TransactionEffects.parse(effectsBytes);\n\n            const gasResult = getGasCoinFromEffects(effects);\n            const gasUsed = effects.V1?.gasUsed;\n\n            if (gasCoin && gasUsed && gasResult.owner === this.#signer.toIotaAddress()) {\n                const totalUsed =\n                    BigInt(gasUsed.computationCost) +\n                    BigInt(gasUsed.storageCost) +\n                    BigInt(gasUsed.storageCost) -\n                    BigInt(gasUsed.storageRebate);\n\n                let usesGasCoin = false;\n                new TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {\n                    if (arg.$kind === 'GasCoin') {\n                        usesGasCoin = true;\n                    }\n\n                    return arg;\n                });\n\n                if (!usesGasCoin && gasCoin.balance >= this.#minimumCoinBalance) {\n                    this.#coinPool.push({\n                        id: gasResult.ref.objectId,\n                        version: gasResult.ref.version,\n                        digest: gasResult.ref.digest,\n                        balance: gasCoin.balance - totalUsed,\n                    });\n                } else {\n                    if (!this.#sourceCoins) {\n                        this.#sourceCoins = new Map();\n                    }\n                    this.#sourceCoins.set(gasResult.ref.objectId, gasResult.ref);\n                }\n            }\n\n            this.#lastDigest = results.digest;\n\n            return {\n                digest: results.digest,\n                effects: toB64(effectsBytes),\n            };\n        } catch (error) {\n            if (gasCoin) {\n                if (!this.#sourceCoins) {\n                    this.#sourceCoins = new Map();\n                }\n\n                this.#sourceCoins.set(gasCoin.id, null);\n            }\n\n            await this.#updateCache(async () => {\n                await Promise.all([\n                    this.#cache.cache.deleteObjects([...usedObjects]),\n                    this.#waitForLastDigest(),\n                ]);\n            });\n\n            throw error;\n        } finally {\n            usedObjects.forEach((objectId) => {\n                const queue = this.#objectIdQueues.get(objectId);\n                if (queue && queue.length > 0) {\n                    queue.shift()!();\n                } else if (queue) {\n                    this.#objectIdQueues.delete(objectId);\n                }\n            });\n            this.#pendingTransactions--;\n        }\n    }\n\n    /** Helper for synchronizing cache updates, by ensuring only one update happens at a time.  This can also be used to wait for any pending cache updates  */\n    async #updateCache(fn?: () => Promise<void>) {\n        if (this.#cacheLock) {\n            await this.#cacheLock;\n        }\n\n        this.#cacheLock =\n            fn?.().then(\n                () => {\n                    this.#cacheLock = null;\n                },\n                () => {},\n            ) ?? null;\n    }\n\n    async #waitForLastDigest() {\n        const digest = this.#lastDigest;\n        if (digest) {\n            this.#lastDigest = null;\n            await this.#client.waitForTransaction({ digest });\n        }\n    }\n\n    async #getGasCoin() {\n        if (this.#coinPool.length === 0 && this.#pendingTransactions <= this.#maxPoolSize) {\n            await this.#refillCoinPool();\n        }\n\n        if (this.#coinPool.length === 0) {\n            throw new Error('No coins available');\n        }\n\n        const coin = this.#coinPool.shift()!;\n        return coin;\n    }\n\n    async #getGasPrice(): Promise<bigint> {\n        const remaining = this.#gasPrice\n            ? this.#gasPrice.expiration - this.#epochBoundaryWindow - Date.now()\n            : 0;\n\n        if (remaining > 0) {\n            return this.#gasPrice!.price;\n        }\n\n        if (this.#gasPrice) {\n            const timeToNextEpoch = Math.max(\n                this.#gasPrice.expiration + this.#epochBoundaryWindow - Date.now(),\n                1_000,\n            );\n\n            await new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));\n        }\n\n        const state = await this.#client.getLatestIotaSystemState();\n\n        this.#gasPrice = {\n            price: BigInt(state.referenceGasPrice),\n            expiration:\n                Number.parseInt(state.epochStartTimestampMs, 10) +\n                Number.parseInt(state.epochDurationMs, 10),\n        };\n\n        return this.#getGasPrice();\n    }\n\n    async #refillCoinPool() {\n        const batchSize = Math.min(\n            this.#coinBatchSize,\n            this.#maxPoolSize - (this.#coinPool.length + this.#pendingTransactions) + 1,\n        );\n\n        if (batchSize === 0) {\n            return;\n        }\n\n        const txb = new Transaction();\n        const address = this.#signer.toIotaAddress();\n        txb.setSender(address);\n\n        if (this.#sourceCoins) {\n            const refs = [];\n            const ids = [];\n            for (const [id, ref] of this.#sourceCoins) {\n                if (ref) {\n                    refs.push(ref);\n                } else {\n                    ids.push(id);\n                }\n            }\n\n            if (ids.length > 0) {\n                const coins = await this.#client.multiGetObjects({\n                    ids,\n                });\n                refs.push(\n                    ...coins\n                        .filter(\n                            (coin): coin is typeof coin & { data: object } => coin.data !== null,\n                        )\n                        .map(({ data }) => ({\n                            objectId: data.objectId,\n                            version: data.version,\n                            digest: data.digest,\n                        })),\n                );\n            }\n\n            txb.setGasPayment(refs);\n            this.#sourceCoins = new Map();\n        }\n\n        const amounts = new Array(batchSize).fill(this.#initialCoinBalance);\n        const results = txb.splitCoins(txb.gas, amounts);\n        const coinResults = [];\n        for (let i = 0; i < amounts.length; i++) {\n            coinResults.push(results[i]);\n        }\n        txb.transferObjects(coinResults, address);\n\n        await this.waitForLastTransaction();\n\n        const result = await this.#client.signAndExecuteTransaction({\n            transaction: txb,\n            signer: this.#signer,\n            options: {\n                showRawEffects: true,\n            },\n        });\n\n        const effects = bcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects!));\n        effects.V1?.changedObjects.forEach(([id, { outputState }], i) => {\n            if (i === effects.V1?.gasObjectIndex || !outputState.ObjectWrite) {\n                return;\n            }\n\n            this.#coinPool.push({\n                id,\n                version: effects.V1!.lamportVersion,\n                digest: outputState.ObjectWrite[0],\n                balance: BigInt(this.#initialCoinBalance),\n            });\n        });\n\n        if (!this.#sourceCoins) {\n            this.#sourceCoins = new Map();\n        }\n\n        const gasObject = getGasCoinFromEffects(effects).ref;\n        this.#sourceCoins!.set(gasObject.objectId, gasObject);\n\n        await this.#client.waitForTransaction({ digest: result.digest });\n    }\n}\n\nfunction promiseWithResolvers<T>() {\n    let resolve: (value: T) => void;\n    let reject: (reason: any) => void;\n\n    const promise = new Promise<T>((_resolve, _reject) => {\n        resolve = _resolve;\n        reject = _reject;\n    });\n\n    return { promise, resolve: resolve!, reject: reject! };\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { InferInput } from 'valibot';\nimport { bigint, object, parse, string } from 'valibot';\n\nimport { bcs } from '../../bcs/index.js';\nimport type { CoinStruct, IotaClient } from '../../client/index.js';\nimport { normalizeStructTag } from '../../utils/iota-types.js';\nimport { Commands } from '../Commands.js';\nimport type { Argument } from '../data/internal.js';\nimport { Inputs } from '../Inputs.js';\nimport type { BuildTransactionOptions } from '../json-rpc-resolver.js';\nimport { getClient } from '../json-rpc-resolver.js';\nimport type { Transaction } from '../Transaction.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\n\nconst COIN_WITH_BALANCE = 'CoinWithBalance';\nconst IOTA_TYPE = normalizeStructTag('0x2::iota::IOTA');\n\nexport function coinWithBalance({\n    type = IOTA_TYPE,\n    balance,\n    useGasCoin = true,\n}: {\n    balance: bigint | number;\n    type?: string;\n    useGasCoin?: boolean;\n}) {\n    return (tx: Transaction) => {\n        tx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);\n        const coinType = type === 'gas' ? type : normalizeStructTag(type);\n\n        return tx.add(\n            Commands.Intent({\n                name: COIN_WITH_BALANCE,\n                inputs: {},\n                data: {\n                    type: coinType === IOTA_TYPE && useGasCoin ? 'gas' : coinType,\n                    balance: BigInt(balance),\n                } satisfies InferInput<typeof CoinWithBalanceData>,\n            }),\n        );\n    };\n}\n\nconst CoinWithBalanceData = object({\n    type: string(),\n    balance: bigint(),\n});\n\nasync function resolveCoinBalance(\n    transactionData: TransactionDataBuilder,\n    buildOptions: BuildTransactionOptions,\n    next: () => Promise<void>,\n) {\n    const coinTypes = new Set<string>();\n    const totalByType = new Map<string, bigint>();\n\n    if (!transactionData.sender) {\n        throw new Error('Sender must be set to resolve CoinWithBalance');\n    }\n\n    for (const command of transactionData.commands) {\n        if (command.$kind === '$Intent' && command.$Intent.name === COIN_WITH_BALANCE) {\n            const { type, balance } = parse(CoinWithBalanceData, command.$Intent.data);\n\n            if (type !== 'gas') {\n                coinTypes.add(type);\n            }\n\n            totalByType.set(type, (totalByType.get(type) ?? 0n) + balance);\n        }\n    }\n    const usedIds = new Set<string>();\n\n    for (const input of transactionData.inputs) {\n        if (input.Object?.ImmOrOwnedObject) {\n            usedIds.add(input.Object.ImmOrOwnedObject.objectId);\n        }\n        if (input.UnresolvedObject?.objectId) {\n            usedIds.add(input.UnresolvedObject.objectId);\n        }\n    }\n\n    const coinsByType = new Map<string, CoinStruct[]>();\n    const client = getClient(buildOptions);\n    await Promise.all(\n        [...coinTypes].map(async (coinType) => {\n            coinsByType.set(\n                coinType,\n                await getCoinsOfType({\n                    coinType,\n                    balance: totalByType.get(coinType)!,\n                    client,\n                    owner: transactionData.sender!,\n                    usedIds,\n                }),\n            );\n        }),\n    );\n\n    const mergedCoins = new Map<string, Argument>();\n\n    mergedCoins.set('gas', { $kind: 'GasCoin', GasCoin: true });\n\n    for (const [index, transaction] of transactionData.commands.entries()) {\n        if (transaction.$kind !== '$Intent' || transaction.$Intent.name !== COIN_WITH_BALANCE) {\n            continue;\n        }\n\n        const { type, balance } = transaction.$Intent.data as {\n            type: string;\n            balance: bigint;\n        };\n\n        const commands = [];\n\n        if (!mergedCoins.has(type)) {\n            const [first, ...rest] = coinsByType.get(type)!.map((coin) =>\n                transactionData.addInput(\n                    'object',\n                    Inputs.ObjectRef({\n                        objectId: coin.coinObjectId,\n                        digest: coin.digest,\n                        version: coin.version,\n                    }),\n                ),\n            );\n\n            if (rest.length > 0) {\n                commands.push(Commands.MergeCoins(first, rest));\n            }\n\n            mergedCoins.set(type, first);\n        }\n\n        commands.push(\n            Commands.SplitCoins(mergedCoins.get(type)!, [\n                transactionData.addInput('pure', Inputs.Pure(bcs.u64().serialize(balance))),\n            ]),\n        );\n\n        transactionData.replaceCommand(index, commands);\n\n        transactionData.mapArguments((arg) => {\n            if (arg.$kind === 'Result' && arg.Result === index) {\n                return {\n                    $kind: 'NestedResult',\n                    NestedResult: [index + commands.length - 1, 0],\n                };\n            }\n\n            return arg;\n        });\n    }\n\n    return next();\n}\n\nasync function getCoinsOfType({\n    coinType,\n    balance,\n    client,\n    owner,\n    usedIds,\n}: {\n    coinType: string;\n    balance: bigint;\n    client: IotaClient;\n    owner: string;\n    usedIds: Set<string>;\n}): Promise<CoinStruct[]> {\n    let remainingBalance = balance;\n    const coins: CoinStruct[] = [];\n\n    return loadMoreCoins();\n\n    async function loadMoreCoins(cursor: string | null = null): Promise<CoinStruct[]> {\n        const { data, hasNextPage, nextCursor } = await client.getCoins({\n            owner,\n            coinType,\n            cursor,\n        });\n\n        const sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));\n\n        for (const coin of sortedCoins) {\n            if (usedIds.has(coin.coinObjectId)) {\n                continue;\n            }\n\n            const coinBalance = BigInt(coin.balance);\n\n            coins.push(coin);\n            remainingBalance -= coinBalance;\n\n            if (remainingBalance <= 0) {\n                return coins;\n            }\n        }\n\n        if (hasNextPage) {\n            return loadMoreCoins(nextCursor);\n        }\n\n        throw new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);\n    }\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Inputs } from './Inputs.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport type { Transaction, TransactionObjectInput } from './Transaction.js';\n\nexport const Arguments = {\n    pure: createPure((value) => (tx: Transaction) => tx.pure(value)),\n    object: createObjectMethods(\n        (value: TransactionObjectInput) => (tx: Transaction) => tx.object(value),\n    ),\n    sharedObjectRef:\n        (...args: Parameters<(typeof Inputs)['SharedObjectRef']>) =>\n        (tx: Transaction) =>\n            tx.sharedObjectRef(...args),\n    objectRef:\n        (...args: Parameters<(typeof Inputs)['ObjectRef']>) =>\n        (tx: Transaction) =>\n            tx.objectRef(...args),\n    receivingRef:\n        (...args: Parameters<(typeof Inputs)['ReceivingRef']>) =>\n        (tx: Transaction) =>\n            tx.receivingRef(...args),\n};\n"],
  "mappings": "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",
  "names": ["ALPHABET", "string", "esm_default", "esm_default", "base64String", "chunk", "bigint", "_BcsType", "options", "validate", "toBytes", "array", "name", "validate", "Argument", "GasData", "StructTag", "ProgrammableMoveCall", "Command", "ObjectArg", "CallArg", "TransactionExpiration", "TransactionData", "UpgradePolicy", "Argument", "ObjectRef", "ObjectArg", "NormalizedCallArg", "TransactionExpiration", "TypeTag", "StructTag", "TransactionData", "Argument", "GasData", "ProgrammableMoveCall", "$Intent", "Command", "ObjectArg", "CallArg", "TransactionExpiration", "chunk", "object", "inputs", "object", "array", "isLE", "_32n", "blake2b", "blake2b", "TransactionData", "_Transaction", "__privateAdd", "Argument", "__privateGet", "__privateSet", "TransactionExpiration", "object", "__privateAdd", "__privateGet", "__privateSet", "cached", "__privateAdd", "__privateSet", "__privateGet", "_queue", "__privateAdd", "__privateGet", "_queue", "_cache", "__privateAdd", "__privateGet", "__privateSet", "_signer", "_client", "_defaultGasBudget", "_cache", "_lastDigest", "__privateAdd", "__privateSet", "__privateGet", "__privateMethod", "promise", "_a"]
}
