"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var format_exports = {};
__export(format_exports, {
  formatAddress: () => formatAddress,
  formatDigest: () => formatDigest,
  formatType: () => formatType,
  trimAddress: () => trimAddress,
  trimOrFormatAddress: () => trimOrFormatAddress
});
module.exports = __toCommonJS(format_exports);
var import_iota_types = require("./iota-types.js");
const ELLIPSIS = "\u2026";
function formatAddress(address) {
  if (address.length <= 6) {
    return address;
  }
  const offset = address.startsWith("0x") ? 2 : 0;
  return `0x${address.slice(offset, offset + 4)}${ELLIPSIS}${address.slice(-4)}`;
}
function formatDigest(digest) {
  return `${digest.slice(0, 10)}${ELLIPSIS}`;
}
function formatType(type) {
  const objectAddressPattern = new RegExp(`0x[a-fA-F0-9]{${import_iota_types.IOTA_ADDRESS_LENGTH * 2}}`, "g");
  const matches = type.match(objectAddressPattern) ?? [];
  for (const match of matches) {
    if ((0, import_iota_types.isValidIotaAddress)(match) || (0, import_iota_types.isValidIotaObjectId)(match)) {
      type = type.replace(match, formatAddress(match));
    }
  }
  return type;
}
const ADDRESS_TRIM_MAX_LENGTH = 8;
function trimAddress(address) {
  const addr = address.toLowerCase().replace(/^0x/, "");
  const shortened = addr.replace(/^0+/, "") || "0";
  return `0x${shortened}`;
}
function trimOrFormatAddress(address) {
  if (address.length <= 6) {
    return address;
  }
  const trimmedAddress = trimAddress(address);
  if (trimmedAddress.length <= ADDRESS_TRIM_MAX_LENGTH) {
    return trimmedAddress;
  }
  return formatAddress(address);
}
//# sourceMappingURL=format.js.map
