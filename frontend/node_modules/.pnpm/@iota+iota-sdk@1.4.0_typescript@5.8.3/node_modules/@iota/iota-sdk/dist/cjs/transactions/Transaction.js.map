{
  "version": 3,
  "sources": ["../../../src/transactions/Transaction.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@iota/bcs';\nimport { fromB64, isSerializedBcs } from '@iota/bcs';\nimport type { InferInput } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { IotaClient } from '../client/index.js';\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport { Argument, NormalizedCallArg, ObjectRef, TransactionExpiration } from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2 } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport type {\n    BuildTransactionOptions,\n    SerializeTransactionOptions,\n    TransactionPlugin,\n} from './json-rpc-resolver.js';\nimport { resolveTransactionData } from './json-rpc-resolver.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\n\nexport type TransactionObjectArgument =\n    | Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>\n    | ((\n          tx: Transaction,\n      ) => Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>);\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n    Extract<Argument, { NestedResult: unknown }>[];\n\nfunction createTransactionResult(index: number) {\n    const baseResult = { $kind: 'Result' as const, Result: index };\n\n    const nestedResults: {\n        $kind: 'NestedResult';\n        NestedResult: [number, number];\n    }[] = [];\n    const nestedResultFor = (\n        resultIndex: number,\n    ): {\n        $kind: 'NestedResult';\n        NestedResult: [number, number];\n    } =>\n        (nestedResults[resultIndex] ??= {\n            $kind: 'NestedResult' as const,\n            NestedResult: [index, resultIndex],\n        });\n\n    return new Proxy(baseResult, {\n        set() {\n            throw new Error(\n                'The transaction result is a proxy, and does not support setting properties directly',\n            );\n        },\n        // TODO: Instead of making this return a concrete argument, we should ideally\n        // make it reference-based (so that this gets resolved at build-time), which\n        // allows re-ordering transactions.\n        get(target, property) {\n            // This allows this transaction argument to be used in the singular form:\n            if (property in target) {\n                return Reflect.get(target, property);\n            }\n\n            // Support destructuring:\n            if (property === Symbol.iterator) {\n                return function* () {\n                    let i = 0;\n                    while (true) {\n                        yield nestedResultFor(i);\n                        i++;\n                    }\n                };\n            }\n\n            if (typeof property === 'symbol') return;\n\n            const resultIndex = parseInt(property, 10);\n            if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n            return nestedResultFor(resultIndex);\n        },\n    }) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@iota/transaction') as never;\n\ninterface SignOptions extends BuildTransactionOptions {\n    signer: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is Transaction {\n    return !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\nconst modulePluginRegistry = {\n    buildPlugins: [] as TransactionPlugin[],\n    serializationPlugins: [] as TransactionPlugin[],\n};\n\nconst TRANSACTION_REGISTRY_KEY = Symbol.for('@iota/transaction/registry');\nfunction getGlobalPluginRegistry() {\n    try {\n        const target = globalThis as {\n            [TRANSACTION_REGISTRY_KEY]?: {\n                buildPlugins: TransactionPlugin[];\n                serializationPlugins: TransactionPlugin[];\n            };\n        };\n\n        if (!target[TRANSACTION_REGISTRY_KEY]) {\n            target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n        }\n\n        return target[TRANSACTION_REGISTRY_KEY];\n    } catch (e) {\n        return modulePluginRegistry;\n    }\n}\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n    #serializationPlugins: TransactionPlugin[];\n    #buildPlugins: TransactionPlugin[];\n    #intentResolvers = new Map<string, TransactionPlugin>();\n\n    /**\n     * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n     * Supports either a byte array, or base64-encoded bytes.\n     */\n    static fromKind(serialized: string | Uint8Array) {\n        const tx = new Transaction();\n\n        tx.#data = TransactionDataBuilder.fromKindBytes(\n            typeof serialized === 'string' ? fromB64(serialized) : serialized,\n        );\n\n        return tx;\n    }\n\n    /**\n     * Converts from a serialized transaction format to a `Transaction` class.\n     * There are two supported serialized formats:\n     * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n     * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n     */\n    static from(transaction: string | Uint8Array | Transaction) {\n        const newTransaction = new Transaction();\n\n        if (isTransaction(transaction)) {\n            newTransaction.#data = new TransactionDataBuilder(transaction.getData());\n        } else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n            newTransaction.#data = TransactionDataBuilder.fromBytes(\n                typeof transaction === 'string' ? fromB64(transaction) : transaction,\n            );\n        } else {\n            newTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n        }\n\n        return newTransaction;\n    }\n\n    static registerGlobalSerializationPlugin(step: TransactionPlugin) {\n        getGlobalPluginRegistry().serializationPlugins.push(step);\n    }\n\n    static registerGlobalBuildPlugin(step: TransactionPlugin) {\n        getGlobalPluginRegistry().buildPlugins.push(step);\n    }\n\n    addSerializationPlugin(step: TransactionPlugin) {\n        this.#serializationPlugins.push(step);\n    }\n\n    addBuildPlugin(step: TransactionPlugin) {\n        this.#buildPlugins.push(step);\n    }\n\n    addIntentResolver(intent: string, resolver: TransactionPlugin) {\n        if (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n            throw new Error(`Intent resolver for ${intent} already exists`);\n        }\n\n        this.#intentResolvers.set(intent, resolver);\n    }\n\n    setSender(sender: string) {\n        this.#data.sender = sender;\n    }\n    /**\n     * Sets the sender only if it has not already been set.\n     * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n     */\n    setSenderIfNotSet(sender: string) {\n        if (!this.#data.sender) {\n            this.#data.sender = sender;\n        }\n    }\n    setExpiration(expiration?: InferInput<typeof TransactionExpiration> | null) {\n        this.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n    }\n    setGasPrice(price: number | bigint) {\n        this.#data.gasConfig.price = String(price);\n    }\n    setGasBudget(budget: number | bigint) {\n        this.#data.gasConfig.budget = String(budget);\n    }\n\n    setGasBudgetIfNotSet(budget: number | bigint) {\n        if (this.#data.gasData.budget == null) {\n            this.#data.gasConfig.budget = String(budget);\n        }\n    }\n\n    setGasOwner(owner: string) {\n        this.#data.gasConfig.owner = owner;\n    }\n    setGasPayment(payments: ObjectRef[]) {\n        this.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));\n    }\n\n    #data: TransactionDataBuilder;\n\n    /** @deprecated Use `getData()` instead. */\n    get blockData() {\n        return serializeV1TransactionData(this.#data.snapshot());\n    }\n\n    /** Get a snapshot of the transaction data, in JSON form: */\n    getData() {\n        return this.#data.snapshot();\n    }\n\n    // Used to brand transaction classes so that they can be identified, even between multiple copies\n    // of the builder.\n    get [TRANSACTION_BRAND]() {\n        return true;\n    }\n\n    // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n    get pure(): ReturnType<typeof createPure<Argument>> {\n        Object.defineProperty(this, 'pure', {\n            enumerable: false,\n            value: createPure<Argument>((value): Argument => {\n                if (isSerializedBcs(value)) {\n                    return this.#data.addInput('pure', {\n                        $kind: 'Pure',\n                        Pure: {\n                            bytes: value.toBase64(),\n                        },\n                    });\n                }\n\n                // TODO: we can also do some deduplication here\n                return this.#data.addInput(\n                    'pure',\n                    is(NormalizedCallArg, value)\n                        ? parse(NormalizedCallArg, value)\n                        : value instanceof Uint8Array\n                          ? Inputs.Pure(value)\n                          : { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n                );\n            }),\n        });\n\n        return this.pure;\n    }\n\n    constructor() {\n        const globalPlugins = getGlobalPluginRegistry();\n        this.#data = new TransactionDataBuilder();\n        this.#buildPlugins = [...globalPlugins.buildPlugins];\n        this.#serializationPlugins = [...globalPlugins.serializationPlugins];\n    }\n\n    /** Returns an argument for the gas coin, to be used in a transaction. */\n    get gas() {\n        return { $kind: 'GasCoin' as const, GasCoin: true as const };\n    }\n\n    /**\n     * Add a new object input to the transaction.\n     */\n    object = createObjectMethods(\n        (value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } => {\n            if (typeof value === 'function') {\n                return this.object(value(this));\n            }\n\n            if (typeof value === 'object' && is(Argument, value)) {\n                return value as { $kind: 'Input'; Input: number; type?: 'object' };\n            }\n\n            const id = getIdFromCallArg(value);\n\n            const inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n            // Upgrade shared object inputs to mutable if needed:\n            if (\n                inserted?.Object?.SharedObject &&\n                typeof value === 'object' &&\n                value.Object?.SharedObject\n            ) {\n                inserted.Object.SharedObject.mutable =\n                    inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n            }\n\n            return inserted\n                ? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n                : this.#data.addInput(\n                      'object',\n                      typeof value === 'string'\n                          ? {\n                                $kind: 'UnresolvedObject',\n                                UnresolvedObject: { objectId: normalizeIotaAddress(value) },\n                            }\n                          : value,\n                  );\n        },\n    );\n\n    /**\n     * Add a new object input to the transaction using the fully-resolved object reference.\n     * If you only have an object ID, use `builder.object(id)` instead.\n     */\n    objectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n        return this.object(Inputs.ObjectRef(...args));\n    }\n\n    /**\n     * Add a new receiving input to the transaction using the fully-resolved object reference.\n     * If you only have an object ID, use `builder.object(id)` instead.\n     */\n    receivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n        return this.object(Inputs.ReceivingRef(...args));\n    }\n\n    /**\n     * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n     * If you only have an object ID, use `builder.object(id)` instead.\n     */\n    sharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n        return this.object(Inputs.SharedObjectRef(...args));\n    }\n\n    /** Add a transaction to the transaction */\n    add<T = TransactionResult>(command: Command | ((tx: Transaction) => T)): T {\n        if (typeof command === 'function') {\n            return command(this);\n        }\n\n        const index = this.#data.commands.push(command);\n\n        return createTransactionResult(index - 1) as T;\n    }\n\n    #normalizeTransactionArgument(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        arg: TransactionArgument | SerializedBcs<any>,\n    ) {\n        if (isSerializedBcs(arg)) {\n            return this.pure(arg);\n        }\n\n        return this.#resolveArgument(arg as TransactionArgument);\n    }\n\n    #resolveArgument(arg: TransactionArgument): Argument {\n        if (typeof arg === 'function') {\n            return parse(Argument, arg(this));\n        }\n\n        return parse(Argument, arg);\n    }\n\n    // Method shorthands:\n\n    splitCoins(\n        coin: TransactionObjectArgument | string,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        amounts: (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n    ) {\n        return this.add(\n            Commands.SplitCoins(\n                typeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n                amounts.map((amount) =>\n                    typeof amount === 'number' ||\n                    typeof amount === 'bigint' ||\n                    typeof amount === 'string'\n                        ? this.pure.u64(amount)\n                        : this.#normalizeTransactionArgument(amount),\n                ),\n            ),\n        );\n    }\n    mergeCoins(\n        destination: TransactionObjectArgument | string,\n        sources: (TransactionObjectArgument | string)[],\n    ) {\n        return this.add(\n            Commands.MergeCoins(\n                this.object(destination),\n                sources.map((src) => this.object(src)),\n            ),\n        );\n    }\n    publish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n        return this.add(\n            Commands.Publish({\n                modules,\n                dependencies,\n            }),\n        );\n    }\n    upgrade({\n        modules,\n        dependencies,\n        package: packageId,\n        ticket,\n    }: {\n        modules: number[][] | string[];\n        dependencies: string[];\n        package: string;\n        ticket: TransactionObjectArgument | string;\n    }) {\n        return this.add(\n            Commands.Upgrade({\n                modules,\n                dependencies,\n                package: packageId,\n                ticket: this.object(ticket),\n            }),\n        );\n    }\n    moveCall({\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        arguments: args,\n        ...input\n    }:\n        | {\n              package: string;\n              module: string;\n              function: string;\n              arguments?: (TransactionArgument | SerializedBcs<any>)[];\n              typeArguments?: string[];\n          }\n        | {\n              target: string;\n              arguments?: (TransactionArgument | SerializedBcs<any>)[];\n              typeArguments?: string[];\n          }) {\n        return this.add(\n            Commands.MoveCall({\n                ...input,\n                arguments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n            } as Parameters<typeof Commands.MoveCall>[0]),\n        );\n    }\n    transferObjects(\n        objects: (TransactionObjectArgument | string)[],\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        address: TransactionArgument | SerializedBcs<any> | string,\n    ) {\n        return this.add(\n            Commands.TransferObjects(\n                objects.map((obj) => this.object(obj)),\n                typeof address === 'string'\n                    ? this.pure.address(address)\n                    : this.#normalizeTransactionArgument(address),\n            ),\n        );\n    }\n    makeMoveVec({\n        type,\n        elements,\n    }: {\n        elements: (TransactionObjectArgument | string)[];\n        type?: string;\n    }) {\n        return this.add(\n            Commands.MakeMoveVec({\n                type,\n                elements: elements.map((obj) => this.object(obj)),\n            }),\n        );\n    }\n\n    /**\n     * @deprecated Use toJSON instead.\n     * For synchronous serialization, you can use `getData()`\n     * */\n    serialize() {\n        return JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n    }\n\n    async toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n        await this.prepareForSerialization(options);\n        return JSON.stringify(\n            parse(SerializedTransactionDataV2, this.#data.snapshot()),\n            (_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n            2,\n        );\n    }\n\n    /** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n    async sign(options: SignOptions): Promise<SignatureWithBytes> {\n        const { signer, ...buildOptions } = options;\n        const bytes = await this.build(buildOptions);\n        return signer.signTransaction(bytes);\n    }\n\n    /** Build the transaction to BCS bytes. */\n    async build(options: BuildTransactionOptions = {}): Promise<Uint8Array> {\n        await this.prepareForSerialization(options);\n        await this.#prepareBuild(options);\n        return this.#data.build({\n            maxSizeBytes: options.maxSizeBytes,\n            onlyTransactionKind: options.onlyTransactionKind,\n        });\n    }\n\n    /** Derive transaction digest */\n    async getDigest(\n        options: {\n            client?: IotaClient;\n        } = {},\n    ): Promise<string> {\n        await this.#prepareBuild(options);\n        return this.#data.getDigest();\n    }\n\n    /**\n     * Prepare the transaction by validating the transaction data and resolving all inputs\n     * so that it can be built into bytes.\n     */\n    async #prepareBuild(options: BuildTransactionOptions) {\n        if (!options.onlyTransactionKind && !this.#data.sender) {\n            throw new Error('Missing transaction sender');\n        }\n\n        await this.#runPlugins([...this.#buildPlugins, resolveTransactionData], options);\n    }\n\n    async #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n        const createNext = (i: number) => {\n            if (i >= plugins.length) {\n                return () => {};\n            }\n            const plugin = plugins[i];\n\n            return async () => {\n                const next = createNext(i + 1);\n                let calledNext = false;\n                let nextResolved = false;\n\n                await plugin(this.#data, options, async () => {\n                    if (calledNext) {\n                        throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n                    }\n\n                    calledNext = true;\n\n                    await next();\n\n                    nextResolved = true;\n                });\n\n                if (!calledNext) {\n                    throw new Error(`next() was not called in TransactionPlugin ${i}`);\n                }\n\n                if (!nextResolved) {\n                    throw new Error(`next() was not awaited in TransactionPlugin ${i}`);\n                }\n            };\n        };\n\n        await createNext(0)();\n    }\n\n    async prepareForSerialization(options: SerializeTransactionOptions) {\n        const intents = new Set<string>();\n        for (const command of this.#data.commands) {\n            if (command.$Intent) {\n                intents.add(command.$Intent.name);\n            }\n        }\n\n        const steps = [...this.#serializationPlugins];\n\n        for (const intent of intents) {\n            if (options.supportedIntents?.includes(intent)) {\n                continue;\n            }\n\n            if (!this.#intentResolvers.has(intent)) {\n                throw new Error(`Missing intent resolver for ${intent}`);\n            }\n\n            steps.push(this.#intentResolvers.get(intent)!);\n        }\n\n        await this.#runPlugins(steps, options);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
