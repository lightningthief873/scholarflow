{
  "version": 3,
  "sources": ["../../../src/multisig/publickey.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@iota/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { bcs } from '../bcs/index.js';\nimport type { Signer } from '../cryptography/keypair.js';\nimport { bytesEqual, PublicKey } from '../cryptography/publickey.js';\nimport {\n    SIGNATURE_FLAG_TO_SCHEME,\n    SIGNATURE_SCHEME_TO_FLAG,\n} from '../cryptography/signature-scheme.js';\nimport type { SignatureFlag, SignatureScheme } from '../cryptography/signature-scheme.js';\nimport { parseSerializedSignature } from '../cryptography/signature.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\n// eslint-disable-next-line import/no-cycle\nimport { publicKeyFromRawBytes } from '../verify/index.js';\nimport { MultiSigSigner } from './signer.js';\n\ntype CompressedSignature =\n    | { ED25519: number[] }\n    | { Secp256k1: number[] }\n    | { Secp256r1: number[] };\n\ntype PublicKeyEnum = { ED25519: number[] } | { Secp256k1: number[] } | { Secp256r1: number[] };\n\ntype PubkeyEnumWeightPair = {\n    pubKey: PublicKeyEnum;\n    weight: number;\n};\n\ntype MultiSigPublicKeyStruct = {\n    pk_map: PubkeyEnumWeightPair[];\n    threshold: number;\n};\n\nexport type MultiSigStruct = {\n    sigs: CompressedSignature[];\n    bitmap: number;\n    multisig_pk: MultiSigPublicKeyStruct;\n};\n\ntype ParsedPartialMultiSigSignature = {\n    signatureScheme: SignatureScheme;\n    signature: Uint8Array;\n    publicKey: PublicKey;\n    weight: number;\n};\n\nexport const MAX_SIGNER_IN_MULTISIG = 10;\nexport const MIN_SIGNER_IN_MULTISIG = 1;\n/**\n * A MultiSig public key\n */\nexport class MultiSigPublicKey extends PublicKey {\n    private rawBytes: Uint8Array;\n    private multisigPublicKey: MultiSigPublicKeyStruct;\n    private publicKeys: {\n        weight: number;\n        publicKey: PublicKey;\n    }[];\n    /**\n     * Create a new MultiSigPublicKey object\n     */\n    constructor(\n        /**\n         *  MultiSig public key as buffer or base-64 encoded string\n         */\n        value: string | Uint8Array | MultiSigPublicKeyStruct,\n    ) {\n        super();\n\n        if (typeof value === 'string') {\n            this.rawBytes = fromB64(value);\n\n            this.multisigPublicKey = bcs.MultiSigPublicKey.parse(this.rawBytes);\n        } else if (value instanceof Uint8Array) {\n            this.rawBytes = value;\n            this.multisigPublicKey = bcs.MultiSigPublicKey.parse(this.rawBytes);\n        } else {\n            this.multisigPublicKey = value;\n            this.rawBytes = bcs.MultiSigPublicKey.serialize(value).toBytes();\n        }\n        if (this.multisigPublicKey.threshold < 1) {\n            throw new Error('Invalid threshold');\n        }\n\n        const seenPublicKeys = new Set<string>();\n\n        this.publicKeys = this.multisigPublicKey.pk_map.map(({ pubKey, weight }) => {\n            const [scheme, bytes] = Object.entries(pubKey).filter(\n                ([name]) => name !== '$kind',\n            )[0] as [SignatureScheme, number[]];\n            const publicKeyStr = Uint8Array.from(bytes).toString();\n\n            if (seenPublicKeys.has(publicKeyStr)) {\n                throw new Error(`Multisig does not support duplicate public keys`);\n            }\n            seenPublicKeys.add(publicKeyStr);\n\n            if (weight < 1) {\n                throw new Error(`Invalid weight`);\n            }\n\n            return {\n                publicKey: publicKeyFromRawBytes(scheme, Uint8Array.from(bytes)),\n                weight,\n            };\n        });\n\n        const totalWeight = this.publicKeys.reduce((sum, { weight }) => sum + weight, 0);\n\n        if (this.multisigPublicKey.threshold > totalWeight) {\n            throw new Error(`Unreachable threshold`);\n        }\n\n        if (this.publicKeys.length > MAX_SIGNER_IN_MULTISIG) {\n            throw new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n        }\n\n        if (this.publicKeys.length < MIN_SIGNER_IN_MULTISIG) {\n            throw new Error(`Min number of signers in a multisig is ${MIN_SIGNER_IN_MULTISIG}`);\n        }\n    }\n    /**\n     * \tA static method to create a new MultiSig publickey instance from a set of public keys and their associated weights pairs and threshold.\n     */\n\n    static fromPublicKeys({\n        threshold,\n        publicKeys,\n    }: {\n        threshold: number;\n        publicKeys: { publicKey: PublicKey; weight: number }[];\n    }) {\n        return new MultiSigPublicKey({\n            pk_map: publicKeys.map(({ publicKey, weight }) => {\n                const scheme = SIGNATURE_FLAG_TO_SCHEME[publicKey.flag() as SignatureFlag];\n\n                return {\n                    pubKey: { [scheme]: Array.from(publicKey.toRawBytes()) } as PublicKeyEnum,\n                    weight,\n                };\n            }),\n            threshold,\n        });\n    }\n\n    /**\n     * Checks if two MultiSig public keys are equal\n     */\n    override equals(publicKey: MultiSigPublicKey): boolean {\n        return super.equals(publicKey);\n    }\n\n    /**\n     * Return the byte array representation of the MultiSig public key\n     */\n    toRawBytes(): Uint8Array {\n        return this.rawBytes;\n    }\n\n    getPublicKeys() {\n        return this.publicKeys;\n    }\n\n    getThreshold() {\n        return this.multisigPublicKey.threshold;\n    }\n\n    getSigner(...signers: [signer: Signer]) {\n        return new MultiSigSigner(this, signers);\n    }\n\n    /**\n     * Return the IOTA address associated with this MultiSig public key\n     */\n    override toIotaAddress(): string {\n        // max length = 1 flag byte + (max pk size + max weight size (u8)) * max signer size + 2 threshold bytes (u16)\n        const maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;\n        const tmp = new Uint8Array(maxLength);\n        tmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\n        tmp.set(bcs.u16().serialize(this.multisigPublicKey.threshold).toBytes(), 1);\n        // The initial value 3 ensures that following data will be after the flag byte and threshold bytes\n        let i = 3;\n        for (const { publicKey, weight } of this.publicKeys) {\n            const bytes = publicKey.toIotaBytesForAddress();\n            tmp.set(bytes, i);\n            i += bytes.length;\n            tmp.set([weight], i++);\n        }\n        return normalizeIotaAddress(bytesToHex(blake2b(tmp.slice(0, i), { dkLen: 32 })));\n    }\n\n    /**\n     * Return the IOTA address associated with this MultiSig public key\n     */\n    flag(): number {\n        return SIGNATURE_SCHEME_TO_FLAG['MultiSig'];\n    }\n\n    /**\n     * Verifies that the signature is valid for the provided message\n     */\n    async verify(message: Uint8Array, multisigSignature: string): Promise<boolean> {\n        // Multisig verification only supports serialized signature\n        const parsed = parseSerializedSignature(multisigSignature);\n\n        if (parsed.signatureScheme !== 'MultiSig') {\n            throw new Error('Invalid signature scheme');\n        }\n\n        const { multisig } = parsed;\n\n        let signatureWeight = 0;\n\n        if (\n            !bytesEqual(\n                bcs.MultiSigPublicKey.serialize(this.multisigPublicKey).toBytes(),\n                bcs.MultiSigPublicKey.serialize(multisig.multisig_pk).toBytes(),\n            )\n        ) {\n            return false;\n        }\n\n        for (const { publicKey, weight, signature } of parsePartialSignatures(multisig)) {\n            if (!(await publicKey.verify(message, signature))) {\n                return false;\n            }\n\n            signatureWeight += weight;\n        }\n\n        return signatureWeight >= this.multisigPublicKey.threshold;\n    }\n\n    /**\n     * Combines multiple partial signatures into a single multisig, ensuring that each public key signs only once\n     * and that all the public keys involved are known and valid, and then serializes multisig into the standard format\n     */\n    combinePartialSignatures(signatures: string[]): string {\n        if (signatures.length > MAX_SIGNER_IN_MULTISIG) {\n            throw new Error(`Max number of signatures in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n        }\n\n        let bitmap = 0;\n        const compressedSignatures: CompressedSignature[] = new Array(signatures.length);\n\n        for (let i = 0; i < signatures.length; i++) {\n            const parsed = parseSerializedSignature(signatures[i]);\n            if (parsed.signatureScheme === 'MultiSig') {\n                throw new Error('MultiSig is not supported inside MultiSig');\n            }\n\n            const publicKey = parsed.publicKey;\n\n            compressedSignatures[i] = {\n                [parsed.signatureScheme]: Array.from(\n                    parsed.signature.map((x: number) => Number(x)),\n                ),\n            } as CompressedSignature;\n\n            let publicKeyIndex;\n            for (let j = 0; j < this.publicKeys.length; j++) {\n                if (bytesEqual(publicKey, this.publicKeys[j].publicKey.toRawBytes())) {\n                    if (bitmap & (1 << j)) {\n                        throw new Error('Received multiple signatures from the same public key');\n                    }\n\n                    publicKeyIndex = j;\n                    break;\n                }\n            }\n\n            if (publicKeyIndex === undefined) {\n                throw new Error('Received signature from unknown public key');\n            }\n\n            bitmap |= 1 << publicKeyIndex;\n        }\n\n        const multisig: MultiSigStruct = {\n            sigs: compressedSignatures,\n            bitmap,\n            multisig_pk: this.multisigPublicKey,\n        };\n        const bytes = bcs.MultiSig.serialize(multisig, { maxSize: 8192 }).toBytes();\n        const tmp = new Uint8Array(bytes.length + 1);\n        tmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n        tmp.set(bytes, 1);\n        return toB64(tmp);\n    }\n}\n\n/**\n * Parse multisig structure into an array of individual signatures: signature scheme, the actual individual signature, public key and its weight.\n */\nexport function parsePartialSignatures(multisig: MultiSigStruct): ParsedPartialMultiSigSignature[] {\n    const res: ParsedPartialMultiSigSignature[] = new Array(multisig.sigs.length);\n    for (let i = 0; i < multisig.sigs.length; i++) {\n        const [signatureScheme, signature] = Object.entries(multisig.sigs[i]).filter(\n            ([name]) => name !== '$kind',\n        )[0] as [SignatureScheme, number[]];\n        const pkIndex = asIndices(multisig.bitmap).at(i)!;\n        const pair = multisig.multisig_pk.pk_map[pkIndex];\n        const pkBytes = Uint8Array.from(Object.values(pair.pubKey)[0]);\n\n        if (signatureScheme === 'MultiSig') {\n            throw new Error('MultiSig is not supported inside MultiSig');\n        }\n\n        const publicKey = publicKeyFromRawBytes(signatureScheme, pkBytes);\n\n        res[i] = {\n            signatureScheme,\n            signature: Uint8Array.from(signature),\n            publicKey: publicKey,\n            weight: pair.weight,\n        };\n    }\n    return res;\n}\n\nfunction asIndices(bitmap: number): Uint8Array {\n    if (bitmap < 0 || bitmap > 1024) {\n        throw new Error('Invalid bitmap');\n    }\n    const res: number[] = [];\n    for (let i = 0; i < 10; i++) {\n        if ((bitmap & (1 << i)) !== 0) {\n            res.push(i);\n        }\n    }\n    return Uint8Array.from(res);\n}\n"],
  "mappings": "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",
  "names": []
}
