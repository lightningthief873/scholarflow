{
  "version": 3,
  "sources": ["../../../src/bcs/types.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport type SharedObjectRef = {\n    /** Hex code as string representing the object id */\n    objectId: string;\n\n    /** The version the object was shared at */\n    initialSharedVersion: number | string;\n\n    /** Whether reference is mutable */\n    mutable: boolean;\n};\n\nexport type IotaObjectRef = {\n    /** Base64 string representing the object digest */\n    objectId: string;\n    /** Object version */\n    version: number | string;\n    /** Hex code as string representing the object id */\n    digest: string;\n};\n\n/**\n * An object argument.\n */\nexport type ObjectArg =\n    | { ImmOrOwnedObject: IotaObjectRef }\n    | { SharedObject: SharedObjectRef }\n    | { Receiving: IotaObjectRef };\n\nexport type ObjectCallArg = {\n    Object: ObjectArg;\n};\n\n/**\n * A pure argument.\n */\nexport type PureArg = { Pure: Array<number> };\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isPureArg(arg: any): arg is PureArg {\n    return (arg as PureArg).Pure !== undefined;\n}\n\n/**\n * An argument for the transaction. It is a 'meant' enum which expects to have\n * one of the optional properties. If not, the BCS error will be thrown while\n * attempting to form a transaction.\n *\n * Example:\n * ```js\n * let arg1: CallArg = { Object: { Shared: {\n *   objectId: '5460cf92b5e3e7067aaace60d88324095fd22944',\n *   initialSharedVersion: 1,\n *   mutable: true,\n * } } };\n * let arg2: CallArg = { Pure: bcs.ser(BCS.STRING, 100000).toBytes() };\n * let arg3: CallArg = { Object: { ImmOrOwned: {\n *   objectId: '4047d2e25211d87922b6650233bd0503a6734279',\n *   version: 1,\n *   digest: 'bCiANCht4O9MEUhuYjdRCqRPZjr2rJ8MfqNiwyhmRgA='\n * } } };\n * ```\n *\n * For `Pure` arguments BCS is required. You must encode the values with BCS according\n * to the type required by the called function. Pure accepts only serialized values\n */\nexport type CallArg = PureArg | ObjectCallArg;\n\n/**\n * Kind of a TypeTag which is represented by a Move type identifier.\n */\nexport type StructTag = {\n    address: string;\n    module: string;\n    name: string;\n    typeParams: TypeTag[];\n};\n\n/**\n * IOTA TypeTag object. A decoupled `0x...::module::Type<???>` parameter.\n */\nexport type TypeTag =\n    | { bool: null | true }\n    | { u8: null | true }\n    | { u64: null | true }\n    | { u128: null | true }\n    | { address: null | true }\n    | { signer: null | true }\n    | { vector: TypeTag }\n    | { struct: StructTag }\n    | { u16: null | true }\n    | { u32: null | true }\n    | { u256: null | true };\n\n// ========== TransactionData ===========\n\n/**\n * The GasData to be used in the transaction.\n */\nexport type GasData = {\n    payment: IotaObjectRef[];\n    owner: string; // Gas Object's owner\n    price: number;\n    budget: number;\n};\n\n/**\n * TransactionExpiration\n *\n * Indications the expiration time for a transaction.\n */\nexport type TransactionExpiration = { None: null } | { Epoch: number };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AA0CO,SAAS,UAAU,KAA0B;AAChD,SAAQ,IAAgB,SAAS;AACrC;",
  "names": []
}
