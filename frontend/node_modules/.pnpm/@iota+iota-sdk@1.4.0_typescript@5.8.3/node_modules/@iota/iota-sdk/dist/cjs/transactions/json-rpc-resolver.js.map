{
  "version": 3,
  "sources": ["../../../src/transactions/json-rpc-resolver.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\n\nimport type { BcsType } from '../bcs/index.js';\nimport { bcs } from '../bcs/index.js';\nimport type { IotaClient } from '../client/client.js';\nimport { normalizeIotaAddress, normalizeIotaObjectId, IOTA_TYPE_ARG } from '../utils/index.js';\nimport { ObjectRef } from './data/internal.js';\nimport type { Argument, CallArg, Command, OpenMoveTypeSignature } from './data/internal.js';\nimport { Inputs } from './Inputs.js';\nimport { getPureBcsSchema, isTxContext, normalizedTypeToMoveTypeSignature } from './serializer.js';\nimport type { TransactionDataBuilder } from './TransactionData.js';\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 50_000_000_000;\n\nexport interface BuildTransactionOptions {\n    client?: IotaClient;\n    onlyTransactionKind?: boolean;\n    maxSizeBytes?: number;\n}\n\nexport interface SerializeTransactionOptions extends BuildTransactionOptions {\n    supportedIntents?: string[];\n}\n\nexport type TransactionPlugin = (\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n    next: () => Promise<void>,\n) => Promise<void>;\n\nexport async function resolveTransactionData(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n    next: () => Promise<void>,\n) {\n    await normalizeInputs(transactionData, options);\n    await resolveObjectReferences(transactionData, options);\n\n    if (!options.onlyTransactionKind) {\n        await setGasPrice(transactionData, options);\n        await setGasBudget(transactionData, options);\n        await setGasPayment(transactionData, options);\n    }\n    await validate(transactionData);\n    return await next();\n}\n\nasync function setGasPrice(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    if (!transactionData.gasConfig.price) {\n        transactionData.gasConfig.price = String(await getClient(options).getReferenceGasPrice());\n    }\n}\n\nasync function setGasBudget(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    if (transactionData.gasConfig.budget) {\n        return;\n    }\n\n    const dryRunResult = await getClient(options).dryRunTransactionBlock({\n        transactionBlock: transactionData.build({\n            overrides: {\n                gasData: {\n                    budget: String(MAX_GAS),\n                    payment: [],\n                },\n            },\n        }),\n    });\n\n    if (dryRunResult.effects.status.status !== 'success') {\n        throw new Error(\n            `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n            { cause: dryRunResult },\n        );\n    }\n\n    const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n\n    const baseComputationCostWithOverhead =\n        BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n    const gasBudget =\n        baseComputationCostWithOverhead +\n        BigInt(dryRunResult.effects.gasUsed.storageCost) -\n        BigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n    transactionData.gasConfig.budget = String(\n        gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n    );\n}\n\n// The current default is just picking _all_ coins we can which may not be ideal.\nasync function setGasPayment(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    if (!transactionData.gasConfig.payment) {\n        const coins = await getClient(options).getCoins({\n            owner: transactionData.gasConfig.owner || transactionData.sender!,\n            coinType: IOTA_TYPE_ARG,\n        });\n\n        const paymentCoins = coins.data\n            // Filter out coins that are also used as input:\n            .filter((coin) => {\n                const matchingInput = transactionData.inputs.find((input) => {\n                    if (input.Object?.ImmOrOwnedObject) {\n                        return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n                    }\n\n                    return false;\n                });\n\n                return !matchingInput;\n            })\n            .map((coin) => ({\n                objectId: coin.coinObjectId,\n                digest: coin.digest,\n                version: coin.version,\n            }));\n\n        if (!paymentCoins.length) {\n            throw new Error('No valid gas coins found for the transaction.');\n        }\n\n        transactionData.gasConfig.payment = paymentCoins.map((payment) =>\n            parse(ObjectRef, payment),\n        );\n    }\n}\n\nasync function resolveObjectReferences(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    // Keep track of the object references that will need to be resolved at the end of the transaction.\n    // We keep the input by-reference to avoid needing to re-resolve it:\n    const objectsToResolve = transactionData.inputs.filter((input) => {\n        return (\n            input.UnresolvedObject &&\n            !(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion)\n        );\n    }) as Extract<CallArg, { UnresolvedObject: unknown }>[];\n\n    const dedupedIds = [\n        ...new Set(\n            objectsToResolve.map((input) => normalizeIotaObjectId(input.UnresolvedObject.objectId)),\n        ),\n    ];\n\n    const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n\n    const resolvedObjects = new Map();\n    const erroredObjects = new Map();\n\n    await Promise.all(\n        objectChunks.map(async (chunk) => {\n            const chunkObjects = await getClient(options).multiGetObjects({\n                ids: chunk,\n                options: { showOwner: true },\n            });\n\n            for (const object of chunkObjects) {\n                const objectId = object.data?.objectId;\n                if (objectId) {\n                    if (object.error || !object.data) {\n                        erroredObjects.set(objectId, object.error);\n                        return;\n                    }\n                    const owner = object.data.owner;\n                    const initialSharedVersion =\n                        owner && typeof owner === 'object' && 'Shared' in owner\n                            ? owner.Shared.initial_shared_version\n                            : null;\n\n                    resolvedObjects.set(objectId, {\n                        objectId,\n                        digest: object.data.digest,\n                        version: object.data.version,\n                        initialSharedVersion,\n                    });\n                }\n            }\n        }),\n    );\n\n    if (erroredObjects.size > 0) {\n        throw new Error(\n            `The following input objects are invalid: ${Array.from(erroredObjects).join(', ')}`,\n        );\n    }\n\n    for (const [index, input] of transactionData.inputs.entries()) {\n        if (!input.UnresolvedObject) {\n            continue;\n        }\n\n        let updated: CallArg | undefined;\n        const id = normalizeIotaAddress(input.UnresolvedObject.objectId);\n        const object = resolvedObjects.get(id);\n\n        if (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n            updated = Inputs.SharedObjectRef({\n                objectId: id,\n                initialSharedVersion:\n                    input.UnresolvedObject.initialSharedVersion ||\n                    (object?.initialSharedVersion as string),\n                mutable: isUsedAsMutable(transactionData, index),\n            });\n        } else if (isUsedAsReceiving(transactionData, index)) {\n            updated = Inputs.ReceivingRef(\n                {\n                    objectId: id,\n                    digest: input.UnresolvedObject.digest ?? (object?.digest as string),\n                    version: input.UnresolvedObject.version ?? (object?.version as string),\n                }!,\n            );\n        }\n\n        transactionData.inputs[transactionData.inputs.indexOf(input)] =\n            updated ??\n            Inputs.ObjectRef({\n                objectId: id,\n                digest: input.UnresolvedObject.digest ?? (object?.digest as string),\n                version: input.UnresolvedObject.version ?? (object?.version as string),\n            });\n    }\n}\n\nasync function normalizeInputs(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    const { inputs, commands } = transactionData;\n    const moveCallsToResolve: Extract<Command, { MoveCall: unknown }>['MoveCall'][] = [];\n    const moveFunctionsToResolve = new Set<string>();\n\n    commands.forEach((command) => {\n        // Special case move call:\n        if (command.MoveCall) {\n            // Determine if any of the arguments require encoding.\n            // - If they don't, then this is good to go.\n            // - If they do, then we need to fetch the normalized move module.\n\n            // If we already know the argument types, we don't need to resolve them again\n            if (command.MoveCall._argumentTypes) {\n                return;\n            }\n\n            const inputs = command.MoveCall.arguments.map((arg) => {\n                if (arg.$kind === 'Input') {\n                    return transactionData.inputs[arg.Input];\n                }\n                return null;\n            });\n            const needsResolution = inputs.some(\n                (input) => input?.UnresolvedPure || input?.UnresolvedObject,\n            );\n\n            if (needsResolution) {\n                const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n                moveFunctionsToResolve.add(functionName);\n                moveCallsToResolve.push(command.MoveCall);\n            }\n        }\n\n        // Special handling for values that where previously encoded using the wellKnownEncoding pattern.\n        // This should only happen when transaction data was hydrated from an old version of the SDK\n        switch (command.$kind) {\n            case 'SplitCoins':\n                command.SplitCoins.amounts.forEach((amount) => {\n                    normalizeRawArgument(amount, bcs.U64, transactionData);\n                });\n                break;\n            case 'TransferObjects':\n                normalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n                break;\n        }\n    });\n\n    const moveFunctionParameters = new Map<string, OpenMoveTypeSignature[]>();\n    if (moveFunctionsToResolve.size > 0) {\n        const client = getClient(options);\n        await Promise.all(\n            [...moveFunctionsToResolve].map(async (functionName) => {\n                const [packageId, moduleId, functionId] = functionName.split('::');\n                const def = await client.getNormalizedMoveFunction({\n                    package: packageId,\n                    module: moduleId,\n                    function: functionId,\n                });\n\n                moveFunctionParameters.set(\n                    functionName,\n                    def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param)),\n                );\n            }),\n        );\n    }\n\n    if (moveCallsToResolve.length) {\n        await Promise.all(\n            moveCallsToResolve.map(async (moveCall) => {\n                const parameters = moveFunctionParameters.get(\n                    `${moveCall.package}::${moveCall.module}::${moveCall.function}`,\n                );\n\n                if (!parameters) {\n                    return;\n                }\n\n                // Entry functions can have a mutable reference to an instance of the TxContext\n                // struct defined in the TxContext module as the last parameter. The caller of\n                // the function does not need to pass it in as an argument.\n                const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1)!);\n                const params = hasTxContext\n                    ? parameters.slice(0, parameters.length - 1)\n                    : parameters;\n\n                moveCall._argumentTypes = params;\n            }),\n        );\n    }\n\n    commands.forEach((command) => {\n        if (!command.MoveCall) {\n            return;\n        }\n\n        const moveCall = command.MoveCall;\n        const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n        const params = moveCall._argumentTypes;\n\n        if (!params) {\n            return;\n        }\n\n        if (params.length !== command.MoveCall.arguments.length) {\n            throw new Error(`Incorrect number of arguments for ${fnName}`);\n        }\n\n        params.forEach((param, i) => {\n            const arg = moveCall.arguments[i];\n            if (arg.$kind !== 'Input') return;\n            const input = inputs[arg.Input];\n\n            // Skip if the input is already resolved\n            if (!input.UnresolvedPure && !input.UnresolvedObject) {\n                return;\n            }\n\n            const inputValue =\n                input.UnresolvedPure?.value ?? (input.UnresolvedObject?.objectId as string);\n\n            const inputIndex = inputs.indexOf(input);\n\n            const schema = getPureBcsSchema(param.body);\n            if (schema) {\n                arg.type = 'pure';\n                inputs[inputIndex] = Inputs.Pure(schema.serialize(inputValue));\n                return;\n            }\n\n            if (typeof inputValue !== 'string') {\n                throw new Error(\n                    `Expect the argument to be an object id string, got ${JSON.stringify(\n                        inputValue,\n                        null,\n                        2,\n                    )}`,\n                );\n            }\n\n            arg.type = 'object';\n            const unresolvedObject: typeof input = input.UnresolvedPure\n                ? {\n                      $kind: 'UnresolvedObject',\n                      UnresolvedObject: {\n                          objectId: inputValue,\n                      },\n                  }\n                : input;\n\n            inputs[inputIndex] = unresolvedObject;\n        });\n    });\n}\n\nfunction validate(transactionData: TransactionDataBuilder) {\n    transactionData.inputs.forEach((input, index) => {\n        if (input.$kind !== 'Object' && input.$kind !== 'Pure') {\n            throw new Error(\n                `Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n                    input,\n                )}`,\n            );\n        }\n    });\n}\n\nfunction normalizeRawArgument(\n    arg: Argument,\n    schema: BcsType<any>,\n    transactionData: TransactionDataBuilder,\n) {\n    if (arg.$kind !== 'Input') {\n        return;\n    }\n    const input = transactionData.inputs[arg.Input];\n\n    if (input.$kind !== 'UnresolvedPure') {\n        return;\n    }\n\n    transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\n\nfunction isUsedAsMutable(transactionData: TransactionDataBuilder, index: number) {\n    let usedAsMutable = false;\n\n    transactionData.getInputUses(index, (arg, tx) => {\n        if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n            const argIndex = tx.MoveCall.arguments.indexOf(arg);\n            usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== '&' || usedAsMutable;\n        }\n\n        if (tx.$kind === 'MakeMoveVec' || tx.$kind === 'MergeCoins' || tx.$kind === 'SplitCoins') {\n            usedAsMutable = true;\n        }\n    });\n\n    return usedAsMutable;\n}\n\nfunction isUsedAsReceiving(transactionData: TransactionDataBuilder, index: number) {\n    let usedAsReceiving = false;\n\n    transactionData.getInputUses(index, (arg, tx) => {\n        if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n            const argIndex = tx.MoveCall.arguments.indexOf(arg);\n            usedAsReceiving =\n                isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n        }\n    });\n\n    return usedAsReceiving;\n}\n\nfunction isReceivingType(type: OpenMoveTypeSignature): boolean {\n    if (typeof type.body !== 'object' || !('datatype' in type.body)) {\n        return false;\n    }\n\n    return (\n        type.body.datatype.package === '0x2' &&\n        type.body.datatype.module === 'transfer' &&\n        type.body.datatype.type === 'Receiving'\n    );\n}\n\nexport function getClient(options: BuildTransactionOptions): IotaClient {\n    if (!options.client) {\n        throw new Error(\n            `No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n        );\n    }\n\n    return options.client;\n}\n\nfunction chunk<T>(arr: T[], size: number): T[][] {\n    return Array.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n        arr.slice(i * size, i * size + size),\n    );\n}\n"],
  "mappings": "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",
  "names": ["chunk", "inputs"]
}
