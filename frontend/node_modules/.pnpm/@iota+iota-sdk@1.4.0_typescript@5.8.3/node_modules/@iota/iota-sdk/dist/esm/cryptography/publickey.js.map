{
  "version": 3,
  "sources": ["../../../src/cryptography/publickey.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@iota/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeIotaAddress, IOTA_ADDRESS_LENGTH } from '../utils/iota-types.js';\nimport type { IntentScope } from './intent.js';\nimport { messageWithIntent } from './intent.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from './signature-scheme.js';\n\n/**\n * Value to be converted into public key.\n */\nexport type PublicKeyInitData = string | Uint8Array | Iterable<number>;\n\nexport function bytesEqual(a: Uint8Array, b: Uint8Array) {\n    if (a === b) return true;\n\n    if (a.length !== b.length) {\n        return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * A public key\n */\nexport abstract class PublicKey {\n    /**\n     * Checks if two public keys are equal\n     */\n    equals(publicKey: PublicKey) {\n        return bytesEqual(this.toRawBytes(), publicKey.toRawBytes());\n    }\n\n    /**\n     * Return the base-64 representation of the public key\n     */\n    toBase64() {\n        return toB64(this.toRawBytes());\n    }\n\n    toString(): never {\n        throw new Error(\n            '`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.',\n        );\n    }\n\n    /**\n     * Return the IOTA representation of the public key encoded in\n     * base-64. An IOTA public key is formed by the concatenation\n     * of the scheme flag with the raw bytes of the public key\n     */\n    toIotaPublicKey(): string {\n        const bytes = this.toIotaBytes();\n        return toB64(bytes);\n    }\n\n    verifyWithIntent(\n        bytes: Uint8Array,\n        signature: Uint8Array | string,\n        intent: IntentScope,\n    ): Promise<boolean> {\n        const intentMessage = messageWithIntent(intent, bytes);\n        const digest = blake2b(intentMessage, { dkLen: 32 });\n\n        return this.verify(digest, signature);\n    }\n\n    /**\n     * Verifies that the signature is valid for the provided PersonalMessage\n     */\n    verifyPersonalMessage(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n        return this.verifyWithIntent(\n            bcs.vector(bcs.u8()).serialize(message).toBytes(),\n            signature,\n            'PersonalMessage',\n        );\n    }\n\n    /**\n     * Verifies that the signature is valid for the provided Transaction\n     */\n    verifyTransaction(transaction: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n        return this.verifyWithIntent(transaction, signature, 'TransactionData');\n    }\n\n    /**\n     * Returns the bytes representation of the public key\n     * prefixed with the signature scheme flag\n     */\n    toIotaBytes(): Uint8Array {\n        const rawBytes = this.toRawBytes();\n        const iotaBytes = new Uint8Array(rawBytes.length + 1);\n        iotaBytes.set([this.flag()]);\n        iotaBytes.set(rawBytes, 1);\n\n        return iotaBytes;\n    }\n\n    /**\n     * Returns the bytes representation of the public key\n     * prefixed with the signature scheme flag. If the\n     * signature scheme is ED25519, no prefix is set.\n     */\n    toIotaBytesForAddress(): Uint8Array {\n        const rawBytes = this.toRawBytes();\n        if (this.flag() === SIGNATURE_SCHEME_TO_FLAG['ED25519']) {\n            return rawBytes;\n        } else {\n            const iotaBytes = new Uint8Array(rawBytes.length + 1);\n            iotaBytes.set([this.flag()]);\n            iotaBytes.set(rawBytes, 1);\n\n            return iotaBytes;\n        }\n    }\n\n    /**\n     * Return the IOTA address associated with this Ed25519 public key\n     */\n    toIotaAddress(): string {\n        // Each hex char represents half a byte, hence hex address doubles the length\n        return normalizeIotaAddress(\n            bytesToHex(blake2b(this.toIotaBytesForAddress(), { dkLen: 32 })).slice(\n                0,\n                IOTA_ADDRESS_LENGTH * 2,\n            ),\n        );\n    }\n\n    /**\n     * Return the byte array representation of the public key\n     */\n    abstract toRawBytes(): Uint8Array;\n\n    /**\n     * Return signature scheme flag of the public key\n     */\n    abstract flag(): number;\n\n    /**\n     * Verifies that the signature is valid for the provided message\n     */\n    abstract verify(data: Uint8Array, signature: Uint8Array | string): Promise<boolean>;\n}\n"],
  "mappings": "AAIA,SAAS,aAAa;AACtB,SAAS,eAAe;AACxB,SAAS,kBAAkB;AAE3B,SAAS,WAAW;AACpB,SAAS,sBAAsB,2BAA2B;AAE1D,SAAS,yBAAyB;AAClC,SAAS,gCAAgC;AAOlC,SAAS,WAAW,GAAe,GAAe;AACrD,MAAI,MAAM,EAAG,QAAO;AAEpB,MAAI,EAAE,WAAW,EAAE,QAAQ;AACvB,WAAO;AAAA,EACX;AAEA,WAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AAC/B,QAAI,EAAE,CAAC,MAAM,EAAE,CAAC,GAAG;AACf,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX;AAKO,MAAe,UAAU;AAAA;AAAA;AAAA;AAAA,EAI5B,OAAO,WAAsB;AACzB,WAAO,WAAW,KAAK,WAAW,GAAG,UAAU,WAAW,CAAC;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW;AACP,WAAO,MAAM,KAAK,WAAW,CAAC;AAAA,EAClC;AAAA,EAEA,WAAkB;AACd,UAAM,IAAI;AAAA,MACN;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,kBAA0B;AACtB,UAAM,QAAQ,KAAK,YAAY;AAC/B,WAAO,MAAM,KAAK;AAAA,EACtB;AAAA,EAEA,iBACI,OACA,WACA,QACgB;AAChB,UAAM,gBAAgB,kBAAkB,QAAQ,KAAK;AACrD,UAAM,SAAS,QAAQ,eAAe,EAAE,OAAO,GAAG,CAAC;AAEnD,WAAO,KAAK,OAAO,QAAQ,SAAS;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKA,sBAAsB,SAAqB,WAAkD;AACzF,WAAO,KAAK;AAAA,MACR,IAAI,OAAO,IAAI,GAAG,CAAC,EAAE,UAAU,OAAO,EAAE,QAAQ;AAAA,MAChD;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB,aAAyB,WAAkD;AACzF,WAAO,KAAK,iBAAiB,aAAa,WAAW,iBAAiB;AAAA,EAC1E;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cAA0B;AACtB,UAAM,WAAW,KAAK,WAAW;AACjC,UAAM,YAAY,IAAI,WAAW,SAAS,SAAS,CAAC;AACpD,cAAU,IAAI,CAAC,KAAK,KAAK,CAAC,CAAC;AAC3B,cAAU,IAAI,UAAU,CAAC;AAEzB,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,wBAAoC;AAChC,UAAM,WAAW,KAAK,WAAW;AACjC,QAAI,KAAK,KAAK,MAAM,yBAAyB,SAAS,GAAG;AACrD,aAAO;AAAA,IACX,OAAO;AACH,YAAM,YAAY,IAAI,WAAW,SAAS,SAAS,CAAC;AACpD,gBAAU,IAAI,CAAC,KAAK,KAAK,CAAC,CAAC;AAC3B,gBAAU,IAAI,UAAU,CAAC;AAEzB,aAAO;AAAA,IACX;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAwB;AAEpB,WAAO;AAAA,MACH,WAAW,QAAQ,KAAK,sBAAsB,GAAG,EAAE,OAAO,GAAG,CAAC,CAAC,EAAE;AAAA,QAC7D;AAAA,QACA,sBAAsB;AAAA,MAC1B;AAAA,IACJ;AAAA,EACJ;AAgBJ;",
  "names": []
}
