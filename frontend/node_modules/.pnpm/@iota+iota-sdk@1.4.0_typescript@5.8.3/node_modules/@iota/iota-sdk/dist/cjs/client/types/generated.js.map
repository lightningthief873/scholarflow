{
  "version": 3,
  "sources": ["../../../../src/client/types/generated.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n *  ######################################\n *  ### DO NOT EDIT THIS FILE DIRECTLY ###\n *  ######################################\n *\n * This file is generated from:\n * /crates/iota-open-rpc/spec/openrpc.json\n */\n\n/** Provides metrics about the addresses. */\nexport interface AddressMetrics {\n    /** The checkpoint sequence number at which the metrics were computed. */\n    checkpoint: string;\n    /** The count of sender addresses. */\n    cumulativeActiveAddresses: string;\n    /** The count of sender and recipient addresses. */\n    cumulativeAddresses: string;\n    /** The count of daily unique sender addresses. */\n    dailyActiveAddresses: string;\n    /** The epoch to which the checkpoint is assigned. */\n    epoch: string;\n    /** The checkpoint timestamp. */\n    timestampMs: string;\n}\nexport interface Balance {\n    coinObjectCount: number;\n    coinType: string;\n    totalBalance: string;\n}\nexport interface BalanceChange {\n    /**\n     * The amount indicate the balance value changes, negative amount means spending coin value and\n     * positive means receiving coin value.\n     */\n    amount: string;\n    coinType: string;\n    /** Owner of the balance change */\n    owner: ObjectOwner;\n}\nexport interface Checkpoint {\n    /** Commitments to checkpoint state */\n    checkpointCommitments: CheckpointCommitment[];\n    /** Checkpoint digest */\n    digest: string;\n    /** Present only on the final checkpoint of the epoch. */\n    endOfEpochData?: EndOfEpochData | null;\n    /** Checkpoint's epoch ID */\n    epoch: string;\n    /**\n     * The running total gas costs of all transactions included in the current epoch so far until this\n     * checkpoint.\n     */\n    epochRollingGasCostSummary: GasCostSummary;\n    /** Total number of transactions committed since genesis, including those in this checkpoint. */\n    networkTotalTransactions: string;\n    /** Digest of the previous checkpoint */\n    previousDigest?: string | null;\n    /** Checkpoint sequence number */\n    sequenceNumber: string;\n    /**\n     * Timestamp of the checkpoint - number of milliseconds from the Unix epoch Checkpoint timestamps are\n     * monotonic, but not strongly monotonic - subsequent checkpoints can have same timestamp if they\n     * originate from the same underlining consensus commit\n     */\n    timestampMs: string;\n    /** Transaction digests */\n    transactions: string[];\n    /** Validator Signature */\n    validatorSignature: string;\n}\nexport type CheckpointCommitment = {\n    ECMHLiveObjectSetDigest: ECMHLiveObjectSetDigest;\n};\nexport type CheckpointId = string | string;\n/** A claim consists of value and index_mod_4. */\nexport interface Claim {\n    indexMod4: number;\n    value: string;\n}\nexport interface CoinStruct {\n    balance: string;\n    coinObjectId: string;\n    coinType: string;\n    digest: string;\n    previousTransaction: string;\n    version: string;\n}\n/** RPC representation of the [Committee] type. */\nexport interface CommitteeInfo {\n    epoch: string;\n    validators: [string, string][];\n}\n/** Unlike [enum Signature], [enum CompressedSignature] does not contain public key. */\nexport type CompressedSignature =\n    | {\n          Ed25519: string;\n      }\n    | {\n          Secp256k1: string;\n      }\n    | {\n          Secp256r1: string;\n      }\n    | {\n          ZkLogin: string;\n      }\n    | {\n          Passkey: string;\n      };\n/** Uses an enum to allow for future expansion of the ConsensusDeterminedVersionAssignments. */\nexport type ConsensusDeterminedVersionAssignments = {\n    CancelledTransactions: [string, [string, string][]][];\n};\nexport type IotaParsedData =\n    | {\n          dataType: 'moveObject';\n          fields: MoveStruct;\n          type: string;\n      }\n    | {\n          dataType: 'package';\n          disassembled: {\n              [key: string]: unknown;\n          };\n      };\nexport interface DelegatedStake {\n    stakes: StakeObject[];\n    /** Staking pool object id. */\n    stakingPool: string;\n    /** Validator's Address. */\n    validatorAddress: string;\n}\nexport interface DelegatedTimelockedStake {\n    stakes: TimelockedStake[];\n    stakingPool: string;\n    validatorAddress: string;\n}\n/** Additional arguments supplied to dev inspect beyond what is allowed in today's API. */\nexport interface DevInspectArgs {\n    /** The gas budget for the transaction. */\n    gasBudget?: string | null;\n    /** The gas objects used to pay for the transaction. */\n    gasObjects?: [string, string, string][] | null;\n    /** The sponsor of the gas for the transaction, might be different from the sender. */\n    gasSponsor?: string | null;\n    /** Whether to return the raw transaction data and effects. */\n    showRawTxnDataAndEffects?: boolean | null;\n    /** Whether to skip transaction checks for the transaction. */\n    skipChecks?: boolean | null;\n}\n/** The response from processing a dev inspect transaction */\nexport interface DevInspectResults {\n    /**\n     * Summary of effects that likely would be generated if the transaction is actually run. Note however,\n     * that not all dev-inspect transactions are actually usable as transactions so it might not be\n     * possible actually generate these effects from a normal transaction.\n     */\n    effects: TransactionEffects;\n    /** Execution error from executing the transactions */\n    error?: string | null;\n    /** Events that likely would be generated if the transaction is actually run. */\n    events: IotaEvent[];\n    /** The raw effects of the transaction that was dev inspected. */\n    rawEffects?: number[];\n    /** The raw transaction data that was dev inspected. */\n    rawTxnData?: number[];\n    /** Execution results (including return values) from executing the transactions */\n    results?: IotaExecutionResult[] | null;\n}\nexport interface DisplayFieldsResponse {\n    data?: {\n        [key: string]: string;\n    } | null;\n    error?: ObjectResponseError | null;\n}\nexport interface DryRunTransactionBlockResponse {\n    balanceChanges: BalanceChange[];\n    effects: TransactionEffects;\n    events: IotaEvent[];\n    input: TransactionBlockData;\n    objectChanges: IotaObjectChange[];\n}\nexport type DynamicFieldInfo =\n    | {\n          digest: string;\n          name: DynamicFieldName;\n          objectId: string;\n          objectType: string;\n          type: DynamicFieldType;\n          version: string;\n          bcsEncoding: 'base64';\n          bcsName: string;\n      }\n    | {\n          digest: string;\n          name: DynamicFieldName;\n          objectId: string;\n          objectType: string;\n          type: DynamicFieldType;\n          version: string;\n          bcsEncoding: 'base58';\n          bcsName: string;\n      };\nexport interface DynamicFieldName {\n    type: string;\n    value: unknown;\n}\nexport type DynamicFieldType = 'DynamicField' | 'DynamicObject';\n/** The Sha256 digest of an EllipticCurveMultisetHash committing to the live object set. */\nexport interface ECMHLiveObjectSetDigest {\n    digest: number[];\n}\nexport interface EndOfEpochData {\n    /** Commitments to epoch specific state (e.g. live object set) */\n    epochCommitments: CheckpointCommitment[];\n    /** The number of tokens that were minted (if positive) or burnt (if negative) in this epoch. */\n    epochSupplyChange: number;\n    /**\n     * next_epoch_committee is `Some` if and only if the current checkpoint is the last checkpoint of an\n     * epoch. Therefore next_epoch_committee can be used to pick the last checkpoint of an epoch, which is\n     * often useful to get epoch level summary stats like total gas cost of an epoch, or the total number\n     * of transactions from genesis to the end of an epoch. The committee is stored as a vector of\n     * validator pub key and stake pairs. The vector should be sorted based on the Committee data\n     * structure.\n     */\n    nextEpochCommittee: [string, string][];\n    /**\n     * The protocol version that is in effect during the epoch that starts immediately after this\n     * checkpoint.\n     */\n    nextEpochProtocolVersion: string;\n}\nexport interface EndOfEpochInfo {\n    burntTokensAmount: string;\n    epochEndTimestamp: string;\n    lastCheckpointId: string;\n    mintedTokensAmount: string;\n    /** existing fields from `SystemEpochInfoEventV1` (without epoch) */\n    protocolVersion: string;\n    referenceGasPrice: string;\n    storageCharge: string;\n    storageFundBalance: string;\n    storageRebate: string;\n    totalGasFees: string;\n    totalStake: string;\n    totalStakeRewardsDistributed: string;\n}\nexport interface EpochInfo {\n    /** Committee validators. Each element is an index pointing to `validators`. */\n    committeeMembers?: string[];\n    /** The end of epoch information. */\n    endOfEpochInfo?: EndOfEpochInfo | null;\n    /** Epoch number */\n    epoch: string;\n    /** The timestamp when the epoch started. */\n    epochStartTimestamp: string;\n    /** Count of tx in epoch */\n    epochTotalTransactions: string;\n    /** First, last checkpoint sequence numbers */\n    firstCheckpointId: string;\n    /** The reference gas price for the given epoch. */\n    referenceGasPrice?: string | null;\n    /** List of validators included in epoch */\n    validators: IotaValidatorSummary[];\n}\n/** A light-weight version of `EpochInfo` for faster loading */\nexport interface EpochMetrics {\n    /** The end of epoch information. */\n    endOfEpochInfo?: EndOfEpochInfo | null;\n    /** The current epoch ID. */\n    epoch: string;\n    /** The timestamp when the epoch started. */\n    epochStartTimestamp: string;\n    /** The total number of transactions in the epoch. */\n    epochTotalTransactions: string;\n    /** The first checkpoint ID of the epoch. */\n    firstCheckpointId: string;\n}\nexport type IotaEvent =\n    | {\n          /**\n           * Sequential event ID, ie (transaction seq number, event seq number). 1) Serves as a unique event ID\n           * for each fullnode 2) Also serves to sequence events for the purposes of pagination and querying. A\n           * higher id is an event seen later by that fullnode. This ID is the \"cursor\" for event querying.\n           */\n          id: EventId;\n          /** Move package where this event was emitted. */\n          packageId: string;\n          /** Parsed json value of the event */\n          parsedJson: unknown;\n          /** Sender's IOTA address. */\n          sender: string;\n          /** UTC timestamp in milliseconds since epoch (1/1/1970) */\n          timestampMs?: string | null;\n          /** Move module where this event was emitted. */\n          transactionModule: string;\n          /** Move event type. */\n          type: string;\n          bcs: string;\n          bcsEncoding: 'base64';\n      }\n    | {\n          /**\n           * Sequential event ID, ie (transaction seq number, event seq number). 1) Serves as a unique event ID\n           * for each fullnode 2) Also serves to sequence events for the purposes of pagination and querying. A\n           * higher id is an event seen later by that fullnode. This ID is the \"cursor\" for event querying.\n           */\n          id: EventId;\n          /** Move package where this event was emitted. */\n          packageId: string;\n          /** Parsed json value of the event */\n          parsedJson: unknown;\n          /** Sender's IOTA address. */\n          sender: string;\n          /** UTC timestamp in milliseconds since epoch (1/1/1970) */\n          timestampMs?: string | null;\n          /** Move module where this event was emitted. */\n          transactionModule: string;\n          /** Move event type. */\n          type: string;\n          bcs: string;\n          bcsEncoding: 'base58';\n      };\nexport type IotaEventFilter =\n    /** Query by sender address. */\n    | {\n          Sender: string;\n      } /** Return events emitted by the given transaction. */\n    | {\n          Transaction: string;\n      } /** Return events emitted in a specified Package. */\n    | {\n          Package: string;\n      } /**\n     * Return events emitted in a specified Move module. If the event is defined in Module A but emitted in\n     * a tx with Module B, query `MoveModule` by module B returns the event. Query `MoveEventModule` by\n     * module A returns the event too.\n     */\n    | {\n          MoveModule: {\n              /** the module name */\n              module: string;\n              /** the Move package ID */\n              package: string;\n          };\n      } /**\n     * Return events with the given Move event struct name (struct tag). For example, if the event is\n     * defined in `0xabcd::MyModule`, and named `Foo`, then the struct tag is `0xabcd::MyModule::Foo`.\n     */\n    | {\n          MoveEventType: string;\n      } /**\n     * Return events with the given Move module name where the event struct is defined. If the event is\n     * defined in Module A but emitted in a tx with Module B, query `MoveEventModule` by module A returns\n     * the event. Query `MoveModule` by module B returns the event too.\n     */\n    | {\n          MoveEventModule: {\n              /** the module name */\n              module: string;\n              /** the Move package ID */\n              package: string;\n          };\n      }\n    | {\n          MoveEventField: {\n              path: string;\n              value: unknown;\n          };\n      } /** Return events emitted in [start_time, end_time] interval */\n    | {\n          TimeRange: {\n              /** right endpoint of time interval, milliseconds since epoch, exclusive */\n              endTime: string;\n              /** left endpoint of time interval, milliseconds since epoch, inclusive */\n              startTime: string;\n          };\n      }\n    | {\n          All: IotaEventFilter[];\n      }\n    | {\n          Any: IotaEventFilter[];\n      }\n    | {\n          And: [IotaEventFilter, IotaEventFilter];\n      }\n    | {\n          Or: [IotaEventFilter, IotaEventFilter];\n      };\n/** Unique ID of an IOTA Event, the ID is a combination of transaction digest and event seq number. */\nexport interface EventId {\n    eventSeq: string;\n    txDigest: string;\n}\nexport type ExecuteTransactionRequestType = 'WaitForEffectsCert' | 'WaitForLocalExecution';\nexport type ExecutionStatus = {\n    status: 'success' | 'failure';\n    error?: string;\n};\n/**\n * Summary of the charges in a transaction. Storage is charged independently of computation. There are\n * 3 parts to the storage charges: `storage_cost`: it is the charge of storage at the time the\n * transaction is executed. The cost of storage is the number of bytes of the objects being mutated\n * multiplied by a variable storage cost per byte `storage_rebate`: this is the amount a user gets back\n * when manipulating an object. The `storage_rebate` is the `storage_cost` for an object minus fees.\n * `non_refundable_storage_fee`: not all the value of the object storage cost is given back to user and\n * there is a small fraction that is kept by the system. This value tracks that charge.\n *\n * When looking at a gas cost summary the amount charged to the user is\n * `computation_cost + storage_cost - storage_rebate` and that is the amount that is deducted from the\n * gas coins. `non_refundable_storage_fee` is collected from the objects being mutated/deleted and it\n * is tracked by the system in storage funds.\n *\n * Objects deleted, including the older versions of objects mutated, have the storage field on the\n * objects added up to a pool of \"potential rebate\". This rebate then is reduced by the \"nonrefundable\n * rate\" such that:\n * `potential_rebate(storage cost of deleted/mutated objects) = storage_rebate + non_refundable_storage_fee`\n */\nexport interface GasCostSummary {\n    /** Cost of computation/execution */\n    computationCost: string;\n    /** The burned component of the computation/execution costs */\n    computationCostBurned: string;\n    /** The fee for the rebate. The portion of the storage rebate kept by the system. */\n    nonRefundableStorageFee: string;\n    /** Storage cost, it's the sum of all storage cost for all objects created or mutated. */\n    storageCost: string;\n    /**\n     * The amount of storage cost refunded to the user for all objects deleted or mutated in the\n     * transaction.\n     */\n    storageRebate: string;\n}\nexport interface IotaGasData {\n    budget: string;\n    owner: string;\n    payment: IotaObjectRef[];\n    price: string;\n}\nexport interface GetPastObjectRequest {\n    /** the ID of the queried object */\n    objectId: string;\n    /** the version of the queried object. */\n    version: string;\n}\nexport type InputObjectKind =\n    | {\n          MovePackage: string;\n      }\n    | {\n          ImmOrOwnedMoveObject: IotaObjectRef;\n      }\n    | {\n          SharedMoveObject: {\n              id: string;\n              initial_shared_version: string;\n              mutable?: boolean;\n          };\n      };\nexport interface IotaActiveJwk {\n    epoch: string;\n    jwk: IotaJWK;\n    jwk_id: IotaJwkId;\n}\n/** An argument to a transaction in a programmable transaction block */\nexport type IotaArgument =\n    | 'GasCoin' /** One of the input objects or primitive values (from `ProgrammableTransactionBlock` inputs) */\n    | {\n          Input: number;\n      } /** The result of another transaction (from `ProgrammableTransactionBlock` transactions) */\n    | {\n          Result: number;\n      } /**\n     * Like a `Result` but it accesses a nested result. Currently, the only usage of this is to access a\n     * value from a Move call with multiple return values.\n     */\n    | {\n          NestedResult: [number, number];\n      };\nexport interface IotaAuthenticatorStateExpire {\n    min_epoch: string;\n}\nexport type IotaCallArg =\n    | {\n          type: 'object';\n          digest: string;\n          objectId: string;\n          objectType: 'immOrOwnedObject';\n          version: string;\n      }\n    | {\n          type: 'object';\n          initialSharedVersion: string;\n          mutable: boolean;\n          objectId: string;\n          objectType: 'sharedObject';\n      }\n    | {\n          type: 'object';\n          digest: string;\n          objectId: string;\n          objectType: 'receiving';\n          version: string;\n      }\n    | {\n          type: 'pure';\n          value: unknown;\n          valueType?: string | null;\n      };\nexport interface IotaChangeEpoch {\n    computation_charge: string;\n    epoch: string;\n    epoch_start_timestamp_ms: string;\n    storage_charge: string;\n    storage_rebate: string;\n}\nexport interface IotaChangeEpochV2 {\n    computation_charge: string;\n    computation_charge_burned: string;\n    epoch: string;\n    epoch_start_timestamp_ms: string;\n    storage_charge: string;\n    storage_rebate: string;\n}\n/** Provides a summary of the circulating IOTA supply. */\nexport interface IotaCirculatingSupply {\n    /** Timestamp (UTC) when the circulating supply was calculated. */\n    atCheckpoint: string;\n    /** Percentage of total supply that is currently circulating (range: 0.0 to 1.0). */\n    circulatingSupplyPercentage: number;\n    /** Circulating supply in NANOS at the given timestamp. */\n    value: string;\n}\nexport interface CoinMetadata {\n    /** Number of decimal places the coin uses. */\n    decimals: number;\n    /** Description of the token */\n    description: string;\n    /** URL for the token logo */\n    iconUrl?: string | null;\n    /** Object id for the CoinMetadata object */\n    id?: string | null;\n    /** Name for the token */\n    name: string;\n    /** Symbol for the token */\n    symbol: string;\n}\nexport type IotaEndOfEpochTransactionKind =\n    | 'AuthenticatorStateCreate'\n    | {\n          ChangeEpoch: IotaChangeEpoch;\n      }\n    | {\n          ChangeEpochV2: IotaChangeEpochV2;\n      }\n    | {\n          AuthenticatorStateExpire: IotaAuthenticatorStateExpire;\n      };\nexport interface IotaExecutionResult {\n    /** The value of any arguments that were mutably borrowed. Non-mut borrowed values are not included */\n    mutableReferenceOutputs?: [IotaArgument, number[], string][];\n    /** The return values from the transaction */\n    returnValues?: [number[], string][];\n}\nexport interface IotaJWK {\n    alg: string;\n    e: string;\n    kty: string;\n    n: string;\n}\nexport interface IotaJwkId {\n    iss: string;\n    kid: string;\n}\nexport type IotaMoveAbility = 'Copy' | 'Drop' | 'Store' | 'Key';\nexport interface IotaMoveAbilitySet {\n    abilities: IotaMoveAbility[];\n}\nexport interface IotaMoveModuleId {\n    address: string;\n    name: string;\n}\nexport interface IotaMoveNormalizedField {\n    name: string;\n    type: IotaMoveNormalizedType;\n}\nexport interface IotaMoveNormalizedFunction {\n    isEntry: boolean;\n    parameters: IotaMoveNormalizedType[];\n    return: IotaMoveNormalizedType[];\n    typeParameters: IotaMoveAbilitySet[];\n    visibility: IotaMoveVisibility;\n}\nexport interface IotaMoveNormalizedModule {\n    address: string;\n    exposedFunctions: {\n        [key: string]: IotaMoveNormalizedFunction;\n    };\n    fileFormatVersion: number;\n    friends: IotaMoveModuleId[];\n    name: string;\n    structs: {\n        [key: string]: IotaMoveNormalizedStruct;\n    };\n}\nexport interface IotaMoveNormalizedStruct {\n    abilities: IotaMoveAbilitySet;\n    fields: IotaMoveNormalizedField[];\n    typeParameters: IotaMoveStructTypeParameter[];\n}\nexport type IotaMoveNormalizedType =\n    | 'Bool'\n    | 'U8'\n    | 'U16'\n    | 'U32'\n    | 'U64'\n    | 'U128'\n    | 'U256'\n    | 'Address'\n    | 'Signer'\n    | {\n          Struct: {\n              address: string;\n              module: string;\n              name: string;\n              typeArguments: IotaMoveNormalizedType[];\n          };\n      }\n    | {\n          Vector: IotaMoveNormalizedType;\n      }\n    | {\n          TypeParameter: number;\n      }\n    | {\n          Reference: IotaMoveNormalizedType;\n      }\n    | {\n          MutableReference: IotaMoveNormalizedType;\n      };\nexport interface IotaMoveStructTypeParameter {\n    constraints: IotaMoveAbilitySet;\n    isPhantom: boolean;\n}\nexport type IotaMoveVisibility = 'Private' | 'Public' | 'Friend';\n/** A single record in the registry. */\nexport interface IotaNameRecord {\n    /** Additional data which may be stored in a record */\n    data: /** Additional data which may be stored in a record */\n    {\n        [key: string]: string;\n    };\n    /** Timestamp in milliseconds when the record expires. */\n    expirationTimestampMs: string;\n    /**\n     * The ID of the registration NFT assigned to this record.\n     *\n     * The owner of the corresponding NFT has the rights to be able to change and adjust the\n     * `target_address` of this name.\n     *\n     * It is possible that the ID changes if the record expires and is purchased by someone else.\n     */\n    nftId: string;\n    /** The target address that this name points to */\n    targetAddress?: string | null;\n}\nexport type IotaObjectDataFilter =\n    | {\n          MatchAll: IotaObjectDataFilter[];\n      }\n    | {\n          MatchAny: IotaObjectDataFilter[];\n      }\n    | {\n          MatchNone: IotaObjectDataFilter[];\n      } /** Query by type a specified Package. */\n    | {\n          Package: string;\n      } /** Query by type a specified Move module. */\n    | {\n          MoveModule: {\n              /** the module name */\n              module: string;\n              /** the Move package ID */\n              package: string;\n          };\n      } /** Query by type */\n    | {\n          StructType: string;\n      }\n    | {\n          AddressOwner: string;\n      }\n    | {\n          ObjectOwner: string;\n      }\n    | {\n          ObjectId: string;\n      }\n    | {\n          ObjectIds: string[];\n      }\n    | {\n          Version: string;\n      };\nexport interface IotaObjectResponse {\n    data?: IotaObjectData | null;\n    error?: ObjectResponseError | null;\n}\n/**\n * The transaction for calling a Move function, either an entry function or a public function (which\n * cannot return references).\n */\nexport interface MoveCallIotaTransaction {\n    /** The arguments to the function. */\n    arguments?: IotaArgument[];\n    /** The function to be called. */\n    function: string;\n    /** The specific module in the package containing the function. */\n    module: string;\n    /** The package containing the module and function. */\n    package: string;\n    /** The type arguments to the function. */\n    type_arguments?: string[];\n}\n/**\n * This is the JSON-RPC type for IOTA system state objects. It is an enum type that can represent\n * either V1 or V2 system state objects.\n */\nexport type IotaSystemStateSummary =\n    | {\n          V1: IotaSystemStateSummaryV1;\n      }\n    | {\n          V2: IotaSystemStateSummaryV2;\n      };\n/**\n * This is the JSON-RPC type for the\n * [`IotaSystemStateV1`](super::iota_system_state_inner_v1::IotaSystemStateV1) object. It flattens all\n * fields to make them top-level fields such that it as minimum dependencies to the internal data\n * structures of the IOTA system state type.\n */\nexport interface IotaSystemStateSummaryV1 {\n    /** The list of active validators in the current epoch. */\n    activeValidators: IotaValidatorSummary[];\n    /** Map storing the number of epochs for which each validator has been below the low stake threshold. */\n    atRiskValidators: [string, string][];\n    /** The current epoch ID, starting from 0. */\n    epoch: string;\n    /** The duration of an epoch, in milliseconds. */\n    epochDurationMs: string;\n    /** Unix timestamp of the current epoch start */\n    epochStartTimestampMs: string;\n    /**\n     * ID of the object that maps from a staking pool ID to the inactive validator that has that pool as\n     * its staking pool.\n     */\n    inactivePoolsId: string;\n    /** Number of inactive staking pools. */\n    inactivePoolsSize: string;\n    /** The current IOTA supply. */\n    iotaTotalSupply: string;\n    /** The `TreasuryCap<IOTA>` object ID. */\n    iotaTreasuryCapId: string;\n    /**\n     * Maximum number of active validators at any moment. We do not allow the number of validators in any\n     * epoch to go above this.\n     */\n    maxValidatorCount: string;\n    /**\n     * Minimum number of active validators at any moment. We do not allow the number of validators in any\n     * epoch to go under this.\n     */\n    minValidatorCount: string;\n    /** Lower-bound on the amount of stake required to become a validator. */\n    minValidatorJoiningStake: string;\n    /** ID of the object that contains the list of new validators that will join at the end of the epoch. */\n    pendingActiveValidatorsId: string;\n    /** Number of new validators that will join at the end of the epoch. */\n    pendingActiveValidatorsSize: string;\n    /** Removal requests from the validators. Each element is an index pointing to `active_validators`. */\n    pendingRemovals: string[];\n    /** The current protocol version, starting from 1. */\n    protocolVersion: string;\n    /** The reference gas price for the current epoch. */\n    referenceGasPrice: string;\n    /**\n     * Whether the system is running in a downgraded safe mode due to a non-recoverable bug. This is set\n     * whenever we failed to execute advance_epoch, and ended up executing advance_epoch_safe_mode. It can\n     * be reset once we are able to successfully execute advance_epoch.\n     */\n    safeMode: boolean;\n    /** Amount of computation rewards accumulated (and not yet distributed) during safe mode. */\n    safeModeComputationRewards: string;\n    /** Amount of non-refundable storage fee accumulated during safe mode. */\n    safeModeNonRefundableStorageFee: string;\n    /** Amount of storage charges accumulated (and not yet distributed) during safe mode. */\n    safeModeStorageCharges: string;\n    /** Amount of storage rebates accumulated (and not yet burned) during safe mode. */\n    safeModeStorageRebates: string;\n    /** ID of the object that maps from staking pool's ID to the iota address of a validator. */\n    stakingPoolMappingsId: string;\n    /** Number of staking pool mappings. */\n    stakingPoolMappingsSize: string;\n    /**\n     * The non-refundable portion of the storage fund coming from non-refundable storage rebates and any\n     * leftover staking rewards.\n     */\n    storageFundNonRefundableBalance: string;\n    /** The storage rebates of all the objects on-chain stored in the storage fund. */\n    storageFundTotalObjectStorageRebates: string;\n    /** The current version of the system state data structure type. */\n    systemStateVersion: string;\n    /** Total amount of stake from all active validators at the beginning of the epoch. */\n    totalStake: string;\n    /**\n     * ID of the object that stores preactive validators, mapping their addresses to their `Validator`\n     * structs.\n     */\n    validatorCandidatesId: string;\n    /** Number of preactive validators. */\n    validatorCandidatesSize: string;\n    /**\n     * A validator can have stake below `validator_low_stake_threshold` for this many epochs before being\n     * kicked out.\n     */\n    validatorLowStakeGracePeriod: string;\n    /**\n     * Validators with stake amount below `validator_low_stake_threshold` are considered to have low stake\n     * and will be escorted out of the validator set after being below this threshold for more than\n     * `validator_low_stake_grace_period` number of epochs.\n     */\n    validatorLowStakeThreshold: string;\n    /** A map storing the records of validator reporting each other. */\n    validatorReportRecords: [string, string[]][];\n    /**\n     * Validators with stake below `validator_very_low_stake_threshold` will be removed immediately at\n     * epoch change, no grace period.\n     */\n    validatorVeryLowStakeThreshold: string;\n}\n/**\n * This is the JSON-RPC type for the\n * [`IotaSystemStateV2`](super::iota_system_state_inner_v2::IotaSystemStateV2) object. It flattens all\n * fields to make them top-level fields such that it as minimum dependencies to the internal data\n * structures of the IOTA system state type.\n */\nexport interface IotaSystemStateSummaryV2 {\n    /** The list of active validators in the current epoch. */\n    activeValidators: IotaValidatorSummary[];\n    /** Map storing the number of epochs for which each validator has been below the low stake threshold. */\n    atRiskValidators: [string, string][];\n    /**\n     * List of committee validators in the current epoch. Each element is an index pointing to\n     * `active_validators`.\n     */\n    committeeMembers: string[];\n    /** The current epoch ID, starting from 0. */\n    epoch: string;\n    /** The duration of an epoch, in milliseconds. */\n    epochDurationMs: string;\n    /** Unix timestamp of the current epoch start */\n    epochStartTimestampMs: string;\n    /**\n     * ID of the object that maps from a staking pool ID to the inactive validator that has that pool as\n     * its staking pool.\n     */\n    inactivePoolsId: string;\n    /** Number of inactive staking pools. */\n    inactivePoolsSize: string;\n    /** The current IOTA supply. */\n    iotaTotalSupply: string;\n    /** The `TreasuryCap<IOTA>` object ID. */\n    iotaTreasuryCapId: string;\n    /**\n     * Maximum number of active validators at any moment. We do not allow the number of validators in any\n     * epoch to go above this.\n     */\n    maxValidatorCount: string;\n    /**\n     * Minimum number of active validators at any moment. We do not allow the number of validators in any\n     * epoch to go under this.\n     */\n    minValidatorCount: string;\n    /** Lower-bound on the amount of stake required to become a validator. */\n    minValidatorJoiningStake: string;\n    /** ID of the object that contains the list of new validators that will join at the end of the epoch. */\n    pendingActiveValidatorsId: string;\n    /** Number of new validators that will join at the end of the epoch. */\n    pendingActiveValidatorsSize: string;\n    /** Removal requests from the validators. Each element is an index pointing to `active_validators`. */\n    pendingRemovals: string[];\n    /** The current protocol version, starting from 1. */\n    protocolVersion: string;\n    /** The reference gas price for the current epoch. */\n    referenceGasPrice: string;\n    /**\n     * Whether the system is running in a downgraded safe mode due to a non-recoverable bug. This is set\n     * whenever we failed to execute advance_epoch, and ended up executing advance_epoch_safe_mode. It can\n     * be reset once we are able to successfully execute advance_epoch.\n     */\n    safeMode: boolean;\n    /** Amount of computation charges accumulated (and not yet distributed) during safe mode. */\n    safeModeComputationCharges: string;\n    /** Amount of burned computation charges accumulated during safe mode. */\n    safeModeComputationChargesBurned: string;\n    /** Amount of non-refundable storage fee accumulated during safe mode. */\n    safeModeNonRefundableStorageFee: string;\n    /** Amount of storage charges accumulated (and not yet distributed) during safe mode. */\n    safeModeStorageCharges: string;\n    /** Amount of storage rebates accumulated (and not yet burned) during safe mode. */\n    safeModeStorageRebates: string;\n    /** ID of the object that maps from staking pool's ID to the iota address of a validator. */\n    stakingPoolMappingsId: string;\n    /** Number of staking pool mappings. */\n    stakingPoolMappingsSize: string;\n    /**\n     * The non-refundable portion of the storage fund coming from non-refundable storage rebates and any\n     * leftover staking rewards.\n     */\n    storageFundNonRefundableBalance: string;\n    /** The storage rebates of all the objects on-chain stored in the storage fund. */\n    storageFundTotalObjectStorageRebates: string;\n    /** The current version of the system state data structure type. */\n    systemStateVersion: string;\n    /** Total amount of stake from all committee validators at the beginning of the epoch. */\n    totalStake: string;\n    /**\n     * ID of the object that stores preactive validators, mapping their addresses to their `Validator`\n     * structs.\n     */\n    validatorCandidatesId: string;\n    /** Number of preactive validators. */\n    validatorCandidatesSize: string;\n    /**\n     * A validator can have stake below `validator_low_stake_threshold` for this many epochs before being\n     * kicked out.\n     */\n    validatorLowStakeGracePeriod: string;\n    /**\n     * Validators with stake amount below `validator_low_stake_threshold` are considered to have low stake\n     * and will be escorted out of the validator set after being below this threshold for more than\n     * `validator_low_stake_grace_period` number of epochs.\n     */\n    validatorLowStakeThreshold: string;\n    /** A map storing the records of validator reporting each other. */\n    validatorReportRecords: [string, string[]][];\n    /**\n     * Validators with stake below `validator_very_low_stake_threshold` will be removed immediately at\n     * epoch change, no grace period.\n     */\n    validatorVeryLowStakeThreshold: string;\n}\n/** A single transaction in a programmable transaction block. */\nexport type IotaTransaction =\n    /** A call to either an entry or a public Move function */\n    | {\n          MoveCall: MoveCallIotaTransaction;\n      } /**\n     * `(Vec<forall T:key+store. T>, address)` It sends n-objects to the specified address. These objects\n     * must have store (public transfer) and either the previous owner must be an address or the object\n     * must be newly created.\n     */\n    | {\n          TransferObjects: [IotaArgument[], IotaArgument];\n      } /**\n     * `(&mut Coin<T>, Vec<u64>)` -> `Vec<Coin<T>>` It splits off some amounts into a new coins with those\n     * amounts\n     */\n    | {\n          SplitCoins: [IotaArgument, IotaArgument[]];\n      } /** `(&mut Coin<T>, Vec<Coin<T>>)` It merges n-coins into the first coin */\n    | {\n          MergeCoins: [IotaArgument, IotaArgument[]];\n      } /**\n     * Publishes a Move package. It takes the package bytes and a list of the package's transitive\n     * dependencies to link against on-chain.\n     */\n    | {\n          Publish: string[];\n      } /** Upgrades a Move package */\n    | {\n          Upgrade: [string[], string, IotaArgument];\n      } /**\n     * `forall T: Vec<T> -> vector<T>` Given n-values of the same type, it constructs a vector. For non\n     * objects or an empty vector, the type tag must be specified.\n     */\n    | {\n          MakeMoveVec: [string | null, IotaArgument[]];\n      };\nexport type IotaTransactionBlockBuilderMode = 'Commit' | 'DevInspect';\n/**\n * Represents the type of a transaction. All transactions except `ProgrammableTransaction` are\n * considered system transactions.\n */\nexport type IotaTransactionKind =\n    | 'ProgrammableTransaction'\n    | 'Genesis'\n    | 'ConsensusCommitPrologueV1'\n    | 'AuthenticatorStateUpdateV1'\n    | 'RandomnessStateUpdate'\n    | 'EndOfEpochTransaction'\n    | 'SystemTransaction';\n/**\n * This is the JSON-RPC type for the IOTA validator. It flattens all inner structures to top-level\n * fields so that they are decoupled from the internal definitions.\n */\nexport interface IotaValidatorSummary {\n    authorityPubkeyBytes: string;\n    commissionRate: string;\n    description: string;\n    /** ID of the exchange rate table object. */\n    exchangeRatesId: string;\n    /** Number of exchange rates in the table. */\n    exchangeRatesSize: string;\n    gasPrice: string;\n    imageUrl: string;\n    iotaAddress: string;\n    name: string;\n    netAddress: string;\n    networkPubkeyBytes: string;\n    nextEpochAuthorityPubkeyBytes?: string | null;\n    nextEpochCommissionRate: string;\n    nextEpochGasPrice: string;\n    nextEpochNetAddress?: string | null;\n    nextEpochNetworkPubkeyBytes?: string | null;\n    nextEpochP2pAddress?: string | null;\n    nextEpochPrimaryAddress?: string | null;\n    nextEpochProofOfPossession?: string | null;\n    nextEpochProtocolPubkeyBytes?: string | null;\n    nextEpochStake: string;\n    operationCapId: string;\n    p2pAddress: string;\n    /** Pending pool token withdrawn during the current epoch, emptied at epoch boundaries. */\n    pendingPoolTokenWithdraw: string;\n    /** Pending stake amount for this epoch. */\n    pendingStake: string;\n    /** Pending stake withdrawn during the current epoch, emptied at epoch boundaries. */\n    pendingTotalIotaWithdraw: string;\n    /** Total number of pool tokens issued by the pool. */\n    poolTokenBalance: string;\n    primaryAddress: string;\n    projectUrl: string;\n    proofOfPossessionBytes: string;\n    protocolPubkeyBytes: string;\n    /** The epoch stake rewards will be added here at the end of each epoch. */\n    rewardsPool: string;\n    /** The epoch at which this pool became active. */\n    stakingPoolActivationEpoch?: string | null;\n    /** The epoch at which this staking pool ceased to be active. `None` = {pre-active, active}, */\n    stakingPoolDeactivationEpoch?: string | null;\n    /** ID of the staking pool object. */\n    stakingPoolId: string;\n    /** The total number of IOTA tokens in this pool. */\n    stakingPoolIotaBalance: string;\n    votingPower: string;\n}\nexport interface MoveCallMetrics {\n    /** The count of calls of each function in the last 30 days. */\n    rank30Days: [MoveFunctionName, string][];\n    /** The count of calls of each function in the last 3 days. */\n    rank3Days: [MoveFunctionName, string][];\n    /** The count of calls of each function in the last 7 days. */\n    rank7Days: [MoveFunctionName, string][];\n}\nexport interface MoveCallParams {\n    arguments: unknown[];\n    function: string;\n    module: string;\n    packageObjectId: string;\n    typeArguments?: string[];\n}\nexport type IotaMoveFunctionArgType =\n    | 'Pure'\n    | {\n          Object: ObjectValueKind;\n      };\n/** Identifies a Move function. */\nexport interface MoveFunctionName {\n    /** The function name. */\n    function: string;\n    /** The module name to which the function belongs. */\n    module: string;\n    /** The package ID to which the function belongs. */\n    package: string;\n}\nexport type MoveStruct =\n    | MoveValue[]\n    | {\n          fields: {\n              [key: string]: MoveValue;\n          };\n          type: string;\n      }\n    | {\n          [key: string]: MoveValue;\n      };\nexport type MoveValue =\n    | number\n    | boolean\n    | string\n    | MoveValue[]\n    | string\n    | {\n          id: string;\n      }\n    | MoveStruct\n    | null\n    | MoveVariant;\nexport interface MoveVariant {\n    fields: {\n        [key: string]: MoveValue;\n    };\n    type: string;\n    variant: string;\n}\n/** The struct that contains signatures and public keys necessary for authenticating a MultiSig. */\nexport interface MultiSig {\n    /** A bitmap that indicates the position of which public key the signature should be authenticated with. */\n    bitmap: number;\n    /**\n     * The public key encoded with each public key with its signature scheme used along with the\n     * corresponding weight.\n     */\n    multisig_pk: MultiSigPublicKey;\n    /** The plain signature encoded with signature scheme. */\n    sigs: CompressedSignature[];\n}\n/** The struct that contains the public key used for authenticating a MultiSig. */\nexport interface MultiSigPublicKey {\n    /** A list of public key and its corresponding weight. */\n    pk_map: [PublicKey, number][];\n    /**\n     * If the total weight of the public keys corresponding to verified signatures is larger than\n     * threshold, the MultiSig is verified.\n     */\n    threshold: number;\n}\nexport interface NetworkMetrics {\n    /** Current checkpoint number */\n    currentCheckpoint: string;\n    /** Current epoch number */\n    currentEpoch: string;\n    /** Current TPS - Transaction Blocks per Second. */\n    currentTps: number;\n    /** Total number of addresses seen in the network */\n    totalAddresses: string;\n    /** Total number of live objects in the network */\n    totalObjects: string;\n    /** Total number of packages published in the network */\n    totalPackages: string;\n    /** Peak TPS in the past 30 days */\n    tps30Days: number;\n}\n/**\n * ObjectChange are derived from the object mutations in the TransactionEffect to provide richer object\n * information.\n */\nexport type IotaObjectChange =\n    /** Module published */\n    | {\n          digest: string;\n          modules: string[];\n          packageId: string;\n          type: 'published';\n          version: string;\n      } /** Transfer objects to new address / wrap in another object */\n    | {\n          digest: string;\n          objectId: string;\n          objectType: string;\n          recipient: ObjectOwner;\n          sender: string;\n          type: 'transferred';\n          version: string;\n      } /** Object mutated. */\n    | {\n          digest: string;\n          objectId: string;\n          objectType: string;\n          owner: ObjectOwner;\n          previousVersion: string;\n          sender: string;\n          type: 'mutated';\n          version: string;\n      } /** Delete object */\n    | {\n          objectId: string;\n          objectType: string;\n          sender: string;\n          type: 'deleted';\n          version: string;\n      } /** Wrapped object */\n    | {\n          objectId: string;\n          objectType: string;\n          sender: string;\n          type: 'wrapped';\n          version: string;\n      } /** New object creation */\n    | {\n          digest: string;\n          objectId: string;\n          objectType: string;\n          owner: ObjectOwner;\n          sender: string;\n          type: 'created';\n          version: string;\n      };\nexport interface IotaObjectData {\n    /**\n     * Move object content or package content in BCS, default to be None unless\n     * IotaObjectDataOptions.showBcs is set to true\n     */\n    bcs?: RawData | null;\n    /**\n     * Move object content or package content, default to be None unless IotaObjectDataOptions.showContent\n     * is set to true\n     */\n    content?: IotaParsedData | null;\n    /** Base64 string representing the object digest */\n    digest: string;\n    /**\n     * The Display metadata for frontend UI rendering, default to be None unless\n     * IotaObjectDataOptions.showContent is set to true This can also be None if the struct type does not\n     * have Display defined\n     */\n    display?: DisplayFieldsResponse | null;\n    objectId: string;\n    /** The owner of this object. Default to be None unless IotaObjectDataOptions.showOwner is set to true */\n    owner?: ObjectOwner | null;\n    /**\n     * The digest of the transaction that created or last mutated this object. Default to be None unless\n     * IotaObjectDataOptions. showPreviousTransaction is set to true\n     */\n    previousTransaction?: string | null;\n    /**\n     * The amount of IOTA we would rebate if this object gets deleted. This number is re-calculated each\n     * time the object is mutated based on the present storage gas price.\n     */\n    storageRebate?: string | null;\n    /** The type of the object. Default to be None unless IotaObjectDataOptions.showType is set to true */\n    type?: string | null;\n    /** Object version. */\n    version: string;\n}\nexport interface IotaObjectDataOptions {\n    /** Whether to show the content in BCS format. Default to be False */\n    showBcs?: boolean;\n    /**\n     * Whether to show the content(i.e., package content or Move struct content) of the object. Default to\n     * be False\n     */\n    showContent?: boolean;\n    /** Whether to show the Display metadata of the object for frontend rendering. Default to be False */\n    showDisplay?: boolean;\n    /** Whether to show the owner of the object. Default to be False */\n    showOwner?: boolean;\n    /** Whether to show the previous transaction digest of the object. Default to be False */\n    showPreviousTransaction?: boolean;\n    /** Whether to show the storage rebate of the object. Default to be False */\n    showStorageRebate?: boolean;\n    /** Whether to show the type of the object. Default to be False */\n    showType?: boolean;\n}\nexport type ObjectRead =\n    /** The object exists and is found with this version */\n    | {\n          details: IotaObjectData;\n          status: 'VersionFound';\n      } /** The object does not exist */\n    | {\n          details: string;\n          status: 'ObjectNotExists';\n      } /** The object is found to be deleted with this version */\n    | {\n          details: IotaObjectRef;\n          status: 'ObjectDeleted';\n      } /** The object exists but not found with this version */\n    | {\n          details: [string, string];\n          status: 'VersionNotFound';\n      } /** The asked object version is higher than the latest */\n    | {\n          details: {\n              asked_version: string;\n              latest_version: string;\n              object_id: string;\n          };\n          status: 'VersionTooHigh';\n      };\nexport interface IotaObjectRef {\n    /** Base64 string representing the object digest */\n    digest: string;\n    /** Hex code as string representing the object id */\n    objectId: string;\n    /** Object version. */\n    version: string;\n}\nexport type ObjectResponseError =\n    | {\n          code: 'notExists';\n          object_id: string;\n      }\n    | {\n          code: 'dynamicFieldNotFound';\n          parent_object_id: string;\n      }\n    | {\n          code: 'deleted';\n          /** Base64 string representing the object digest */\n          digest: string;\n          object_id: string;\n          /** Object version. */\n          version: string;\n      }\n    | {\n          code: 'unknown';\n      }\n    | {\n          code: 'display';\n          error: string;\n      };\nexport interface IotaObjectResponseQuery {\n    /** If None, no filter will be applied */\n    filter?: IotaObjectDataFilter | null;\n    /** config which fields to include in the response, by default only digest is included */\n    options?: IotaObjectDataOptions | null;\n}\nexport type ObjectValueKind = 'ByImmutableReference' | 'ByMutableReference' | 'ByValue';\nexport interface OwnedObjectRef {\n    owner: ObjectOwner;\n    reference: IotaObjectRef;\n}\nexport type ObjectOwner =\n    /** Object is exclusively owned by a single address, and is mutable. */\n    | {\n          AddressOwner: string;\n      } /**\n     * Object is exclusively owned by a single object, and is mutable. The object ID is converted to\n     * IotaAddress as IotaAddress is universal.\n     */\n    | {\n          ObjectOwner: string;\n      } /** Object is shared, can be used by any address, and is mutable. */\n    | {\n          Shared: {\n              /** The version at which the object became shared */\n              initial_shared_version: string;\n          };\n      }\n    | 'Immutable';\n/**\n * `next_cursor` points to the last item in the page; Reading with `next_cursor` will start from the\n * next item after `next_cursor` if `next_cursor` is `Some`, otherwise it will start from the first\n * item.\n */\nexport interface PaginatedCheckpoints {\n    data: Checkpoint[];\n    hasNextPage: boolean;\n    nextCursor?: string | null;\n}\n/**\n * `next_cursor` points to the last item in the page; Reading with `next_cursor` will start from the\n * next item after `next_cursor` if `next_cursor` is `Some`, otherwise it will start from the first\n * item.\n */\nexport interface PaginatedCoins {\n    data: CoinStruct[];\n    hasNextPage: boolean;\n    nextCursor?: string | null;\n}\n/**\n * `next_cursor` points to the last item in the page; Reading with `next_cursor` will start from the\n * next item after `next_cursor` if `next_cursor` is `Some`, otherwise it will start from the first\n * item.\n */\nexport interface PaginatedDynamicFieldInfos {\n    data: DynamicFieldInfo[];\n    hasNextPage: boolean;\n    nextCursor?: string | null;\n}\n/**\n * `next_cursor` points to the last item in the page; Reading with `next_cursor` will start from the\n * next item after `next_cursor` if `next_cursor` is `Some`, otherwise it will start from the first\n * item.\n */\nexport interface PaginatedEpochInfos {\n    data: EpochInfo[];\n    hasNextPage: boolean;\n    nextCursor?: string | null;\n}\n/**\n * `next_cursor` points to the last item in the page; Reading with `next_cursor` will start from the\n * next item after `next_cursor` if `next_cursor` is `Some`, otherwise it will start from the first\n * item.\n */\nexport interface PaginatedEpochMetricss {\n    data: EpochMetrics[];\n    hasNextPage: boolean;\n    nextCursor?: string | null;\n}\n/**\n * `next_cursor` points to the last item in the page; Reading with `next_cursor` will start from the\n * next item after `next_cursor` if `next_cursor` is `Some`, otherwise it will start from the first\n * item.\n */\nexport interface PaginatedEvents {\n    data: IotaEvent[];\n    hasNextPage: boolean;\n    nextCursor?: EventId | null;\n}\n/**\n * `next_cursor` points to the last item in the page; Reading with `next_cursor` will start from the\n * next item after `next_cursor` if `next_cursor` is `Some`, otherwise it will start from the first\n * item.\n */\nexport interface PaginatedObjectsResponse {\n    data: IotaObjectResponse[];\n    hasNextPage: boolean;\n    nextCursor?: string | null;\n}\n/**\n * `next_cursor` points to the last item in the page; Reading with `next_cursor` will start from the\n * next item after `next_cursor` if `next_cursor` is `Some`, otherwise it will start from the first\n * item.\n */\nexport interface PaginatedTransactionResponse {\n    data: IotaTransactionBlockResponse[];\n    hasNextPage: boolean;\n    nextCursor?: string | null;\n}\n/** Provides metrics about the participation in the network. */\nexport interface ParticipationMetrics {\n    /** The count of distinct addresses with delegated stake. */\n    totalAddresses: string;\n}\n/**\n * An passkey authenticator with parsed fields. See field definition below. Can be initialized from\n * [struct RawPasskeyAuthenticator].\n */\nexport interface PasskeyAuthenticator {\n    /**\n     * `authenticatorData` is a bytearray that encodes\n     * [Authenticator Data](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) structure returned\n     * by the authenticator attestation response as is.\n     */\n    authenticator_data: number[];\n    /**\n     * `clientDataJSON` contains a JSON-compatible UTF-8 encoded string of the client data which is passed\n     * to the authenticator by the client during the authentication request (see\n     * [CollectedClientData](https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata))\n     */\n    client_data_json: string;\n}\nexport interface ProtocolConfig {\n    attributes: {\n        [key: string]: ProtocolConfigValue | null;\n    };\n    featureFlags: {\n        [key: string]: boolean;\n    };\n    maxSupportedProtocolVersion: string;\n    minSupportedProtocolVersion: string;\n    protocolVersion: string;\n}\nexport type ProtocolConfigValue =\n    | {\n          u16: string;\n      }\n    | {\n          u32: string;\n      }\n    | {\n          u64: string;\n      }\n    | {\n          f64: string;\n      }\n    | {\n          bool: string;\n      };\nexport type PublicKey =\n    | {\n          Ed25519: string;\n      }\n    | {\n          Secp256k1: string;\n      }\n    | {\n          Secp256r1: string;\n      }\n    | {\n          ZkLogin: string;\n      }\n    | {\n          Passkey: string;\n      };\nexport type RPCTransactionRequestParams =\n    | {\n          transferObjectRequestParams: TransferObjectParams;\n      }\n    | {\n          moveCallRequestParams: MoveCallParams;\n      };\nexport type RawData =\n    | {\n          bcsBytes: string;\n          dataType: 'moveObject';\n          type: string;\n          version: string;\n      }\n    | {\n          dataType: 'package';\n          id: string;\n          linkageTable: {\n              [key: string]: UpgradeInfo;\n          };\n          moduleMap: {\n              [key: string]: string;\n          };\n          typeOriginTable: TypeOrigin[];\n          version: string;\n      };\nexport type Signature =\n    | {\n          Ed25519IotaSignature: string;\n      }\n    | {\n          Secp256k1IotaSignature: string;\n      }\n    | {\n          Secp256r1IotaSignature: string;\n      };\nexport type StakeObject =\n    | {\n          principal: string;\n          stakeActiveEpoch: string;\n          stakeRequestEpoch: string;\n          /** ID of the StakedIota receipt object. */\n          stakedIotaId: string;\n          status: 'Pending';\n      }\n    | {\n          principal: string;\n          stakeActiveEpoch: string;\n          stakeRequestEpoch: string;\n          /** ID of the StakedIota receipt object. */\n          stakedIotaId: string;\n          estimatedReward: string;\n          status: 'Active';\n      }\n    | {\n          principal: string;\n          stakeActiveEpoch: string;\n          stakeRequestEpoch: string;\n          /** ID of the StakedIota receipt object. */\n          stakedIotaId: string;\n          status: 'Unstaked';\n      };\nexport interface CoinSupply {\n    value: string;\n}\nexport type TimelockedStake =\n    | {\n          expirationTimestampMs: string;\n          label?: string | null;\n          principal: string;\n          stakeActiveEpoch: string;\n          stakeRequestEpoch: string;\n          timelockedStakedIotaId: string;\n          status: 'Pending';\n      }\n    | {\n          expirationTimestampMs: string;\n          label?: string | null;\n          principal: string;\n          stakeActiveEpoch: string;\n          stakeRequestEpoch: string;\n          timelockedStakedIotaId: string;\n          estimatedReward: string;\n          status: 'Active';\n      }\n    | {\n          expirationTimestampMs: string;\n          label?: string | null;\n          principal: string;\n          stakeActiveEpoch: string;\n          stakeRequestEpoch: string;\n          timelockedStakedIotaId: string;\n          status: 'Unstaked';\n      };\nexport interface IotaTransactionBlock {\n    data: TransactionBlockData;\n    txSignatures: string[];\n}\nexport interface TransactionBlockBytes {\n    /** the gas objects to be used */\n    gas: IotaObjectRef[];\n    /** objects to be used in this transaction */\n    inputObjects: InputObjectKind[];\n    /** BCS serialized transaction data bytes without its type tag, as base-64 encoded string. */\n    txBytes: string;\n}\nexport type TransactionBlockData = {\n    gasData: IotaGasData;\n    messageVersion: 'v1';\n    sender: string;\n    transaction: IotaTransactionBlockKind;\n};\nexport type TransactionEffects =\n    /** The response from processing a transaction or a certified transaction */\n    {\n        /** ObjectRef and owner of new objects created. */\n        created?: OwnedObjectRef[];\n        /** Object Refs of objects now deleted (the old refs). */\n        deleted?: IotaObjectRef[];\n        /** The set of transaction digests this transaction depends on. */\n        dependencies?: string[];\n        /**\n         * The digest of the events emitted during execution, can be None if the transaction does not emit any\n         * event.\n         */\n        eventsDigest?: string | null;\n        /** The epoch when this transaction was executed. */\n        executedEpoch: string;\n        /**\n         * The updated gas object reference. Have a dedicated field for convenient access. It's also included\n         * in mutated.\n         */\n        gasObject: OwnedObjectRef;\n        gasUsed: GasCostSummary;\n        messageVersion: 'v1';\n        /**\n         * The version that every modified (mutated or deleted) object had before it was modified by this\n         * transaction.\n         */\n        modifiedAtVersions?: TransactionBlockEffectsModifiedAtVersions[];\n        /** ObjectRef and owner of mutated objects, including gas object. */\n        mutated?: OwnedObjectRef[];\n        /**\n         * The object references of the shared objects used in this transaction. Empty if no shared objects\n         * were used.\n         */\n        sharedObjects?: IotaObjectRef[];\n        /** The status of the execution */\n        status: ExecutionStatus;\n        /** The transaction digest */\n        transactionDigest: string;\n        /**\n         * ObjectRef and owner of objects that are unwrapped in this transaction. Unwrapped objects are objects\n         * that were wrapped into other objects in the past, and just got extracted out.\n         */\n        unwrapped?: OwnedObjectRef[];\n        /** Object refs of objects previously wrapped in other objects but now deleted. */\n        unwrappedThenDeleted?: IotaObjectRef[];\n        /** Object refs of objects now wrapped in other objects. */\n        wrapped?: IotaObjectRef[];\n    };\nexport interface TransactionBlockEffectsModifiedAtVersions {\n    objectId: string;\n    sequenceNumber: string;\n}\nexport type IotaTransactionBlockKind =\n    /** A system transaction used for initializing the initial state of the chain. */\n    | {\n          events: EventId[];\n          kind: 'Genesis';\n          objects: string[];\n      } /** A system transaction marking the start of a series of transactions scheduled as part of a checkpoint */\n    | {\n          commit_timestamp_ms: string;\n          consensus_commit_digest: string;\n          consensus_determined_version_assignments: ConsensusDeterminedVersionAssignments;\n          epoch: string;\n          kind: 'ConsensusCommitPrologueV1';\n          round: string;\n          sub_dag_index?: string | null;\n      } /** A series of transactions where the results of one transaction can be used in future transactions */\n    | {\n          /** Input objects or primitive values */\n          inputs: IotaCallArg[];\n          kind: 'ProgrammableTransaction';\n          /**\n           * The transactions to be executed sequentially. A failure in any transaction will result in the\n           * failure of the entire programmable transaction block.\n           */\n          transactions: IotaTransaction[];\n      } /** A transaction which updates global authenticator state */\n    | {\n          epoch: string;\n          kind: 'AuthenticatorStateUpdateV1';\n          new_active_jwks: IotaActiveJwk[];\n          round: string;\n      } /** A transaction which updates global randomness state */\n    | {\n          epoch: string;\n          kind: 'RandomnessStateUpdate';\n          random_bytes: number[];\n          randomness_round: string;\n      } /** The transaction which occurs only at the end of the epoch */\n    | {\n          kind: 'EndOfEpochTransaction';\n          transactions: IotaEndOfEpochTransactionKind[];\n      };\nexport interface IotaTransactionBlockResponse {\n    balanceChanges?: BalanceChange[] | null;\n    /**\n     * The checkpoint number when this transaction was included and hence finalized. This is only returned\n     * in the read api, not in the transaction execution api.\n     */\n    checkpoint?: string | null;\n    confirmedLocalExecution?: boolean | null;\n    digest: string;\n    effects?: TransactionEffects | null;\n    errors?: string[];\n    events?: IotaEvent[] | null;\n    objectChanges?: IotaObjectChange[] | null;\n    rawEffects?: number[];\n    /**\n     * BCS encoded [SenderSignedData] that includes input object references returns empty array if\n     * `show_raw_transaction` is false\n     */\n    rawTransaction?: string;\n    timestampMs?: string | null;\n    /** Transaction input data */\n    transaction?: IotaTransactionBlock | null;\n}\nexport interface IotaTransactionBlockResponseOptions {\n    /** Whether to show balance_changes. Default to be False */\n    showBalanceChanges?: boolean;\n    /** Whether to show transaction effects. Default to be False */\n    showEffects?: boolean;\n    /** Whether to show transaction events. Default to be False */\n    showEvents?: boolean;\n    /** Whether to show transaction input data. Default to be False */\n    showInput?: boolean;\n    /** Whether to show object_changes. Default to be False */\n    showObjectChanges?: boolean;\n    /** Whether to show raw transaction effects. Default to be False */\n    showRawEffects?: boolean;\n    /** Whether to show bcs-encoded transaction input data */\n    showRawInput?: boolean;\n}\nexport interface IotaTransactionBlockResponseQuery {\n    /** If None, no filter will be applied */\n    filter?: TransactionFilter | null;\n    /** config which fields to include in the response, by default only digest is included */\n    options?: IotaTransactionBlockResponseOptions | null;\n}\nexport type TransactionFilter =\n    /** Query by checkpoint. */\n    | {\n          Checkpoint: string;\n      } /** Query by move function. */\n    | {\n          MoveFunction: {\n              function?: string | null;\n              module?: string | null;\n              package: string;\n          };\n      } /** Query by input object. */\n    | {\n          InputObject: string;\n      } /** Query by changed object, including created, mutated and unwrapped objects. */\n    | {\n          ChangedObject: string;\n      } /** Query by sender address. */\n    | {\n          FromAddress: string;\n      } /** Query by recipient address. */\n    | {\n          ToAddress: string;\n      } /** Query by sender and recipient address. */\n    | {\n          FromAndToAddress: {\n              from: string;\n              to: string;\n          };\n      } /** Query txs that have a given address as sender or recipient. */\n    | {\n          FromOrToAddress: {\n              addr: string;\n          };\n      } /** Query by transaction kind */\n    | {\n          TransactionKind: IotaTransactionKind;\n      } /** Query transactions of any given kind in the input. */\n    | {\n          TransactionKindIn: IotaTransactionKind[];\n      };\nexport interface TransferObjectParams {\n    objectId: string;\n    recipient: string;\n}\n/** Identifies a struct and the module it was defined in */\nexport interface TypeOrigin {\n    datatype_name: string;\n    module_name: string;\n    package: string;\n}\n/** Upgraded package info for the linkage table */\nexport interface UpgradeInfo {\n    /** ID of the upgraded packages */\n    upgraded_id: string;\n    /** Version of the upgraded package */\n    upgraded_version: string;\n}\nexport interface ValidatorApy {\n    address: string;\n    apy: number;\n}\nexport interface ValidatorsApy {\n    apys: ValidatorApy[];\n    epoch: string;\n}\n/** An zk login authenticator with all the necessary fields. */\nexport interface ZkLoginAuthenticator {\n    inputs: ZkLoginInputs;\n    maxEpoch: string;\n    userSignature: Signature;\n}\n/** All inputs required for the zk login proof verification and other public inputs. */\nexport interface ZkLoginInputs {\n    addressSeed: string;\n    headerBase64: string;\n    issBase64Details: Claim;\n    proofPoints: ZkLoginProof;\n}\n/** The struct for zk login proof. */\nexport interface ZkLoginProof {\n    a: string[];\n    b: string[][];\n    c: string[];\n}\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
