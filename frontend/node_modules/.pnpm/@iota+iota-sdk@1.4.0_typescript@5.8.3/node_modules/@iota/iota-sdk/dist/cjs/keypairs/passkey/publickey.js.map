{
  "version": 3,
  "sources": ["../../../../src/keypairs/passkey/publickey.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2025 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@iota/bcs';\nimport { secp256r1 } from '@noble/curves/p256';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport { PasskeyAuthenticator } from '../../bcs/bcs.js';\nimport { bytesEqual, PublicKey } from '../../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../../cryptography/signature-scheme.js';\n\nexport const PASSKEY_PUBLIC_KEY_SIZE = 33;\nexport const PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;\nexport const PASSKEY_SIGNATURE_SIZE = 64;\n/** Fixed DER header for secp256r1 SubjectPublicKeyInfo\nDER structure for P-256 SPKI:\n30 -- SEQUENCE\n  59 -- length (89 bytes)\n  30 -- SEQUENCE\n    13 -- length (19 bytes)\n    06 -- OBJECT IDENTIFIER\n      07 -- length\n      2A 86 48 CE 3D 02 01 -- id-ecPublicKey\n    06 -- OBJECT IDENTIFIER\n      08 -- length\n      2A 86 48 CE 3D 03 01 07 -- secp256r1/prime256v1\n  03 -- BIT STRING\n    42 -- length (66 bytes)\n    00 -- padding\n\t===== above bytes are considered header =====\n    04 || x || y -- uncompressed point (65 bytes: 0x04 || 32-byte x || 32-byte y)\n*/\nexport const SECP256R1_SPKI_HEADER = new Uint8Array([\n    0x30,\n    0x59, // SEQUENCE, length 89\n    0x30,\n    0x13, // SEQUENCE, length 19\n    0x06,\n    0x07, // OID, length 7\n    0x2a,\n    0x86,\n    0x48,\n    0xce,\n    0x3d,\n    0x02,\n    0x01, // OID: 1.2.840.10045.2.1 (ecPublicKey)\n    0x06,\n    0x08, // OID, length 8\n    0x2a,\n    0x86,\n    0x48,\n    0xce,\n    0x3d,\n    0x03,\n    0x01,\n    0x07, // OID: 1.2.840.10045.3.1.7 (prime256v1/secp256r1)\n    0x03,\n    0x42, // BIT STRING, length 66\n    0x00, // no unused bits\n] as const);\n\n/**\n * A passkey public key\n */\nexport class PasskeyPublicKey extends PublicKey {\n    static SIZE = PASSKEY_PUBLIC_KEY_SIZE;\n    private data: Uint8Array;\n\n    /**\n     * Create a new PasskeyPublicKey object\n     * @param value passkey public key as buffer or base-64 encoded string\n     */\n    constructor(value: PublicKeyInitData) {\n        super();\n\n        if (typeof value === 'string') {\n            this.data = fromB64(value);\n        } else if (value instanceof Uint8Array) {\n            this.data = value;\n        } else {\n            this.data = Uint8Array.from(value);\n        }\n\n        if (this.data.length !== PASSKEY_PUBLIC_KEY_SIZE) {\n            throw new Error(\n                `Invalid public key input. Expected ${PASSKEY_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n            );\n        }\n    }\n\n    /**\n     * Checks if two passkey public keys are equal\n     */\n    override equals(publicKey: PasskeyPublicKey): boolean {\n        return super.equals(publicKey);\n    }\n\n    /**\n     * Return the byte array representation of the Secp256r1 public key\n     */\n    toRawBytes(): Uint8Array {\n        return this.data;\n    }\n\n    /**\n     * Return the IOTA address associated with this Secp256r1 public key\n     */\n    flag(): number {\n        return SIGNATURE_SCHEME_TO_FLAG['Passkey'];\n    }\n\n    /**\n     * Verifies that the signature is valid for for the provided message\n     */\n    async verify(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n        const parsed = parseSerializedPasskeySignature(signature);\n        const clientDataJSON = JSON.parse(parsed.clientDataJson);\n\n        if (clientDataJSON.type !== 'webauthn.get') {\n            return false;\n        }\n\n        // parse challenge from base64 url\n        const parsedChallenge = fromB64(\n            clientDataJSON.challenge.replace(/-/g, '+').replace(/_/g, '/'),\n        );\n        if (!bytesEqual(message, parsedChallenge)) {\n            return false;\n        }\n\n        const pk = parsed.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE);\n        if (!bytesEqual(this.toRawBytes(), pk)) {\n            return false;\n        }\n\n        const payload = new Uint8Array([\n            ...parsed.authenticatorData,\n            ...sha256(parsed.clientDataJson),\n        ]);\n        const sig = parsed.userSignature.slice(1, PASSKEY_SIGNATURE_SIZE + 1);\n        return secp256r1.verify(sig, sha256(payload), pk);\n    }\n}\n\n/**\n * Parses a DER SubjectPublicKeyInfo into an uncompressed public key. This also verifies\n * that the curve used is P-256 (secp256r1).\n *\n * @param data: DER SubjectPublicKeyInfo\n * @returns uncompressed public key (`0x04 || x || y`)\n */\nexport function parseDerSPKI(derBytes: Uint8Array): Uint8Array {\n    // Verify length and header bytes are expected\n    if (derBytes.length !== SECP256R1_SPKI_HEADER.length + PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE) {\n        throw new Error('Invalid DER length');\n    }\n    for (let i = 0; i < SECP256R1_SPKI_HEADER.length; i++) {\n        if (derBytes[i] !== SECP256R1_SPKI_HEADER[i]) {\n            throw new Error('Invalid spki header');\n        }\n    }\n\n    if (derBytes[SECP256R1_SPKI_HEADER.length] !== 0x04) {\n        throw new Error('Invalid point marker');\n    }\n\n    // Returns the last 65 bytes `04 || x || y`\n    return derBytes.slice(SECP256R1_SPKI_HEADER.length);\n}\n\n/**\n * Parse signature from bytes or base64 string into the following fields.\n */\nexport function parseSerializedPasskeySignature(signature: Uint8Array | string) {\n    const bytes = typeof signature === 'string' ? fromB64(signature) : signature;\n\n    if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.Passkey) {\n        throw new Error('Invalid signature scheme');\n    }\n    const dec = PasskeyAuthenticator.parse(bytes.slice(1));\n    return {\n        signatureScheme: 'Passkey' as const,\n        serializedSignature: toB64(bytes),\n        signature: bytes,\n        authenticatorData: dec.authenticatorData,\n        clientDataJson: dec.clientDataJson,\n        userSignature: new Uint8Array(dec.userSignature),\n        publicKey: new Uint8Array(dec.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE)),\n    };\n}\n"],
  "mappings": "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",
  "names": ["import_bcs"]
}
