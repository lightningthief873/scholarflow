{
  "version": 3,
  "sources": ["../../../src/transactions/serializer.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@iota/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { IotaMoveNormalizedType } from '../client/index.js';\nimport { MOVE_STDLIB_ADDRESS, IOTA_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { OpenMoveTypeSignature, OpenMoveTypeSignatureBody } from './data/internal.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nexport function isTxContext(param: OpenMoveTypeSignature): boolean {\n    const struct =\n        typeof param.body === 'object' && 'datatype' in param.body ? param.body.datatype : null;\n\n    return (\n        !!struct &&\n        normalizeIotaAddress(struct.package) === normalizeIotaAddress('0x2') &&\n        struct.module === 'tx_context' &&\n        struct.type === 'TxContext'\n    );\n}\n\nexport function getPureBcsSchema(typeSignature: OpenMoveTypeSignatureBody): BcsType<any> | null {\n    if (typeof typeSignature === 'string') {\n        switch (typeSignature) {\n            case 'address':\n                return bcs.Address;\n            case 'bool':\n                return bcs.Bool;\n            case 'u8':\n                return bcs.U8;\n            case 'u16':\n                return bcs.U16;\n            case 'u32':\n                return bcs.U32;\n            case 'u64':\n                return bcs.U64;\n            case 'u128':\n                return bcs.U128;\n            case 'u256':\n                return bcs.U256;\n            default:\n                throw new Error(`Unknown type signature ${typeSignature}`);\n        }\n    }\n\n    if ('vector' in typeSignature) {\n        if (typeSignature.vector === 'u8') {\n            return bcs.vector(bcs.U8).transform({\n                input: (val: string | Uint8Array) =>\n                    typeof val === 'string' ? new TextEncoder().encode(val) : val,\n                output: (val) => val,\n            });\n        }\n        const type = getPureBcsSchema(typeSignature.vector);\n        return type ? bcs.vector(type) : null;\n    }\n\n    if ('datatype' in typeSignature) {\n        const pkg = normalizeIotaAddress(typeSignature.datatype.package);\n\n        if (pkg === normalizeIotaAddress(MOVE_STDLIB_ADDRESS)) {\n            if (\n                typeSignature.datatype.module === STD_ASCII_MODULE_NAME &&\n                typeSignature.datatype.type === STD_ASCII_STRUCT_NAME\n            ) {\n                return bcs.String;\n            }\n\n            if (\n                typeSignature.datatype.module === STD_UTF8_MODULE_NAME &&\n                typeSignature.datatype.type === STD_UTF8_STRUCT_NAME\n            ) {\n                return bcs.String;\n            }\n\n            if (\n                typeSignature.datatype.module === STD_OPTION_MODULE_NAME &&\n                typeSignature.datatype.type === STD_OPTION_STRUCT_NAME\n            ) {\n                const type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);\n                return type ? bcs.vector(type) : null;\n            }\n        }\n\n        if (\n            pkg === normalizeIotaAddress(IOTA_FRAMEWORK_ADDRESS) &&\n            typeSignature.datatype.module === OBJECT_MODULE_NAME &&\n            typeSignature.datatype.type === ID_STRUCT_NAME\n        ) {\n            return bcs.Address;\n        }\n    }\n\n    return null;\n}\n\nexport function normalizedTypeToMoveTypeSignature(\n    type: IotaMoveNormalizedType,\n): OpenMoveTypeSignature {\n    if (typeof type === 'object' && 'Reference' in type) {\n        return {\n            ref: '&',\n            body: normalizedTypeToMoveTypeSignatureBody(type.Reference),\n        };\n    }\n    if (typeof type === 'object' && 'MutableReference' in type) {\n        return {\n            ref: '&mut',\n            body: normalizedTypeToMoveTypeSignatureBody(type.MutableReference),\n        };\n    }\n\n    return {\n        ref: null,\n        body: normalizedTypeToMoveTypeSignatureBody(type),\n    };\n}\n\nfunction normalizedTypeToMoveTypeSignatureBody(\n    type: IotaMoveNormalizedType,\n): OpenMoveTypeSignatureBody {\n    if (typeof type === 'string') {\n        switch (type) {\n            case 'Address':\n                return 'address';\n            case 'Bool':\n                return 'bool';\n            case 'U8':\n                return 'u8';\n            case 'U16':\n                return 'u16';\n            case 'U32':\n                return 'u32';\n            case 'U64':\n                return 'u64';\n            case 'U128':\n                return 'u128';\n            case 'U256':\n                return 'u256';\n            default:\n                throw new Error(`Unexpected type ${type}`);\n        }\n    }\n\n    if ('Vector' in type) {\n        return { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };\n    }\n\n    if ('Struct' in type) {\n        return {\n            datatype: {\n                package: type.Struct.address,\n                module: type.Struct.module,\n                type: type.Struct.name,\n                typeParameters: type.Struct.typeArguments.map(\n                    normalizedTypeToMoveTypeSignatureBody,\n                ),\n            },\n        };\n    }\n\n    if ('TypeParameter' in type) {\n        return { typeParameter: type.TypeParameter };\n    }\n\n    throw new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\n\nexport function pureBcsSchemaFromOpenMoveTypeSignatureBody(\n    typeSignature: OpenMoveTypeSignatureBody,\n): BcsType<any> {\n    if (typeof typeSignature === 'string') {\n        switch (typeSignature) {\n            case 'address':\n                return bcs.Address;\n            case 'bool':\n                return bcs.Bool;\n            case 'u8':\n                return bcs.U8;\n            case 'u16':\n                return bcs.U16;\n            case 'u32':\n                return bcs.U32;\n            case 'u64':\n                return bcs.U64;\n            case 'u128':\n                return bcs.U128;\n            case 'u256':\n                return bcs.U256;\n            default:\n                throw new Error(`Unknown type signature ${typeSignature}`);\n        }\n    }\n\n    if ('vector' in typeSignature) {\n        return bcs.vector(pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature.vector));\n    }\n\n    throw new Error(`Expected pure typeSignature, but got ${JSON.stringify(typeSignature)}`);\n}\n"],
  "mappings": "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",
  "names": []
}
