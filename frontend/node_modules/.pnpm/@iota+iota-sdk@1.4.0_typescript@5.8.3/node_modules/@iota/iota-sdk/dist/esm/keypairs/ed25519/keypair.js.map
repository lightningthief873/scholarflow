{
  "version": 3,
  "sources": ["../../../../src/keypairs/ed25519/keypair.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport nacl from 'tweetnacl';\n\nimport { encodeIotaPrivateKey, Keypair, PRIVATE_KEY_SIZE } from '../../cryptography/keypair.js';\nimport { isValidHardenedPath, mnemonicToSeedHex } from '../../cryptography/mnemonics.js';\nimport type { SignatureScheme } from '../../cryptography/signature-scheme.js';\nimport { derivePath } from './ed25519-hd-key.js';\nimport { Ed25519PublicKey } from './publickey.js';\n\nexport const DEFAULT_ED25519_DERIVATION_PATH = \"m/44'/4218'/0'/0'/0'\";\n\n/**\n * Ed25519 Keypair data. The publickey is the 32-byte public key and\n * the secretkey is 64-byte, where the first 32 bytes is the secret\n * key and the last 32 bytes is the public key.\n */\nexport interface Ed25519KeypairData {\n    publicKey: Uint8Array;\n    secretKey: Uint8Array;\n}\n\n/**\n * An Ed25519 Keypair used for signing transactions.\n */\nexport class Ed25519Keypair extends Keypair {\n    private keypair: Ed25519KeypairData;\n\n    /**\n     * Create a new Ed25519 keypair instance.\n     * Generate random keypair if no {@link Ed25519Keypair} is provided.\n     *\n     * @param keypair Ed25519 keypair\n     */\n    constructor(keypair?: Ed25519KeypairData) {\n        super();\n        if (keypair) {\n            this.keypair = keypair;\n        } else {\n            this.keypair = nacl.sign.keyPair();\n        }\n    }\n\n    /**\n     * Get the key scheme of the keypair ED25519\n     */\n    getKeyScheme(): SignatureScheme {\n        return 'ED25519';\n    }\n\n    /**\n     * Generate a new random Ed25519 keypair\n     */\n    static generate(): Ed25519Keypair {\n        return new Ed25519Keypair(nacl.sign.keyPair());\n    }\n\n    /**\n     * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.\n     * This is NOT the private scalar which is result of hashing and bit clamping of\n     * the raw secret key.\n     *\n     * @throws error if the provided secret key is invalid and validation is not skipped.\n     *\n     * @param secretKey secret key byte array\n     * @param options: skip secret key validation\n     */\n    static fromSecretKey(\n        secretKey: Uint8Array,\n        options?: { skipValidation?: boolean },\n    ): Ed25519Keypair {\n        const secretKeyLength = secretKey.length;\n        if (secretKeyLength !== PRIVATE_KEY_SIZE) {\n            throw new Error(\n                `Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`,\n            );\n        }\n        const keypair = nacl.sign.keyPair.fromSeed(secretKey);\n        if (!options || !options.skipValidation) {\n            const encoder = new TextEncoder();\n            const signData = encoder.encode('iota validation');\n            const signature = nacl.sign.detached(signData, keypair.secretKey);\n            if (!nacl.sign.detached.verify(signData, signature, keypair.publicKey)) {\n                throw new Error('provided secretKey is invalid');\n            }\n        }\n        return new Ed25519Keypair(keypair);\n    }\n\n    /**\n     * The public key for this Ed25519 keypair\n     */\n    getPublicKey(): Ed25519PublicKey {\n        return new Ed25519PublicKey(this.keypair.publicKey);\n    }\n\n    /**\n     * The Bech32 secret key string for this Ed25519 keypair\n     */\n    getSecretKey(): string {\n        return encodeIotaPrivateKey(\n            this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE),\n            this.getKeyScheme(),\n        );\n    }\n\n    /**\n     * Return the signature for the provided data using Ed25519.\n     */\n    async sign(data: Uint8Array) {\n        return nacl.sign.detached(data, this.keypair.secretKey);\n    }\n\n    /**\n     * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized\n     * and validated against the english wordlist.\n     *\n     * If path is none, it will default to m/44'/4218'/0'/0'/0', otherwise the path must\n     * be compliant to SLIP-0010 in form m/44'/4218'/{account_index}'/{change_index}'/{address_index}'.\n     */\n    static deriveKeypair(mnemonics: string, path?: string): Ed25519Keypair {\n        if (path == null) {\n            path = DEFAULT_ED25519_DERIVATION_PATH;\n        }\n        if (!isValidHardenedPath(path)) {\n            throw new Error('Invalid derivation path');\n        }\n        const { key } = derivePath(path, mnemonicToSeedHex(mnemonics));\n\n        return Ed25519Keypair.fromSecretKey(key);\n    }\n\n    /**\n     * Derive Ed25519 keypair from mnemonicSeed and path.\n     *\n     * If path is none, it will default to m/44'/4218'/0'/0'/0', otherwise the path must\n     * be compliant to SLIP-0010 in form m/44'/4218'/{account_index}'/{change_index}'/{address_index}'.\n     */\n    static deriveKeypairFromSeed(seedHex: string, path?: string): Ed25519Keypair {\n        if (path == null) {\n            path = DEFAULT_ED25519_DERIVATION_PATH;\n        }\n        if (!isValidHardenedPath(path)) {\n            throw new Error('Invalid derivation path');\n        }\n        const { key } = derivePath(path, seedHex);\n\n        return Ed25519Keypair.fromSecretKey(key);\n    }\n}\n"],
  "mappings": "AAIA,OAAO,UAAU;AAEjB,SAAS,sBAAsB,SAAS,wBAAwB;AAChE,SAAS,qBAAqB,yBAAyB;AAEvD,SAAS,kBAAkB;AAC3B,SAAS,wBAAwB;AAE1B,MAAM,kCAAkC;AAexC,MAAM,uBAAuB,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASxC,YAAY,SAA8B;AACtC,UAAM;AACN,QAAI,SAAS;AACT,WAAK,UAAU;AAAA,IACnB,OAAO;AACH,WAAK,UAAU,KAAK,KAAK,QAAQ;AAAA,IACrC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,eAAgC;AAC5B,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,WAA2B;AAC9B,WAAO,IAAI,eAAe,KAAK,KAAK,QAAQ,CAAC;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,OAAO,cACH,WACA,SACc;AACd,UAAM,kBAAkB,UAAU;AAClC,QAAI,oBAAoB,kBAAkB;AACtC,YAAM,IAAI;AAAA,QACN,kCAAkC,gBAAgB,eAAe,eAAe;AAAA,MACpF;AAAA,IACJ;AACA,UAAM,UAAU,KAAK,KAAK,QAAQ,SAAS,SAAS;AACpD,QAAI,CAAC,WAAW,CAAC,QAAQ,gBAAgB;AACrC,YAAM,UAAU,IAAI,YAAY;AAChC,YAAM,WAAW,QAAQ,OAAO,iBAAiB;AACjD,YAAM,YAAY,KAAK,KAAK,SAAS,UAAU,QAAQ,SAAS;AAChE,UAAI,CAAC,KAAK,KAAK,SAAS,OAAO,UAAU,WAAW,QAAQ,SAAS,GAAG;AACpE,cAAM,IAAI,MAAM,+BAA+B;AAAA,MACnD;AAAA,IACJ;AACA,WAAO,IAAI,eAAe,OAAO;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,eAAiC;AAC7B,WAAO,IAAI,iBAAiB,KAAK,QAAQ,SAAS;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA,EAKA,eAAuB;AACnB,WAAO;AAAA,MACH,KAAK,QAAQ,UAAU,MAAM,GAAG,gBAAgB;AAAA,MAChD,KAAK,aAAa;AAAA,IACtB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAK,MAAkB;AACzB,WAAO,KAAK,KAAK,SAAS,MAAM,KAAK,QAAQ,SAAS;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,cAAc,WAAmB,MAA+B;AACnE,QAAI,QAAQ,MAAM;AACd,aAAO;AAAA,IACX;AACA,QAAI,CAAC,oBAAoB,IAAI,GAAG;AAC5B,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC7C;AACA,UAAM,EAAE,IAAI,IAAI,WAAW,MAAM,kBAAkB,SAAS,CAAC;AAE7D,WAAO,eAAe,cAAc,GAAG;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,sBAAsB,SAAiB,MAA+B;AACzE,QAAI,QAAQ,MAAM;AACd,aAAO;AAAA,IACX;AACA,QAAI,CAAC,oBAAoB,IAAI,GAAG;AAC5B,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC7C;AACA,UAAM,EAAE,IAAI,IAAI,WAAW,MAAM,OAAO;AAExC,WAAO,eAAe,cAAc,GAAG;AAAA,EAC3C;AACJ;",
  "names": []
}
