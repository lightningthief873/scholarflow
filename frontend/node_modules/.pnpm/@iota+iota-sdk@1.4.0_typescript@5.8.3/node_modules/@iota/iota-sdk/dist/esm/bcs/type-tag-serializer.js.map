{
  "version": 3,
  "sources": ["../../../src/bcs/type-tag-serializer.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@iota/bcs';\n\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n    static parseFromStr(str: string, normalizeAddress = false): TypeTag {\n        if (str === 'address') {\n            return { address: null };\n        } else if (str === 'bool') {\n            return { bool: null };\n        } else if (str === 'u8') {\n            return { u8: null };\n        } else if (str === 'u16') {\n            return { u16: null };\n        } else if (str === 'u32') {\n            return { u32: null };\n        } else if (str === 'u64') {\n            return { u64: null };\n        } else if (str === 'u128') {\n            return { u128: null };\n        } else if (str === 'u256') {\n            return { u256: null };\n        } else if (str === 'signer') {\n            return { signer: null };\n        }\n\n        const vectorMatch = str.match(VECTOR_REGEX);\n        if (vectorMatch) {\n            return {\n                vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n            };\n        }\n\n        const structMatch = str.match(STRUCT_REGEX);\n        if (structMatch) {\n            const address = normalizeAddress\n                ? normalizeIotaAddress(structMatch[1])\n                : structMatch[1];\n            return {\n                struct: {\n                    address,\n                    module: structMatch[2],\n                    name: structMatch[3],\n                    typeParams:\n                        structMatch[5] === undefined\n                            ? []\n                            : TypeTagSerializer.parseStructTypeArgs(\n                                  structMatch[5],\n                                  normalizeAddress,\n                              ),\n                },\n            };\n        }\n\n        throw new Error(`Encountered unexpected token when parsing type args for ${str}`);\n    }\n\n    static parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n        return splitGenericParameters(str).map((tok) =>\n            TypeTagSerializer.parseFromStr(tok, normalizeAddress),\n        );\n    }\n\n    static tagToString(tag: TypeTag): string {\n        if ('bool' in tag) {\n            return 'bool';\n        }\n        if ('u8' in tag) {\n            return 'u8';\n        }\n        if ('u16' in tag) {\n            return 'u16';\n        }\n        if ('u32' in tag) {\n            return 'u32';\n        }\n        if ('u64' in tag) {\n            return 'u64';\n        }\n        if ('u128' in tag) {\n            return 'u128';\n        }\n        if ('u256' in tag) {\n            return 'u256';\n        }\n        if ('address' in tag) {\n            return 'address';\n        }\n        if ('signer' in tag) {\n            return 'signer';\n        }\n        if ('vector' in tag) {\n            return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n        }\n        if ('struct' in tag) {\n            const struct = tag.struct;\n            const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n            return `${struct.address}::${struct.module}::${struct.name}${\n                typeParams ? `<${typeParams}>` : ''\n            }`;\n        }\n        throw new Error('Invalid TypeTag');\n    }\n}\n"],
  "mappings": "AAIA,SAAS,8BAA8B;AAEvC,SAAS,4BAA4B;AAGrC,MAAM,eAAe;AACrB,MAAM,eAAe;AAEd,MAAM,kBAAkB;AAAA,EAC3B,OAAO,aAAa,KAAa,mBAAmB,OAAgB;AAChE,QAAI,QAAQ,WAAW;AACnB,aAAO,EAAE,SAAS,KAAK;AAAA,IAC3B,WAAW,QAAQ,QAAQ;AACvB,aAAO,EAAE,MAAM,KAAK;AAAA,IACxB,WAAW,QAAQ,MAAM;AACrB,aAAO,EAAE,IAAI,KAAK;AAAA,IACtB,WAAW,QAAQ,OAAO;AACtB,aAAO,EAAE,KAAK,KAAK;AAAA,IACvB,WAAW,QAAQ,OAAO;AACtB,aAAO,EAAE,KAAK,KAAK;AAAA,IACvB,WAAW,QAAQ,OAAO;AACtB,aAAO,EAAE,KAAK,KAAK;AAAA,IACvB,WAAW,QAAQ,QAAQ;AACvB,aAAO,EAAE,MAAM,KAAK;AAAA,IACxB,WAAW,QAAQ,QAAQ;AACvB,aAAO,EAAE,MAAM,KAAK;AAAA,IACxB,WAAW,QAAQ,UAAU;AACzB,aAAO,EAAE,QAAQ,KAAK;AAAA,IAC1B;AAEA,UAAM,cAAc,IAAI,MAAM,YAAY;AAC1C,QAAI,aAAa;AACb,aAAO;AAAA,QACH,QAAQ,kBAAkB,aAAa,YAAY,CAAC,GAAG,gBAAgB;AAAA,MAC3E;AAAA,IACJ;AAEA,UAAM,cAAc,IAAI,MAAM,YAAY;AAC1C,QAAI,aAAa;AACb,YAAM,UAAU,mBACV,qBAAqB,YAAY,CAAC,CAAC,IACnC,YAAY,CAAC;AACnB,aAAO;AAAA,QACH,QAAQ;AAAA,UACJ;AAAA,UACA,QAAQ,YAAY,CAAC;AAAA,UACrB,MAAM,YAAY,CAAC;AAAA,UACnB,YACI,YAAY,CAAC,MAAM,SACb,CAAC,IACD,kBAAkB;AAAA,YACd,YAAY,CAAC;AAAA,YACb;AAAA,UACJ;AAAA,QACd;AAAA,MACJ;AAAA,IACJ;AAEA,UAAM,IAAI,MAAM,2DAA2D,GAAG,EAAE;AAAA,EACpF;AAAA,EAEA,OAAO,oBAAoB,KAAa,mBAAmB,OAAkB;AACzE,WAAO,uBAAuB,GAAG,EAAE;AAAA,MAAI,CAAC,QACpC,kBAAkB,aAAa,KAAK,gBAAgB;AAAA,IACxD;AAAA,EACJ;AAAA,EAEA,OAAO,YAAY,KAAsB;AACrC,QAAI,UAAU,KAAK;AACf,aAAO;AAAA,IACX;AACA,QAAI,QAAQ,KAAK;AACb,aAAO;AAAA,IACX;AACA,QAAI,SAAS,KAAK;AACd,aAAO;AAAA,IACX;AACA,QAAI,SAAS,KAAK;AACd,aAAO;AAAA,IACX;AACA,QAAI,SAAS,KAAK;AACd,aAAO;AAAA,IACX;AACA,QAAI,UAAU,KAAK;AACf,aAAO;AAAA,IACX;AACA,QAAI,UAAU,KAAK;AACf,aAAO;AAAA,IACX;AACA,QAAI,aAAa,KAAK;AAClB,aAAO;AAAA,IACX;AACA,QAAI,YAAY,KAAK;AACjB,aAAO;AAAA,IACX;AACA,QAAI,YAAY,KAAK;AACjB,aAAO,UAAU,kBAAkB,YAAY,IAAI,MAAM,CAAC;AAAA,IAC9D;AACA,QAAI,YAAY,KAAK;AACjB,YAAM,SAAS,IAAI;AACnB,YAAM,aAAa,OAAO,WAAW,IAAI,kBAAkB,WAAW,EAAE,KAAK,IAAI;AACjF,aAAO,GAAG,OAAO,OAAO,KAAK,OAAO,MAAM,KAAK,OAAO,IAAI,GACtD,aAAa,IAAI,UAAU,MAAM,EACrC;AAAA,IACJ;AACA,UAAM,IAAI,MAAM,iBAAiB;AAAA,EACrC;AACJ;",
  "names": []
}
