{
  "version": 3,
  "sources": ["../../../../src/keypairs/ed25519/publickey.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64 } from '@iota/bcs';\nimport nacl from 'tweetnacl';\n\nimport type { PublicKeyInitData } from '../../cryptography/publickey.js';\nimport { bytesEqual, PublicKey } from '../../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../../cryptography/signature-scheme.js';\nimport { parseSerializedSignature } from '../../cryptography/signature.js';\n\nconst PUBLIC_KEY_SIZE = 32;\n\n/**\n * An Ed25519 public key\n */\nexport class Ed25519PublicKey extends PublicKey {\n    static SIZE = PUBLIC_KEY_SIZE;\n    private data: Uint8Array;\n\n    /**\n     * Create a new Ed25519PublicKey object\n     * @param value ed25519 public key as buffer or base-64 encoded string\n     */\n    constructor(value: PublicKeyInitData) {\n        super();\n\n        if (typeof value === 'string') {\n            this.data = fromB64(value);\n        } else if (value instanceof Uint8Array) {\n            this.data = value;\n        } else {\n            this.data = Uint8Array.from(value);\n        }\n\n        if (this.data.length !== PUBLIC_KEY_SIZE) {\n            throw new Error(\n                `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n            );\n        }\n    }\n\n    /**\n     * Checks if two Ed25519 public keys are equal\n     */\n    override equals(publicKey: Ed25519PublicKey): boolean {\n        return super.equals(publicKey);\n    }\n\n    /**\n     * Return the byte array representation of the Ed25519 public key\n     */\n    toRawBytes(): Uint8Array {\n        return this.data;\n    }\n\n    /**\n     * Return the IOTA address associated with this Ed25519 public key\n     */\n    flag(): number {\n        return SIGNATURE_SCHEME_TO_FLAG['ED25519'];\n    }\n\n    /**\n     * Verifies that the signature is valid for the provided message\n     */\n    async verify(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n        let bytes;\n        if (typeof signature === 'string') {\n            const parsed = parseSerializedSignature(signature);\n            if (parsed.signatureScheme !== 'ED25519') {\n                throw new Error('Invalid signature scheme');\n            }\n\n            if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {\n                throw new Error('Signature does not match public key');\n            }\n\n            bytes = parsed.signature;\n        } else {\n            bytes = signature;\n        }\n\n        return nacl.sign.detached.verify(message, bytes, this.toRawBytes());\n    }\n}\n"],
  "mappings": "AAIA,SAAS,eAAe;AACxB,OAAO,UAAU;AAGjB,SAAS,YAAY,iBAAiB;AACtC,SAAS,gCAAgC;AACzC,SAAS,gCAAgC;AAEzC,MAAM,kBAAkB;AAKjB,MAAM,yBAAyB,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ5C,YAAY,OAA0B;AAClC,UAAM;AAEN,QAAI,OAAO,UAAU,UAAU;AAC3B,WAAK,OAAO,QAAQ,KAAK;AAAA,IAC7B,WAAW,iBAAiB,YAAY;AACpC,WAAK,OAAO;AAAA,IAChB,OAAO;AACH,WAAK,OAAO,WAAW,KAAK,KAAK;AAAA,IACrC;AAEA,QAAI,KAAK,KAAK,WAAW,iBAAiB;AACtC,YAAM,IAAI;AAAA,QACN,sCAAsC,eAAe,eAAe,KAAK,KAAK,MAAM;AAAA,MACxF;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKS,OAAO,WAAsC;AAClD,WAAO,MAAM,OAAO,SAAS;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAKA,aAAyB;AACrB,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,OAAe;AACX,WAAO,yBAAyB,SAAS;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO,SAAqB,WAAkD;AAChF,QAAI;AACJ,QAAI,OAAO,cAAc,UAAU;AAC/B,YAAM,SAAS,yBAAyB,SAAS;AACjD,UAAI,OAAO,oBAAoB,WAAW;AACtC,cAAM,IAAI,MAAM,0BAA0B;AAAA,MAC9C;AAEA,UAAI,CAAC,WAAW,KAAK,WAAW,GAAG,OAAO,SAAS,GAAG;AAClD,cAAM,IAAI,MAAM,qCAAqC;AAAA,MACzD;AAEA,cAAQ,OAAO;AAAA,IACnB,OAAO;AACH,cAAQ;AAAA,IACZ;AAEA,WAAO,KAAK,KAAK,SAAS,OAAO,SAAS,OAAO,KAAK,WAAW,CAAC;AAAA,EACtE;AACJ;AArEa,iBACF,OAAO;",
  "names": []
}
