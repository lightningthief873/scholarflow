{
  "version": 3,
  "sources": ["../../../src/client/http-transport.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { PACKAGE_VERSION, TARGETED_RPC_VERSION } from '../version.js';\nimport { JsonRpcError, IotaHTTPStatusError } from './errors.js';\nimport type { WebsocketClientOptions } from './rpc-websocket-client.js';\nimport { WebsocketClient } from './rpc-websocket-client.js';\n\n/**\n * An object defining headers to be passed to the RPC server\n */\nexport type HttpHeaders = { [header: string]: string };\n\nexport interface IotaHTTPTransportOptions {\n    fetch?: typeof fetch;\n    WebSocketConstructor?: typeof WebSocket;\n    url: string;\n    rpc?: {\n        headers?: HttpHeaders;\n        url?: string;\n    };\n    websocket?: WebsocketClientOptions & {\n        url?: string;\n    };\n}\n\nexport interface IotaTransportRequestOptions {\n    method: string;\n    params: unknown[];\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nexport interface IotaTransportSubscribeOptions<T> {\n    method: string;\n    unsubscribe: string;\n    params: unknown[];\n    onMessage: (event: T) => void;\n}\n\nexport interface IotaTransport {\n    request<T = unknown>(input: IotaTransportRequestOptions): Promise<T>;\n    subscribe<T = unknown>(\n        input: IotaTransportSubscribeOptions<T>,\n    ): Promise<() => Promise<boolean>>;\n}\n\nexport class IotaHTTPTransport implements IotaTransport {\n    #requestId = 0;\n    #options: IotaHTTPTransportOptions;\n    #websocketClient?: WebsocketClient;\n\n    constructor(options: IotaHTTPTransportOptions) {\n        this.#options = options;\n    }\n\n    fetch(input: RequestInfo, init?: RequestInit): Promise<Response> {\n        const fetchFn = this.#options.fetch ?? fetch;\n\n        if (!fetchFn) {\n            throw new Error(\n                'The current environment does not support fetch, you can provide a fetch implementation in the options for IotaHTTPTransport.',\n            );\n        }\n\n        return fetchFn(input, init);\n    }\n\n    #getWebsocketClient(): WebsocketClient {\n        if (!this.#websocketClient) {\n            const WebSocketConstructor = this.#options.WebSocketConstructor ?? WebSocket;\n            if (!WebSocketConstructor) {\n                throw new Error(\n                    'The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for IotaHTTPTransport.',\n                );\n            }\n\n            this.#websocketClient = new WebsocketClient(\n                this.#options.websocket?.url ?? this.#options.url,\n                {\n                    WebSocketConstructor,\n                    ...this.#options.websocket,\n                },\n            );\n        }\n\n        return this.#websocketClient;\n    }\n\n    async request<T>(input: IotaTransportRequestOptions): Promise<T> {\n        this.#requestId += 1;\n\n        const res = await this.fetch(this.#options.rpc?.url ?? this.#options.url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Client-Sdk-Type': 'typescript',\n                'Client-Sdk-Version': PACKAGE_VERSION,\n                'Client-Target-Api-Version': TARGETED_RPC_VERSION,\n                ...this.#options.rpc?.headers,\n            },\n            body: JSON.stringify({\n                jsonrpc: '2.0',\n                id: this.#requestId,\n                method: input.method,\n                params: input.params,\n            }),\n        });\n\n        if (!res.ok) {\n            throw new IotaHTTPStatusError(\n                `Unexpected status code: ${res.status}`,\n                res.status,\n                res.statusText,\n            );\n        }\n\n        const data = await res.json();\n\n        if ('error' in data && data.error != null) {\n            throw new JsonRpcError(data.error.message, data.error.code);\n        }\n\n        return data.result;\n    }\n\n    async subscribe<T>(input: IotaTransportSubscribeOptions<T>): Promise<() => Promise<boolean>> {\n        const unsubscribe = await this.#getWebsocketClient().subscribe(input);\n\n        return async () => !!(await unsubscribe());\n    }\n}\n"],
  "mappings": ";;;;;;;;AAAA;AAIA,SAAS,iBAAiB,4BAA4B;AACtD,SAAS,cAAc,2BAA2B;AAElD,SAAS,uBAAuB;AAyCzB,MAAM,kBAA2C;AAAA,EAKpD,YAAY,SAAmC;AAL5C;AACH,mCAAa;AACb;AACA;AAGI,uBAAK,UAAW;AAAA,EACpB;AAAA,EAEA,MAAM,OAAoB,MAAuC;AAC7D,UAAM,UAAU,mBAAK,UAAS,SAAS;AAEvC,QAAI,CAAC,SAAS;AACV,YAAM,IAAI;AAAA,QACN;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO,QAAQ,OAAO,IAAI;AAAA,EAC9B;AAAA,EAuBA,MAAM,QAAW,OAAgD;AAC7D,uBAAK,YAAL,mBAAK,cAAc;AAEnB,UAAM,MAAM,MAAM,KAAK,MAAM,mBAAK,UAAS,KAAK,OAAO,mBAAK,UAAS,KAAK;AAAA,MACtE,QAAQ;AAAA,MACR,SAAS;AAAA,QACL,gBAAgB;AAAA,QAChB,mBAAmB;AAAA,QACnB,sBAAsB;AAAA,QACtB,6BAA6B;AAAA,QAC7B,GAAG,mBAAK,UAAS,KAAK;AAAA,MAC1B;AAAA,MACA,MAAM,KAAK,UAAU;AAAA,QACjB,SAAS;AAAA,QACT,IAAI,mBAAK;AAAA,QACT,QAAQ,MAAM;AAAA,QACd,QAAQ,MAAM;AAAA,MAClB,CAAC;AAAA,IACL,CAAC;AAED,QAAI,CAAC,IAAI,IAAI;AACT,YAAM,IAAI;AAAA,QACN,2BAA2B,IAAI,MAAM;AAAA,QACrC,IAAI;AAAA,QACJ,IAAI;AAAA,MACR;AAAA,IACJ;AAEA,UAAM,OAAO,MAAM,IAAI,KAAK;AAE5B,QAAI,WAAW,QAAQ,KAAK,SAAS,MAAM;AACvC,YAAM,IAAI,aAAa,KAAK,MAAM,SAAS,KAAK,MAAM,IAAI;AAAA,IAC9D;AAEA,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,MAAM,UAAa,OAA0E;AACzF,UAAM,cAAc,MAAM,sBAAK,qDAAL,WAA2B,UAAU,KAAK;AAEpE,WAAO,YAAY,CAAC,CAAE,MAAM,YAAY;AAAA,EAC5C;AACJ;AAnFI;AACA;AACA;AAHG;AAqBH,wBAAmB,WAAoB;AACnC,MAAI,CAAC,mBAAK,mBAAkB;AACxB,UAAM,uBAAuB,mBAAK,UAAS,wBAAwB;AACnE,QAAI,CAAC,sBAAsB;AACvB,YAAM,IAAI;AAAA,QACN;AAAA,MACJ;AAAA,IACJ;AAEA,uBAAK,kBAAmB,IAAI;AAAA,MACxB,mBAAK,UAAS,WAAW,OAAO,mBAAK,UAAS;AAAA,MAC9C;AAAA,QACI;AAAA,QACA,GAAG,mBAAK,UAAS;AAAA,MACrB;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO,mBAAK;AAChB;",
  "names": []
}
