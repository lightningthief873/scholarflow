import type { BcsType } from '@iota/bcs';
export declare const Address: any;
export declare const ObjectDigest: any;
export declare const IotaObjectRef: BcsType<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
export declare const SharedObjectRef: BcsType<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
export declare const ObjectArg: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
export declare const Owner: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
export declare const CallArg: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
export declare const TypeTag: any;
export declare const Argument: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
export declare const ProgrammableMoveCall: BcsType<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
export declare const Command: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
export declare const ProgrammableTransaction: BcsType<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
export declare const TransactionKind: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
export declare const TransactionExpiration: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
export declare const StructTag: BcsType<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
export declare const GasData: BcsType<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
export declare const TransactionDataV1: BcsType<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
export declare const TransactionData: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
export declare const IntentScope: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
export declare const IntentVersion: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
export declare const AppId: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
export declare const Intent: BcsType<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
export declare function IntentMessage<T extends BcsType<any>>(T: T): BcsType<{ [K in keyof T_1]: T_1[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T_1]: T_1[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
export declare const CompressedSignature: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
export declare const PublicKey: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
export declare const MultiSigPkMap: BcsType<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
export declare const MultiSigPublicKey: BcsType<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
export declare const MultiSig: BcsType<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
export declare const base64String: any;
export declare const SenderSignedTransaction: BcsType<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
export declare const SenderSignedData: BcsType<T[], Iterable<Input> & {
    length: number;
}>;
export declare const PasskeyAuthenticator: BcsType<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never; }, { [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : never; }>;
