{
  "version": 3,
  "sources": ["../../../src/cryptography/keypair.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs, toB64 } from '@iota/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bech32 } from 'bech32';\n\nimport type { IntentScope } from './intent.js';\nimport { messageWithIntent } from './intent.js';\nimport type { PublicKey } from './publickey.js';\nimport { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_FLAG } from './signature-scheme.js';\nimport type { SignatureScheme } from './signature-scheme.js';\nimport { toSerializedSignature } from './signature.js';\n\nexport const PRIVATE_KEY_SIZE = 32;\nexport const LEGACY_PRIVATE_KEY_SIZE = 64;\nexport const IOTA_PRIVATE_KEY_PREFIX = 'iotaprivkey';\n\nexport type ParsedKeypair = {\n    schema: SignatureScheme;\n    secretKey: Uint8Array;\n};\n\nexport interface SignatureWithBytes {\n    bytes: string;\n    signature: string;\n}\n\n/**\n * TODO: Document\n */\nexport abstract class Signer {\n    abstract sign(bytes: Uint8Array): Promise<Uint8Array>;\n    /**\n     * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,\n     * it ensures that a signed message is tied to a specific purpose and domain separator is provided\n     */\n    async signWithIntent(bytes: Uint8Array, intent: IntentScope): Promise<SignatureWithBytes> {\n        const intentMessage = messageWithIntent(intent, bytes);\n        const digest = blake2b(intentMessage, { dkLen: 32 });\n\n        const signature = toSerializedSignature({\n            signature: await this.sign(digest),\n            signatureScheme: this.getKeyScheme(),\n            publicKey: this.getPublicKey(),\n        });\n\n        return {\n            signature,\n            bytes: toB64(bytes),\n        };\n    }\n    /**\n     * Signs provided transaction by calling `signWithIntent()` with a `TransactionData` provided as intent scope\n     */\n    async signTransaction(bytes: Uint8Array) {\n        return this.signWithIntent(bytes, 'TransactionData');\n    }\n    /**\n     * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope\n     */\n    async signPersonalMessage(bytes: Uint8Array) {\n        const { signature } = await this.signWithIntent(\n            bcs.vector(bcs.u8()).serialize(bytes).toBytes(),\n            'PersonalMessage',\n        );\n\n        return {\n            bytes: toB64(bytes),\n            signature,\n        };\n    }\n\n    toIotaAddress(): string {\n        return this.getPublicKey().toIotaAddress();\n    }\n\n    /**\n     * Get the key scheme of the keypair: Secp256k1 or ED25519\n     */\n    abstract getKeyScheme(): SignatureScheme;\n\n    /**\n     * The public key for this keypair\n     */\n    abstract getPublicKey(): PublicKey;\n}\n\nexport abstract class Keypair extends Signer {\n    /**\n     * This returns the Bech32 secret key string for this keypair.\n     */\n    abstract getSecretKey(): string;\n}\n\n/**\n * This returns an ParsedKeypair object based by validating the\n * 33-byte Bech32 encoded string starting with `iotaprivkey`, and\n * parse out the signature scheme and the private key in bytes.\n */\nexport function decodeIotaPrivateKey(value: string): ParsedKeypair {\n    const { prefix, words } = bech32.decode(value);\n    if (prefix !== IOTA_PRIVATE_KEY_PREFIX) {\n        throw new Error('invalid private key prefix');\n    }\n    const extendedSecretKey = new Uint8Array(bech32.fromWords(words));\n    const secretKey = extendedSecretKey.slice(1);\n    const signatureScheme =\n        SIGNATURE_FLAG_TO_SCHEME[extendedSecretKey[0] as keyof typeof SIGNATURE_FLAG_TO_SCHEME];\n    return {\n        schema: signatureScheme,\n        secretKey: secretKey,\n    };\n}\n\n/**\n * This returns a Bech32 encoded string starting with `iotaprivkey`,\n * encoding 33-byte `flag || bytes` for the given the 32-byte private\n * key and its signature scheme.\n */\nexport function encodeIotaPrivateKey(bytes: Uint8Array, scheme: SignatureScheme): string {\n    if (bytes.length !== PRIVATE_KEY_SIZE) {\n        throw new Error('Invalid bytes length');\n    }\n    const flag = SIGNATURE_SCHEME_TO_FLAG[scheme];\n    const privKeyBytes = new Uint8Array(bytes.length + 1);\n    privKeyBytes.set([flag]);\n    privKeyBytes.set(bytes, 1);\n    return bech32.encode(IOTA_PRIVATE_KEY_PREFIX, bech32.toWords(privKeyBytes));\n}\n"],
  "mappings": "AAIA,SAAS,KAAK,aAAa;AAC3B,SAAS,eAAe;AACxB,SAAS,cAAc;AAGvB,SAAS,yBAAyB;AAElC,SAAS,0BAA0B,gCAAgC;AAEnE,SAAS,6BAA6B;AAE/B,MAAM,mBAAmB;AACzB,MAAM,0BAA0B;AAChC,MAAM,0BAA0B;AAehC,MAAe,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA,EAMzB,MAAM,eAAe,OAAmB,QAAkD;AACtF,UAAM,gBAAgB,kBAAkB,QAAQ,KAAK;AACrD,UAAM,SAAS,QAAQ,eAAe,EAAE,OAAO,GAAG,CAAC;AAEnD,UAAM,YAAY,sBAAsB;AAAA,MACpC,WAAW,MAAM,KAAK,KAAK,MAAM;AAAA,MACjC,iBAAiB,KAAK,aAAa;AAAA,MACnC,WAAW,KAAK,aAAa;AAAA,IACjC,CAAC;AAED,WAAO;AAAA,MACH;AAAA,MACA,OAAO,MAAM,KAAK;AAAA,IACtB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,gBAAgB,OAAmB;AACrC,WAAO,KAAK,eAAe,OAAO,iBAAiB;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,oBAAoB,OAAmB;AACzC,UAAM,EAAE,UAAU,IAAI,MAAM,KAAK;AAAA,MAC7B,IAAI,OAAO,IAAI,GAAG,CAAC,EAAE,UAAU,KAAK,EAAE,QAAQ;AAAA,MAC9C;AAAA,IACJ;AAEA,WAAO;AAAA,MACH,OAAO,MAAM,KAAK;AAAA,MAClB;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,gBAAwB;AACpB,WAAO,KAAK,aAAa,EAAE,cAAc;AAAA,EAC7C;AAWJ;AAEO,MAAe,gBAAgB,OAAO;AAK7C;AAOO,SAAS,qBAAqB,OAA8B;AAC/D,QAAM,EAAE,QAAQ,MAAM,IAAI,OAAO,OAAO,KAAK;AAC7C,MAAI,WAAW,yBAAyB;AACpC,UAAM,IAAI,MAAM,4BAA4B;AAAA,EAChD;AACA,QAAM,oBAAoB,IAAI,WAAW,OAAO,UAAU,KAAK,CAAC;AAChE,QAAM,YAAY,kBAAkB,MAAM,CAAC;AAC3C,QAAM,kBACF,yBAAyB,kBAAkB,CAAC,CAA0C;AAC1F,SAAO;AAAA,IACH,QAAQ;AAAA,IACR;AAAA,EACJ;AACJ;AAOO,SAAS,qBAAqB,OAAmB,QAAiC;AACrF,MAAI,MAAM,WAAW,kBAAkB;AACnC,UAAM,IAAI,MAAM,sBAAsB;AAAA,EAC1C;AACA,QAAM,OAAO,yBAAyB,MAAM;AAC5C,QAAM,eAAe,IAAI,WAAW,MAAM,SAAS,CAAC;AACpD,eAAa,IAAI,CAAC,IAAI,CAAC;AACvB,eAAa,IAAI,OAAO,CAAC;AACzB,SAAO,OAAO,OAAO,yBAAyB,OAAO,QAAQ,YAAY,CAAC;AAC9E;",
  "names": []
}
