{
  "version": 3,
  "sources": ["../../../src/transactions/TransactionData.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB58 } from '@iota/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type {\n    Argument,\n    CallArg,\n    Command,\n    GasData,\n    TransactionExpiration,\n} from './data/internal.js';\nimport { TransactionData } from './data/internal.js';\nimport { transactionDataFromV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV2 } from './data/v2.js';\nimport { hashTypedData } from './hash.js';\n\nfunction prepareIotaAddress(address: string) {\n    return normalizeIotaAddress(address).replace('0x', '');\n}\n\nexport class TransactionDataBuilder implements TransactionData {\n    static fromKindBytes(bytes: Uint8Array) {\n        const kind = bcs.TransactionKind.parse(bytes);\n\n        const programmableTx = kind.ProgrammableTransaction;\n        if (!programmableTx) {\n            throw new Error('Unable to deserialize from bytes.');\n        }\n\n        return TransactionDataBuilder.restore({\n            version: 2,\n            sender: null,\n            expiration: null,\n            gasData: {\n                budget: null,\n                owner: null,\n                payment: null,\n                price: null,\n            },\n            inputs: programmableTx.inputs,\n            commands: programmableTx.commands,\n        });\n    }\n\n    static fromBytes(bytes: Uint8Array) {\n        const rawData = bcs.TransactionData.parse(bytes);\n        const data = rawData?.V1;\n        const programmableTx = data.kind.ProgrammableTransaction;\n\n        if (!data || !programmableTx) {\n            throw new Error('Unable to deserialize from bytes.');\n        }\n\n        return TransactionDataBuilder.restore({\n            version: 2,\n            sender: data.sender,\n            expiration: data.expiration,\n            gasData: data.gasData,\n            inputs: programmableTx.inputs,\n            commands: programmableTx.commands,\n        });\n    }\n\n    static restore(\n        data:\n            | InferInput<typeof SerializedTransactionDataV2>\n            | InferInput<typeof SerializedTransactionDataV1>,\n    ) {\n        if (data.version === 2) {\n            return new TransactionDataBuilder(parse(TransactionData, data));\n        } else {\n            return new TransactionDataBuilder(parse(TransactionData, transactionDataFromV1(data)));\n        }\n    }\n\n    /**\n     * Generate transaction digest.\n     *\n     * @param bytes BCS serialized transaction data\n     * @returns transaction digest.\n     */\n    static getDigestFromBytes(bytes: Uint8Array) {\n        const hash = hashTypedData('TransactionData', bytes);\n        return toB58(hash);\n    }\n\n    // @deprecated use gasData instead\n    get gasConfig() {\n        return this.gasData;\n    }\n    // @deprecated use gasData instead\n    set gasConfig(value) {\n        this.gasData = value;\n    }\n\n    version = 2 as const;\n    sender: string | null;\n    expiration: TransactionExpiration | null;\n    gasData: GasData;\n    inputs: CallArg[];\n    commands: Command[];\n\n    constructor(clone?: TransactionData) {\n        this.sender = clone?.sender ?? null;\n        this.expiration = clone?.expiration ?? null;\n        this.inputs = clone?.inputs ?? [];\n        this.commands = clone?.commands ?? [];\n        this.gasData = clone?.gasData ?? {\n            budget: null,\n            price: null,\n            owner: null,\n            payment: null,\n        };\n    }\n\n    build({\n        maxSizeBytes = Infinity,\n        overrides,\n        onlyTransactionKind,\n    }: {\n        maxSizeBytes?: number;\n        overrides?: {\n            expiration?: TransactionExpiration;\n            sender?: string;\n            // @deprecated use gasData instead\n            gasConfig?: Partial<GasData>;\n            gasData?: Partial<GasData>;\n        };\n        onlyTransactionKind?: boolean;\n    } = {}) {\n        // TODO validate that inputs and intents are actually resolved\n        const inputs = this.inputs as (typeof bcs.CallArg.$inferInput)[];\n        const commands = this.commands as Extract<\n            Command<Exclude<Argument, { IntentResult: unknown } | { NestedIntentResult: unknown }>>,\n            { Upgrade: unknown }\n        >[];\n\n        const kind = {\n            ProgrammableTransaction: {\n                inputs,\n                commands,\n            },\n        };\n\n        if (onlyTransactionKind) {\n            return bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n        }\n\n        const expiration = overrides?.expiration ?? this.expiration;\n        const sender = overrides?.sender ?? this.sender;\n        const gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n\n        if (!sender) {\n            throw new Error('Missing transaction sender');\n        }\n\n        if (!gasData.budget) {\n            throw new Error('Missing gas budget');\n        }\n\n        if (!gasData.payment) {\n            throw new Error('Missing gas payment');\n        }\n\n        if (!gasData.price) {\n            throw new Error('Missing gas price');\n        }\n\n        const transactionData = {\n            sender: prepareIotaAddress(sender),\n            expiration: expiration ? expiration : { None: true },\n            gasData: {\n                payment: gasData.payment,\n                owner: prepareIotaAddress(this.gasData.owner ?? sender),\n                price: BigInt(gasData.price),\n                budget: BigInt(gasData.budget),\n            },\n            kind: {\n                ProgrammableTransaction: {\n                    inputs,\n                    commands,\n                },\n            },\n        };\n\n        return bcs.TransactionData.serialize(\n            { V1: transactionData },\n            { maxSize: maxSizeBytes },\n        ).toBytes();\n    }\n\n    addInput<T extends 'object' | 'pure'>(type: T, arg: CallArg) {\n        const index = this.inputs.length;\n        this.inputs.push(arg);\n        return { Input: index, type, $kind: 'Input' as const };\n    }\n\n    getInputUses(index: number, fn: (arg: Argument, command: Command) => void) {\n        this.mapArguments((arg, command) => {\n            if (arg.$kind === 'Input' && arg.Input === index) {\n                fn(arg, command);\n            }\n\n            return arg;\n        });\n    }\n\n    mapArguments(fn: (arg: Argument, command: Command) => Argument) {\n        for (const command of this.commands) {\n            switch (command.$kind) {\n                case 'MoveCall':\n                    command.MoveCall.arguments = command.MoveCall.arguments.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'TransferObjects':\n                    command.TransferObjects.objects = command.TransferObjects.objects.map((arg) =>\n                        fn(arg, command),\n                    );\n                    command.TransferObjects.address = fn(command.TransferObjects.address, command);\n                    break;\n                case 'SplitCoins':\n                    command.SplitCoins.coin = fn(command.SplitCoins.coin, command);\n                    command.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'MergeCoins':\n                    command.MergeCoins.destination = fn(command.MergeCoins.destination, command);\n                    command.MergeCoins.sources = command.MergeCoins.sources.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'MakeMoveVec':\n                    command.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'Upgrade':\n                    command.Upgrade.ticket = fn(command.Upgrade.ticket, command);\n                    break;\n                case '$Intent':\n                    const inputs = command.$Intent.inputs;\n                    command.$Intent.inputs = {};\n\n                    for (const [key, value] of Object.entries(inputs)) {\n                        command.$Intent.inputs[key] = Array.isArray(value)\n                            ? value.map((arg) => fn(arg, command))\n                            : fn(value, command);\n                    }\n\n                    break;\n                case 'Publish':\n                    break;\n                default:\n                    throw new Error(\n                        `Unexpected transaction kind: ${(command as { $kind: unknown }).$kind}`,\n                    );\n            }\n        }\n    }\n\n    replaceCommand(index: number, replacement: Command | Command[]) {\n        if (!Array.isArray(replacement)) {\n            this.commands[index] = replacement;\n            return;\n        }\n\n        const sizeDiff = replacement.length - 1;\n        this.commands.splice(index, 1, ...replacement);\n\n        if (sizeDiff !== 0) {\n            this.mapArguments((arg) => {\n                switch (arg.$kind) {\n                    case 'Result':\n                        if (arg.Result > index) {\n                            arg.Result += sizeDiff;\n                        }\n                        break;\n\n                    case 'NestedResult':\n                        if (arg.NestedResult[0] > index) {\n                            arg.NestedResult[0] += sizeDiff;\n                        }\n                        break;\n                }\n                return arg;\n            });\n        }\n    }\n\n    getDigest() {\n        const bytes = this.build({ onlyTransactionKind: false });\n        return TransactionDataBuilder.getDigestFromBytes(bytes);\n    }\n\n    snapshot(): TransactionData {\n        return parse(TransactionData, this);\n    }\n}\n"],
  "mappings": "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",
  "names": ["import_bcs"]
}
