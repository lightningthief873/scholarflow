import { IntentMessage } from './bcs.js';
export type { TypeTag } from './types.js';
export { TypeTagSerializer } from './type-tag-serializer.js';
export { BcsType, type BcsTypeOptions } from '@iota/bcs';
declare const iotaBcs: {
    U8: BcsType<number, number>;
    U16: BcsType<number, number>;
    U32: BcsType<number, number>;
    U64: BcsType<string, string | number | bigint>;
    U128: BcsType<string, string | number | bigint>;
    U256: BcsType<string, string | number | bigint>;
    ULEB128: BcsType<number, number>;
    Bool: BcsType<boolean, boolean>;
    String: BcsType<string, string>;
    Address: any;
    AppId: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    Argument: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    CallArg: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    CompressedSignature: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    GasData: BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    Intent: BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    IntentMessage: typeof IntentMessage;
    IntentScope: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    IntentVersion: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    MultiSig: BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    MultiSigPkMap: BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    MultiSigPublicKey: BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    ObjectArg: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    ObjectDigest: any;
    Owner: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    ProgrammableMoveCall: BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    ProgrammableTransaction: BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    PublicKey: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    SenderSignedData: BcsType<T_2[], Iterable<Input> & {
        length: number;
    }>;
    SenderSignedTransaction: BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    SharedObjectRef: BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    StructTag: BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    IotaObjectRef: BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    Command: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    TransactionData: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    TransactionDataV1: BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    TransactionExpiration: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    TransactionKind: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    TypeTag: any;
    TransactionEffects: BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    PasskeyAuthenticator: BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    u8(options?: any): BcsType<number, number>;
    u16(options?: any): BcsType<number, number>;
    u32(options?: any): BcsType<number, number>;
    u64(options?: any): BcsType<string, string | number | bigint>;
    u128(options?: any): BcsType<string, string | number | bigint>;
    u256(options?: any): BcsType<string, string | number | bigint>;
    bool(options?: any): BcsType<boolean, boolean>;
    uleb128(options?: any): BcsType<number, number>;
    bytes<T_3 extends number>(size: T_3, options?: any): BcsType<Uint8Array, Uint8Array>;
    byteVector(options?: any): BcsType<Uint8Array, Iterable<number>>;
    string(options?: any): BcsType<string, string>;
    fixedArray<T_3, Input_1>(size: number, type: BcsType<T_3, Input_1>, options?: any): BcsType<T_3[], Iterable<Input_1> & {
        length: number;
    }>;
    option<T_3, Input_1>(type: BcsType<T_3, Input_1>): BcsType<T_3 | null, Input_1 | null | undefined>;
    vector<T_2, Input>(type: BcsType<T_2, Input>, options?: any): BcsType<T_2[], Iterable<Input> & {
        length: number;
    }>;
    tuple<const Types extends readonly BcsType<any>[]>(types: Types, options?: any): BcsType<{ -readonly [K_3 in keyof Types]: Types[K_3] extends BcsType<infer T_3, any> ? T_3 : never; }, { [K_1_2 in keyof Types]: Types[K_1_2] extends BcsType<any, infer T_1_1> ? T_1_1 : never; }>;
    struct<T_1 extends Record<string, BcsType<any>>>(name: string, fields: T_1, options?: Omit<BcsTypeOptions<{ [K_3 in keyof T_1]: T_1[K_3] extends BcsType<infer U_3, any> ? U_3 : never; }, { [K_4 in keyof T_1]: T_1[K_4] extends BcsType<any, infer U_4> ? U_4 : never; }>, "name">): BcsType<{ [K_2 in keyof T_1]: T_1[K_2] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_1_1 in keyof T_1]: T_1[K_1_1] extends BcsType<any, infer U_1_1> ? U_1_1 : never; }>;
    enum<T extends Record<string, BcsType<any> | null>>(name: string, values: T, options?: Omit<BcsTypeOptions<import("@iota/bcs").EnumOutputShape<{ [K_3 in keyof T]: T[K_3] extends BcsType<infer U_3, any> ? U_3 : true; }>, import("@iota/bcs").EnumInputShape<{ [K_4 in keyof T]: T[K_4] extends BcsType<any, infer U_4> ? U_4 : boolean | object | null; }>>, "name">): BcsType<import("@iota/bcs").EnumOutputShape<{ [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true; }>, import("@iota/bcs").EnumInputShape<{ [K_1 in keyof T]: T[K_1] extends BcsType<any, infer U_1> ? U_1 : boolean | object | null; }>>;
    map<K_3, V, InputK = K_3, InputV = V>(keyType: BcsType<K_3, InputK>, valueType: BcsType<V, InputV>): BcsType<Map<K_3, V>, Map<InputK, InputV>>;
    lazy<T_3 extends BcsType<any>>(cb: () => T_3): T_3;
};
export { iotaBcs as bcs };
