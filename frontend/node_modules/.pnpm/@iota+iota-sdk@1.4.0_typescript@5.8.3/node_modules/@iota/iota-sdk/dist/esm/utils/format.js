import { isValidIotaAddress, isValidIotaObjectId, IOTA_ADDRESS_LENGTH } from "./iota-types.js";
const ELLIPSIS = "\u2026";
function formatAddress(address) {
  if (address.length <= 6) {
    return address;
  }
  const offset = address.startsWith("0x") ? 2 : 0;
  return `0x${address.slice(offset, offset + 4)}${ELLIPSIS}${address.slice(-4)}`;
}
function formatDigest(digest) {
  return `${digest.slice(0, 10)}${ELLIPSIS}`;
}
function formatType(type) {
  const objectAddressPattern = new RegExp(`0x[a-fA-F0-9]{${IOTA_ADDRESS_LENGTH * 2}}`, "g");
  const matches = type.match(objectAddressPattern) ?? [];
  for (const match of matches) {
    if (isValidIotaAddress(match) || isValidIotaObjectId(match)) {
      type = type.replace(match, formatAddress(match));
    }
  }
  return type;
}
const ADDRESS_TRIM_MAX_LENGTH = 8;
function trimAddress(address) {
  const addr = address.toLowerCase().replace(/^0x/, "");
  const shortened = addr.replace(/^0+/, "") || "0";
  return `0x${shortened}`;
}
function trimOrFormatAddress(address) {
  if (address.length <= 6) {
    return address;
  }
  const trimmedAddress = trimAddress(address);
  if (trimmedAddress.length <= ADDRESS_TRIM_MAX_LENGTH) {
    return trimmedAddress;
  }
  return formatAddress(address);
}
export {
  formatAddress,
  formatDigest,
  formatType,
  trimAddress,
  trimOrFormatAddress
};
//# sourceMappingURL=format.js.map
