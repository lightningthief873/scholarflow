{
  "version": 3,
  "sources": ["../../../../src/transactions/intents/CoinWithBalance.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { InferInput } from 'valibot';\nimport { bigint, object, parse, string } from 'valibot';\n\nimport { bcs } from '../../bcs/index.js';\nimport type { CoinStruct, IotaClient } from '../../client/index.js';\nimport { normalizeStructTag } from '../../utils/iota-types.js';\nimport { Commands } from '../Commands.js';\nimport type { Argument } from '../data/internal.js';\nimport { Inputs } from '../Inputs.js';\nimport type { BuildTransactionOptions } from '../json-rpc-resolver.js';\nimport { getClient } from '../json-rpc-resolver.js';\nimport type { Transaction } from '../Transaction.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\n\nconst COIN_WITH_BALANCE = 'CoinWithBalance';\nconst IOTA_TYPE = normalizeStructTag('0x2::iota::IOTA');\n\nexport function coinWithBalance({\n    type = IOTA_TYPE,\n    balance,\n    useGasCoin = true,\n}: {\n    balance: bigint | number;\n    type?: string;\n    useGasCoin?: boolean;\n}) {\n    return (tx: Transaction) => {\n        tx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);\n        const coinType = type === 'gas' ? type : normalizeStructTag(type);\n\n        return tx.add(\n            Commands.Intent({\n                name: COIN_WITH_BALANCE,\n                inputs: {},\n                data: {\n                    type: coinType === IOTA_TYPE && useGasCoin ? 'gas' : coinType,\n                    balance: BigInt(balance),\n                } satisfies InferInput<typeof CoinWithBalanceData>,\n            }),\n        );\n    };\n}\n\nconst CoinWithBalanceData = object({\n    type: string(),\n    balance: bigint(),\n});\n\nasync function resolveCoinBalance(\n    transactionData: TransactionDataBuilder,\n    buildOptions: BuildTransactionOptions,\n    next: () => Promise<void>,\n) {\n    const coinTypes = new Set<string>();\n    const totalByType = new Map<string, bigint>();\n\n    if (!transactionData.sender) {\n        throw new Error('Sender must be set to resolve CoinWithBalance');\n    }\n\n    for (const command of transactionData.commands) {\n        if (command.$kind === '$Intent' && command.$Intent.name === COIN_WITH_BALANCE) {\n            const { type, balance } = parse(CoinWithBalanceData, command.$Intent.data);\n\n            if (type !== 'gas') {\n                coinTypes.add(type);\n            }\n\n            totalByType.set(type, (totalByType.get(type) ?? 0n) + balance);\n        }\n    }\n    const usedIds = new Set<string>();\n\n    for (const input of transactionData.inputs) {\n        if (input.Object?.ImmOrOwnedObject) {\n            usedIds.add(input.Object.ImmOrOwnedObject.objectId);\n        }\n        if (input.UnresolvedObject?.objectId) {\n            usedIds.add(input.UnresolvedObject.objectId);\n        }\n    }\n\n    const coinsByType = new Map<string, CoinStruct[]>();\n    const client = getClient(buildOptions);\n    await Promise.all(\n        [...coinTypes].map(async (coinType) => {\n            coinsByType.set(\n                coinType,\n                await getCoinsOfType({\n                    coinType,\n                    balance: totalByType.get(coinType)!,\n                    client,\n                    owner: transactionData.sender!,\n                    usedIds,\n                }),\n            );\n        }),\n    );\n\n    const mergedCoins = new Map<string, Argument>();\n\n    mergedCoins.set('gas', { $kind: 'GasCoin', GasCoin: true });\n\n    for (const [index, transaction] of transactionData.commands.entries()) {\n        if (transaction.$kind !== '$Intent' || transaction.$Intent.name !== COIN_WITH_BALANCE) {\n            continue;\n        }\n\n        const { type, balance } = transaction.$Intent.data as {\n            type: string;\n            balance: bigint;\n        };\n\n        const commands = [];\n\n        if (!mergedCoins.has(type)) {\n            const [first, ...rest] = coinsByType.get(type)!.map((coin) =>\n                transactionData.addInput(\n                    'object',\n                    Inputs.ObjectRef({\n                        objectId: coin.coinObjectId,\n                        digest: coin.digest,\n                        version: coin.version,\n                    }),\n                ),\n            );\n\n            if (rest.length > 0) {\n                commands.push(Commands.MergeCoins(first, rest));\n            }\n\n            mergedCoins.set(type, first);\n        }\n\n        commands.push(\n            Commands.SplitCoins(mergedCoins.get(type)!, [\n                transactionData.addInput('pure', Inputs.Pure(bcs.u64().serialize(balance))),\n            ]),\n        );\n\n        transactionData.replaceCommand(index, commands);\n\n        transactionData.mapArguments((arg) => {\n            if (arg.$kind === 'Result' && arg.Result === index) {\n                return {\n                    $kind: 'NestedResult',\n                    NestedResult: [index + commands.length - 1, 0],\n                };\n            }\n\n            return arg;\n        });\n    }\n\n    return next();\n}\n\nasync function getCoinsOfType({\n    coinType,\n    balance,\n    client,\n    owner,\n    usedIds,\n}: {\n    coinType: string;\n    balance: bigint;\n    client: IotaClient;\n    owner: string;\n    usedIds: Set<string>;\n}): Promise<CoinStruct[]> {\n    let remainingBalance = balance;\n    const coins: CoinStruct[] = [];\n\n    return loadMoreCoins();\n\n    async function loadMoreCoins(cursor: string | null = null): Promise<CoinStruct[]> {\n        const { data, hasNextPage, nextCursor } = await client.getCoins({\n            owner,\n            coinType,\n            cursor,\n        });\n\n        const sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));\n\n        for (const coin of sortedCoins) {\n            if (usedIds.has(coin.coinObjectId)) {\n                continue;\n            }\n\n            const coinBalance = BigInt(coin.balance);\n\n            coins.push(coin);\n            remainingBalance -= coinBalance;\n\n            if (remainingBalance <= 0) {\n                return coins;\n            }\n        }\n\n        if (hasNextPage) {\n            return loadMoreCoins(nextCursor);\n        }\n\n        throw new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
