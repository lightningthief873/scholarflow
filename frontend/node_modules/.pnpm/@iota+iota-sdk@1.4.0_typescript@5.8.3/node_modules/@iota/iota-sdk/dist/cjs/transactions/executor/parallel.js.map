{
  "version": 3,
  "sources": ["../../../../src/transactions/executor/parallel.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@iota/bcs';\n\nimport { bcs } from '../../bcs/index.js';\nimport type { IotaObjectRef } from '../../bcs/types.js';\nimport type { IotaClient, IotaTransactionBlockResponseOptions } from '../../client/index.js';\nimport type { Signer } from '../../cryptography/index.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { Transaction } from '../Transaction.js';\nimport { TransactionDataBuilder } from '../TransactionData.js';\nimport { CachingTransactionExecutor } from './caching.js';\nimport { ParallelQueue, SerialQueue } from './queue.js';\nimport { getGasCoinFromEffects } from './serial.js';\n\nconst PARALLEL_EXECUTOR_DEFAULTS = {\n    coinBatchSize: 20,\n    initialCoinBalance: 200_000_000n,\n    minimumCoinBalance: 50_000_000n,\n    maxPoolSize: 50,\n    epochBoundaryWindow: 1_000,\n} satisfies Omit<ParallelTransactionExecutorOptions, 'signer' | 'client'>;\nexport interface ParallelTransactionExecutorOptions extends Omit<ObjectCacheOptions, 'address'> {\n    client: IotaClient;\n    signer: Signer;\n    /** The number of coins to create in a batch when refilling the gas pool */\n    coinBatchSize?: number;\n    /** The initial balance of each coin created for the gas pool */\n    initialCoinBalance?: bigint;\n    /** The minimum balance of a coin that can be reused for future transactions.  If the gasCoin is below this value, it will be used when refilling the gasPool */\n    minimumCoinBalance?: bigint;\n    /** The gasBudget to use if the transaction has not defined it's own gasBudget, defaults to `minimumCoinBalance` */\n    defaultGasBudget?: bigint;\n    /**\n     * Time to wait before/after the expected epoch boundary before re-fetching the gas pool (in milliseconds).\n     * Building transactions will be paused for up to 2x this duration around each epoch boundary to ensure the\n     * gas price is up-to-date for the next epoch.\n     * */\n    epochBoundaryWindow?: number;\n    /** The maximum number of transactions that can be execute in parallel, this also determines the maximum number of gas coins that will be created */\n    maxPoolSize?: number;\n    /** An initial list of coins used to fund the gas pool, uses all owned IOTA coins by default */\n    sourceCoins?: string[];\n}\n\ninterface CoinWithBalance {\n    id: string;\n    version: string;\n    digest: string;\n    balance: bigint;\n}\nexport class ParallelTransactionExecutor {\n    #signer: Signer;\n    #client: IotaClient;\n    #coinBatchSize: number;\n    #initialCoinBalance: bigint;\n    #minimumCoinBalance: bigint;\n    #epochBoundaryWindow: number;\n    #defaultGasBudget: bigint;\n    #maxPoolSize: number;\n    #sourceCoins: Map<string, IotaObjectRef | null> | null;\n    #coinPool: CoinWithBalance[] = [];\n    #cache: CachingTransactionExecutor;\n    #objectIdQueues = new Map<string, (() => void)[]>();\n    #buildQueue = new SerialQueue();\n    #executeQueue: ParallelQueue;\n    #lastDigest: string | null = null;\n    #cacheLock: Promise<void> | null = null;\n    #pendingTransactions = 0;\n    #gasPrice: null | {\n        price: bigint;\n        expiration: number;\n    } = null;\n\n    constructor(options: ParallelTransactionExecutorOptions) {\n        this.#signer = options.signer;\n        this.#client = options.client;\n        this.#coinBatchSize = options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize;\n        this.#initialCoinBalance =\n            options.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance;\n        this.#minimumCoinBalance =\n            options.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance;\n        this.#defaultGasBudget = options.defaultGasBudget ?? this.#minimumCoinBalance;\n        this.#epochBoundaryWindow =\n            options.epochBoundaryWindow ?? PARALLEL_EXECUTOR_DEFAULTS.epochBoundaryWindow;\n        this.#maxPoolSize = options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize;\n        this.#cache = new CachingTransactionExecutor({\n            client: options.client,\n            cache: options.cache,\n        });\n        this.#executeQueue = new ParallelQueue(this.#maxPoolSize);\n        this.#sourceCoins = options.sourceCoins\n            ? new Map(options.sourceCoins.map((id) => [id, null]))\n            : null;\n    }\n\n    resetCache() {\n        this.#gasPrice = null;\n        return this.#updateCache(() => this.#cache.reset());\n    }\n\n    async waitForLastTransaction() {\n        await this.#updateCache(() => this.#waitForLastDigest());\n    }\n\n    async executeTransaction(\n        transaction: Transaction,\n        options?: IotaTransactionBlockResponseOptions,\n    ) {\n        const { promise, resolve, reject } = promiseWithResolvers<{\n            digest: string;\n            effects: string;\n        }>();\n        const usedObjects = await this.#getUsedObjects(transaction);\n\n        const execute = () => {\n            this.#executeQueue.runTask(() => {\n                const promise = this.#execute(transaction, usedObjects, options);\n\n                return promise.then(resolve, reject);\n            });\n        };\n\n        const conflicts = new Set<string>();\n\n        usedObjects.forEach((objectId) => {\n            const queue = this.#objectIdQueues.get(objectId);\n            if (queue) {\n                conflicts.add(objectId);\n                this.#objectIdQueues.get(objectId)!.push(() => {\n                    conflicts.delete(objectId);\n                    if (conflicts.size === 0) {\n                        execute();\n                    }\n                });\n            } else {\n                this.#objectIdQueues.set(objectId, []);\n            }\n        });\n\n        if (conflicts.size === 0) {\n            execute();\n        }\n\n        return promise;\n    }\n\n    async #getUsedObjects(transaction: Transaction) {\n        const usedObjects = new Set<string>();\n        let serialized = false;\n\n        transaction.addSerializationPlugin(async (blockData, _options, next) => {\n            await next();\n\n            if (serialized) {\n                return;\n            }\n            serialized = true;\n\n            blockData.inputs.forEach((input) => {\n                if (input.Object?.ImmOrOwnedObject?.objectId) {\n                    usedObjects.add(input.Object.ImmOrOwnedObject.objectId);\n                } else if (input.Object?.Receiving?.objectId) {\n                    usedObjects.add(input.Object.Receiving.objectId);\n                } else if (\n                    input.UnresolvedObject?.objectId &&\n                    !input.UnresolvedObject.initialSharedVersion\n                ) {\n                    usedObjects.add(input.UnresolvedObject.objectId);\n                }\n            });\n        });\n\n        await transaction.prepareForSerialization({ client: this.#client });\n\n        return usedObjects;\n    }\n\n    async #execute(\n        transaction: Transaction,\n        usedObjects: Set<string>,\n        options?: IotaTransactionBlockResponseOptions,\n    ) {\n        let gasCoin!: CoinWithBalance;\n        try {\n            transaction.setSenderIfNotSet(this.#signer.toIotaAddress());\n\n            await this.#buildQueue.runTask(async () => {\n                const data = transaction.getData();\n\n                if (!data.gasData.price) {\n                    transaction.setGasPrice(await this.#getGasPrice());\n                }\n\n                transaction.setGasBudgetIfNotSet(this.#defaultGasBudget);\n\n                await this.#updateCache();\n                gasCoin = await this.#getGasCoin();\n                this.#pendingTransactions++;\n                transaction.setGasPayment([\n                    {\n                        objectId: gasCoin.id,\n                        version: gasCoin.version,\n                        digest: gasCoin.digest,\n                    },\n                ]);\n\n                // Resolve cached references\n                await this.#cache.buildTransaction({ transaction, onlyTransactionKind: true });\n            });\n\n            const bytes = await transaction.build({ client: this.#client });\n\n            const { signature } = await this.#signer.signTransaction(bytes);\n\n            const results = await this.#cache.executeTransaction({\n                transaction: bytes,\n                signature,\n                options: {\n                    ...options,\n                    showEffects: true,\n                },\n            });\n\n            const effectsBytes = Uint8Array.from(results.rawEffects!);\n            const effects = bcs.TransactionEffects.parse(effectsBytes);\n\n            const gasResult = getGasCoinFromEffects(effects);\n            const gasUsed = effects.V1?.gasUsed;\n\n            if (gasCoin && gasUsed && gasResult.owner === this.#signer.toIotaAddress()) {\n                const totalUsed =\n                    BigInt(gasUsed.computationCost) +\n                    BigInt(gasUsed.storageCost) +\n                    BigInt(gasUsed.storageCost) -\n                    BigInt(gasUsed.storageRebate);\n\n                let usesGasCoin = false;\n                new TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {\n                    if (arg.$kind === 'GasCoin') {\n                        usesGasCoin = true;\n                    }\n\n                    return arg;\n                });\n\n                if (!usesGasCoin && gasCoin.balance >= this.#minimumCoinBalance) {\n                    this.#coinPool.push({\n                        id: gasResult.ref.objectId,\n                        version: gasResult.ref.version,\n                        digest: gasResult.ref.digest,\n                        balance: gasCoin.balance - totalUsed,\n                    });\n                } else {\n                    if (!this.#sourceCoins) {\n                        this.#sourceCoins = new Map();\n                    }\n                    this.#sourceCoins.set(gasResult.ref.objectId, gasResult.ref);\n                }\n            }\n\n            this.#lastDigest = results.digest;\n\n            return {\n                digest: results.digest,\n                effects: toB64(effectsBytes),\n            };\n        } catch (error) {\n            if (gasCoin) {\n                if (!this.#sourceCoins) {\n                    this.#sourceCoins = new Map();\n                }\n\n                this.#sourceCoins.set(gasCoin.id, null);\n            }\n\n            await this.#updateCache(async () => {\n                await Promise.all([\n                    this.#cache.cache.deleteObjects([...usedObjects]),\n                    this.#waitForLastDigest(),\n                ]);\n            });\n\n            throw error;\n        } finally {\n            usedObjects.forEach((objectId) => {\n                const queue = this.#objectIdQueues.get(objectId);\n                if (queue && queue.length > 0) {\n                    queue.shift()!();\n                } else if (queue) {\n                    this.#objectIdQueues.delete(objectId);\n                }\n            });\n            this.#pendingTransactions--;\n        }\n    }\n\n    /** Helper for synchronizing cache updates, by ensuring only one update happens at a time.  This can also be used to wait for any pending cache updates  */\n    async #updateCache(fn?: () => Promise<void>) {\n        if (this.#cacheLock) {\n            await this.#cacheLock;\n        }\n\n        this.#cacheLock =\n            fn?.().then(\n                () => {\n                    this.#cacheLock = null;\n                },\n                () => {},\n            ) ?? null;\n    }\n\n    async #waitForLastDigest() {\n        const digest = this.#lastDigest;\n        if (digest) {\n            this.#lastDigest = null;\n            await this.#client.waitForTransaction({ digest });\n        }\n    }\n\n    async #getGasCoin() {\n        if (this.#coinPool.length === 0 && this.#pendingTransactions <= this.#maxPoolSize) {\n            await this.#refillCoinPool();\n        }\n\n        if (this.#coinPool.length === 0) {\n            throw new Error('No coins available');\n        }\n\n        const coin = this.#coinPool.shift()!;\n        return coin;\n    }\n\n    async #getGasPrice(): Promise<bigint> {\n        const remaining = this.#gasPrice\n            ? this.#gasPrice.expiration - this.#epochBoundaryWindow - Date.now()\n            : 0;\n\n        if (remaining > 0) {\n            return this.#gasPrice!.price;\n        }\n\n        if (this.#gasPrice) {\n            const timeToNextEpoch = Math.max(\n                this.#gasPrice.expiration + this.#epochBoundaryWindow - Date.now(),\n                1_000,\n            );\n\n            await new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));\n        }\n\n        const state = await this.#client.getLatestIotaSystemState();\n\n        this.#gasPrice = {\n            price: BigInt(state.referenceGasPrice),\n            expiration:\n                Number.parseInt(state.epochStartTimestampMs, 10) +\n                Number.parseInt(state.epochDurationMs, 10),\n        };\n\n        return this.#getGasPrice();\n    }\n\n    async #refillCoinPool() {\n        const batchSize = Math.min(\n            this.#coinBatchSize,\n            this.#maxPoolSize - (this.#coinPool.length + this.#pendingTransactions) + 1,\n        );\n\n        if (batchSize === 0) {\n            return;\n        }\n\n        const txb = new Transaction();\n        const address = this.#signer.toIotaAddress();\n        txb.setSender(address);\n\n        if (this.#sourceCoins) {\n            const refs = [];\n            const ids = [];\n            for (const [id, ref] of this.#sourceCoins) {\n                if (ref) {\n                    refs.push(ref);\n                } else {\n                    ids.push(id);\n                }\n            }\n\n            if (ids.length > 0) {\n                const coins = await this.#client.multiGetObjects({\n                    ids,\n                });\n                refs.push(\n                    ...coins\n                        .filter(\n                            (coin): coin is typeof coin & { data: object } => coin.data !== null,\n                        )\n                        .map(({ data }) => ({\n                            objectId: data.objectId,\n                            version: data.version,\n                            digest: data.digest,\n                        })),\n                );\n            }\n\n            txb.setGasPayment(refs);\n            this.#sourceCoins = new Map();\n        }\n\n        const amounts = new Array(batchSize).fill(this.#initialCoinBalance);\n        const results = txb.splitCoins(txb.gas, amounts);\n        const coinResults = [];\n        for (let i = 0; i < amounts.length; i++) {\n            coinResults.push(results[i]);\n        }\n        txb.transferObjects(coinResults, address);\n\n        await this.waitForLastTransaction();\n\n        const result = await this.#client.signAndExecuteTransaction({\n            transaction: txb,\n            signer: this.#signer,\n            options: {\n                showRawEffects: true,\n            },\n        });\n\n        const effects = bcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects!));\n        effects.V1?.changedObjects.forEach(([id, { outputState }], i) => {\n            if (i === effects.V1?.gasObjectIndex || !outputState.ObjectWrite) {\n                return;\n            }\n\n            this.#coinPool.push({\n                id,\n                version: effects.V1!.lamportVersion,\n                digest: outputState.ObjectWrite[0],\n                balance: BigInt(this.#initialCoinBalance),\n            });\n        });\n\n        if (!this.#sourceCoins) {\n            this.#sourceCoins = new Map();\n        }\n\n        const gasObject = getGasCoinFromEffects(effects).ref;\n        this.#sourceCoins!.set(gasObject.objectId, gasObject);\n\n        await this.#client.waitForTransaction({ digest: result.digest });\n    }\n}\n\nfunction promiseWithResolvers<T>() {\n    let resolve: (value: T) => void;\n    let reject: (reason: any) => void;\n\n    const promise = new Promise<T>((_resolve, _reject) => {\n        resolve = _resolve;\n        reject = _reject;\n    });\n\n    return { promise, resolve: resolve!, reject: reject! };\n}\n"],
  "mappings": "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",
  "names": ["import_bcs", "promise"]
}
