{
  "version": 3,
  "sources": ["../../../../src/client/types/params.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n *  ######################################\n *  ### DO NOT EDIT THIS FILE DIRECTLY ###\n *  ######################################\n *\n * This file is generated from:\n * /crates/iota-open-rpc/spec/openrpc.json\n */\n\nimport type * as RpcTypes from './generated.js';\nimport type { Transaction } from '../../transactions/index.js';\n/**\n * Runs the transaction in dev-inspect mode. Which allows for nearly any transaction (or Move call)\n * with any arguments. Detailed results are provided, including both the transaction effects and any\n * return values.\n */\nexport interface DevInspectTransactionBlockParams {\n    sender: string;\n    /** BCS encoded TransactionKind(as opposed to TransactionData, which include gasBudget and gasPrice) */\n    transactionBlock: Transaction | Uint8Array | string;\n    /** Gas is not charged, but gas usage is still calculated. Default to use reference gas price */\n    gasPrice?: bigint | number | null | undefined;\n    /** The epoch to perform the call. Will be set from the system state object if not provided */\n    epoch?: string | null | undefined;\n    /** Additional arguments including gas_budget, gas_objects, gas_sponsor and skip_checks. */\n    additionalArgs?: RpcTypes.DevInspectArgs | null | undefined;\n}\n/**\n * Return transaction execution effects including the gas cost summary, while the effects are not\n * committed to the chain.\n */\nexport interface DryRunTransactionBlockParams {\n    transactionBlock: Uint8Array | string;\n}\n/**\n * Execute the transaction and wait for results if desired. Request types: 1. WaitForEffectsCert: waits\n * for TransactionEffectsCert and then return to client. This mode is a proxy for transaction\n * finality. 2. WaitForLocalExecution: waits for TransactionEffectsCert and make sure the node executed\n * the transaction locally before returning the client. The local execution makes sure this node is\n * aware of this transaction when client fires subsequent queries. However if the node fails to execute\n * the transaction locally in a timely manner, a bool type in the response is set to false to indicated\n * the case. request_type is default to be `WaitForEffectsCert` unless options.show_events or\n * options.show_effects is true\n */\nexport interface ExecuteTransactionBlockParams {\n    /** BCS serialized transaction data bytes without its type tag, as base-64 encoded string. */\n    transactionBlock: Uint8Array | string;\n    /**\n     * A list of signatures (`flag || signature || pubkey` bytes, as base-64 encoded string). Signature is\n     * committed to the intent message of the transaction data, as base-64 encoded string.\n     */\n    signature: string | string[];\n    /** options for specifying the content to be returned */\n    options?: RpcTypes.IotaTransactionBlockResponseOptions | null | undefined;\n    /** @deprecated requestType will be ignored by JSON RPC in the future */\n    requestType?: RpcTypes.ExecuteTransactionRequestType | null | undefined;\n}\n/** Return the first four bytes of the chain's genesis checkpoint digest. */\nexport interface GetChainIdentifierParams {}\n/** Return a checkpoint */\nexport interface GetCheckpointParams {\n    /** Checkpoint identifier, can use either checkpoint digest, or checkpoint sequence number as input. */\n    id: RpcTypes.CheckpointId;\n}\n/** Return paginated list of checkpoints */\nexport interface GetCheckpointsParams {\n    /**\n     * An optional paging cursor. If provided, the query will start from the next item after the specified\n     * cursor. Default to start from the first item if not specified.\n     */\n    cursor?: string | null | undefined;\n    /** Maximum item returned per page, default to [QUERY_MAX_RESULT_LIMIT_CHECKPOINTS] if not specified. */\n    limit?: number | null | undefined;\n    /** query result ordering, default to false (ascending order), oldest record first. */\n    descendingOrder: boolean;\n}\n/** Return transaction events. */\nexport interface GetEventsParams {\n    /** the event query criteria. */\n    transactionDigest: string;\n}\n/** Return the sequence number of the latest checkpoint that has been executed */\nexport interface GetLatestCheckpointSequenceNumberParams {}\n/** Return the argument types of a Move function, based on normalized Type. */\nexport interface GetMoveFunctionArgTypesParams {\n    package: string;\n    module: string;\n    function: string;\n}\n/** Return a structured representation of Move function */\nexport interface GetNormalizedMoveFunctionParams {\n    package: string;\n    module: string;\n    function: string;\n}\n/** Return a structured representation of Move module */\nexport interface GetNormalizedMoveModuleParams {\n    package: string;\n    module: string;\n}\n/** Return structured representations of all modules in the given package */\nexport interface GetNormalizedMoveModulesByPackageParams {\n    package: string;\n}\n/** Return a structured representation of Move struct */\nexport interface GetNormalizedMoveStructParams {\n    package: string;\n    module: string;\n    struct: string;\n}\n/** Return the object information for a specified object */\nexport interface GetObjectParams {\n    /** the ID of the queried object */\n    id: string;\n    /** options for specifying the content to be returned */\n    options?: RpcTypes.IotaObjectDataOptions | null | undefined;\n}\n/**\n * Return the protocol config table for the given version number. If the version number is not\n * specified, If none is specified, the node uses the version of the latest epoch it has processed.\n */\nexport interface GetProtocolConfigParams {\n    /**\n     * An optional protocol version specifier. If omitted, the latest protocol config table for the node\n     * will be returned.\n     */\n    version?: string | null | undefined;\n}\n/** Return the total number of transaction blocks known to the server. */\nexport interface GetTotalTransactionBlocksParams {}\n/** Return the transaction response object. */\nexport interface GetTransactionBlockParams {\n    /** the digest of the queried transaction */\n    digest: string;\n    /** options for specifying the content to be returned */\n    options?: RpcTypes.IotaTransactionBlockResponseOptions | null | undefined;\n}\n/** Return the object data for a list of objects */\nexport interface MultiGetObjectsParams {\n    /** the IDs of the queried objects */\n    ids: string[];\n    /** options for specifying the content to be returned */\n    options?: RpcTypes.IotaObjectDataOptions | null | undefined;\n}\n/**\n * Returns an ordered list of transaction responses The method will throw an error if the input\n * contains any duplicate or the input size exceeds QUERY_MAX_RESULT_LIMIT\n */\nexport interface MultiGetTransactionBlocksParams {\n    /** A list of transaction digests. */\n    digests: string[];\n    /** config options to control which fields to fetch */\n    options?: RpcTypes.IotaTransactionBlockResponseOptions | null | undefined;\n}\n/**\n * Note there is no software-level guarantee/SLA that objects with past versions can be retrieved by\n * this API, even if the object and version exists/existed. The result may vary across nodes depending\n * on their pruning policies. Return the object information for a specified version\n */\nexport interface TryGetPastObjectParams {\n    /** the ID of the queried object */\n    id: string;\n    /** the version of the queried object. If None, default to the latest known version */\n    version: number;\n    /** options for specifying the content to be returned */\n    options?: RpcTypes.IotaObjectDataOptions | null | undefined;\n}\n/**\n * Note there is no software-level guarantee/SLA that objects with past versions can be retrieved by\n * this API, even if the object and version exists/existed. The result may vary across nodes depending\n * on their pruning policies. Return the object information for a specified version\n */\nexport interface TryMultiGetPastObjectsParams {\n    /** a vector of object and versions to be queried */\n    pastObjects: RpcTypes.GetPastObjectRequest[];\n    /** options for specifying the content to be returned */\n    options?: RpcTypes.IotaObjectDataOptions | null | undefined;\n}\n/** Return the total coin balance for all coin type, owned by the address owner. */\nexport interface GetAllBalancesParams {\n    /** the owner's IOTA address */\n    owner: string;\n}\n/** Return all Coin objects owned by an address. */\nexport interface GetAllCoinsParams {\n    /** the owner's IOTA address */\n    owner: string;\n    /** optional paging cursor */\n    cursor?: string | null | undefined;\n    /** maximum number of items per page */\n    limit?: number | null | undefined;\n}\n/** Address related metrics. Exclusively served by the indexer. */\nexport interface GetAllEpochAddressMetricsParams {\n    descendingOrder?: boolean | null | undefined;\n}\n/** Return the total coin balance for one coin type, owned by the address owner. */\nexport interface GetBalanceParams {\n    /** the owner's IOTA address */\n    owner: string;\n    /**\n     * optional type names for the coin (e.g., 0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC),\n     * default to 0x2::iota::IOTA if not specified.\n     */\n    coinType?: string | null | undefined;\n}\n/** Address related metrics. Exclusively served by the indexer. */\nexport interface GetCheckpointAddressMetricsParams {\n    checkpoint: string;\n}\n/** Return the circulating supply summary. */\nexport interface GetCirculatingSupplyParams {}\n/** Return metadata (e.g., symbol, decimals) for a coin. */\nexport interface GetCoinMetadataParams {\n    /** type name for the coin (e.g., 0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC) */\n    coinType: string;\n}\n/** Return all Coin<`coin_type`> objects owned by an address. */\nexport interface GetCoinsParams {\n    /** the owner's IOTA address */\n    owner: string;\n    /**\n     * optional type name for the coin (e.g., 0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC),\n     * default to 0x2::iota::IOTA if not specified.\n     */\n    coinType?: string | null | undefined;\n    /** optional paging cursor */\n    cursor?: string | null | undefined;\n    /** maximum number of items per page */\n    limit?: number | null | undefined;\n}\n/** Return the committee information for the asked `epoch`. */\nexport interface GetCommitteeInfoParams {\n    /** The epoch of interest. If None, default to the latest epoch */\n    epoch?: string | null | undefined;\n}\n/** Return current epoch info. Exclusively served by the indexer. */\nexport interface GetCurrentEpochParams {}\n/** Return the dynamic field object information for a specified object */\nexport interface GetDynamicFieldObjectParams {\n    /** The ID of the queried parent object */\n    parentId: string;\n    /** The Name of the dynamic field */\n    name: RpcTypes.DynamicFieldName;\n}\n/** Return the dynamic field object information for a specified object with content options. */\nexport interface GetDynamicFieldObjectV2Params {\n    /** The ID of the queried parent object */\n    parentObjectId: string;\n    /** The Name of the dynamic field */\n    name: RpcTypes.DynamicFieldName;\n    /** Options for specifying the content to be returned */\n    options?: RpcTypes.IotaObjectDataOptions | null | undefined;\n}\n/** Return the list of dynamic field objects owned by an object. */\nexport interface GetDynamicFieldsParams {\n    /** The ID of the parent object */\n    parentId: string;\n    /**\n     * An optional paging cursor. If provided, the query will start from the next item after the specified\n     * cursor. Default to start from the first item if not specified.\n     */\n    cursor?: string | null | undefined;\n    /** Maximum item returned per page, default to [QUERY_MAX_RESULT_LIMIT] if not specified. */\n    limit?: number | null | undefined;\n}\n/** Return a list of epoch metrics, which is a subset of epoch info. Exclusively served by the indexer. */\nexport interface GetEpochMetricsParams {\n    /** Optional paging cursor */\n    cursor?: string | null | undefined;\n    /** Maximum number of items per page */\n    limit?: number | null | undefined;\n    /** Flag to return results in descending order */\n    descendingOrder?: boolean | null | undefined;\n}\n/** Return a list of epoch info. Exclusively served by the indexer. */\nexport interface GetEpochsParams {\n    /** Optional paging cursor */\n    cursor?: string | null | undefined;\n    /** Maximum number of items per page */\n    limit?: number | null | undefined;\n    /** Flag to return results in descending order */\n    descendingOrder?: boolean | null | undefined;\n}\n/** Address related metrics. Exclusively served by the indexer. */\nexport interface GetLatestAddressMetricsParams {}\n/**\n * Return the latest IOTA system state object on networks supporting protocol version `< 5`. These are\n * networks with node software release version `< 0.11`.\n */\nexport interface GetLatestIotaSystemStateParams {}\n/**\n * Return the latest IOTA system state object on networks supporting protocol version `>= 5`. These are\n * networks with node software release version `>= 0.11`.\n */\nexport interface GetLatestIotaSystemStateV2Params {}\n/** Return move call metrics. Exclusively served by the indexer. */\nexport interface GetMoveCallMetricsParams {}\n/** Return Network metrics. Exclusively served by the indexer. */\nexport interface GetNetworkMetricsParams {}\n/**\n * Return the list of objects owned by an address. Note that if the address owns more than\n * `QUERY_MAX_RESULT_LIMIT` objects, the pagination is not accurate, because previous page may have\n * been updated when the next page is fetched. Please use iotax_queryObjects if this is a concern.\n */\nexport type GetOwnedObjectsParams = {\n    /** the owner's IOTA address */\n    owner: string;\n    /**\n     * An optional paging cursor. If provided, the query will start from the next item after the specified\n     * cursor. Default to start from the first item if not specified.\n     */\n    cursor?: string | null | undefined;\n    /** Max number of items returned per page, default to [QUERY_MAX_RESULT_LIMIT] if not specified. */\n    limit?: number | null | undefined;\n} & RpcTypes.IotaObjectResponseQuery;\n/**\n * Returns the participation metrics. Participation is defined as the total number of unique addresses\n * that have delegated stake in the current epoch. Includes both staked and timelocked staked IOTA.\n * Exclusively served by the indexer.\n */\nexport interface GetParticipationMetricsParams {}\n/** Return the reference gas price for the network */\nexport interface GetReferenceGasPriceParams {}\n/** Return all [DelegatedStake]. */\nexport interface GetStakesParams {\n    owner: string;\n}\n/** Return one or more [DelegatedStake]. If a Stake was withdrawn its status will be Unstaked. */\nexport interface GetStakesByIdsParams {\n    stakedIotaIds: string[];\n}\n/** Return all [DelegatedTimelockedStake]. */\nexport interface GetTimelockedStakesParams {\n    owner: string;\n}\n/** Return one or more [DelegatedTimelockedStake]. If a Stake was withdrawn its status will be Unstaked. */\nexport interface GetTimelockedStakesByIdsParams {\n    timelockedStakedIotaIds: string[];\n}\n/** Return total supply for a coin. */\nexport interface GetTotalSupplyParams {\n    /** type name for the coin (e.g., 0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC) */\n    coinType: string;\n}\n/** Return the total number of transactions. Exclusively served by the indexer. */\nexport interface GetTotalTransactionsParams {}\n/** Return the validator APY */\nexport interface GetValidatorsApyParams {}\n/** Find all registration NFTs for the given address. */\nexport interface IotaNamesFindAllRegistrationNFTsParams {\n    address: string;\n    cursor?: string | null | undefined;\n    limit?: number | null | undefined;\n    options?: RpcTypes.IotaObjectDataOptions | null | undefined;\n}\n/** Return the resolved record for the given name. */\nexport interface IotaNamesLookupParams {\n    /** The name to resolve */\n    name: string;\n}\n/** Return the resolved name for the given address. */\nexport interface IotaNamesReverseLookupParams {\n    /** The address to resolve. */\n    address: string;\n}\n/** Return list of events for a specified query criteria. */\nexport interface QueryEventsParams {\n    /**\n     * The event query criteria. See\n     * [Event filter](https://docs.iota.org/developer/iota-101/using-events#applying-event-filters)\n     * documentation for examples.\n     */\n    query: RpcTypes.IotaEventFilter;\n    /** optional paging cursor */\n    cursor?: RpcTypes.EventId | null | undefined;\n    /** maximum number of items per page, default to [QUERY_MAX_RESULT_LIMIT] if not specified. */\n    limit?: number | null | undefined;\n    /** query result ordering, default to false (ascending order), oldest record first. */\n    order?: 'ascending' | 'descending' | null | undefined;\n}\n/** Return list of transactions for a specified query criteria. */\nexport type QueryTransactionBlocksParams = {\n    /**\n     * An optional paging cursor. If provided, the query will start from the next item after the specified\n     * cursor. Default to start from the first item if not specified.\n     */\n    cursor?: string | null | undefined;\n    /** Maximum item returned per page, default to QUERY_MAX_RESULT_LIMIT if not specified. */\n    limit?: number | null | undefined;\n    /** query result ordering, default to false (ascending order), oldest record first. */\n    order?: 'ascending' | 'descending' | null | undefined;\n} & RpcTypes.IotaTransactionBlockResponseQuery;\n/** Subscribe to a stream of IOTA event */\nexport interface SubscribeEventParams {\n    /**\n     * The filter criteria of the event stream. See\n     * [Event filter](https://docs.iota.org/developer/iota-101/using-events#applying-event-filters)\n     * documentation for examples.\n     */\n    filter: RpcTypes.IotaEventFilter;\n}\n/** Subscribe to a stream of IOTA transaction effects */\nexport interface SubscribeTransactionParams {\n    filter: RpcTypes.TransactionFilter;\n}\n/** Create an unsigned batched transaction. */\nexport interface UnsafeBatchTransactionParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** list of transaction request parameters */\n    singleTransactionParams: RpcTypes.RPCTransactionRequestParams[];\n    /**\n     * gas object to be used in this transaction, node will pick one from the signer's possession if not\n     * provided\n     */\n    gas?: string | null | undefined;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n    /** Whether this is a regular transaction or a Dev Inspect Transaction */\n    txnBuilderMode?: RpcTypes.IotaTransactionBlockBuilderMode | null | undefined;\n}\n/** Create an unsigned transaction to merge multiple coins into one coin. */\nexport interface UnsafeMergeCoinsParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** the coin object to merge into, this coin will remain after the transaction */\n    primaryCoin: string;\n    /**\n     * the coin object to be merged, this coin will be destroyed, the balance will be added to\n     * `primary_coin`\n     */\n    coinToMerge: string;\n    /**\n     * gas object to be used in this transaction, node will pick one from the signer's possession if not\n     * provided\n     */\n    gas?: string | null | undefined;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n}\n/**\n * Create an unsigned transaction to execute a Move call on the network, by calling the specified\n * function in the module of a given package.\n */\nexport interface UnsafeMoveCallParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** the Move package ID, e.g. `0x2` */\n    packageObjectId: string;\n    /** the Move module name, e.g. `pay` */\n    module: string;\n    /** the move function name, e.g. `split` */\n    function: string;\n    /** the type arguments of the Move function */\n    typeArguments: string[];\n    /**\n     * the arguments to be passed into the Move function, in\n     * [IotaJson](https://docs.iota.org/references/iota-api) format\n     */\n    arguments: unknown[];\n    /**\n     * gas object to be used in this transaction, node will pick one from the signer's possession if not\n     * provided\n     */\n    gas?: string | null | undefined;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n    /**\n     * Whether this is a Normal transaction or a Dev Inspect Transaction. Default to be\n     * `IotaTransactionBlockBuilderMode::Commit` when it's None.\n     */\n    executionMode?: RpcTypes.IotaTransactionBlockBuilderMode | null | undefined;\n}\n/**\n * Send `Coin<T>` to a list of addresses, where `T` can be any coin type, following a list of amounts,\n * The object specified in the `gas` field will be used to pay the gas fee for the transaction. The gas\n * object can not appear in `input_coins`. If the gas object is not specified, the RPC server will\n * auto-select one.\n */\nexport interface UnsafePayParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** the IOTA coins to be used in this transaction */\n    inputCoins: string[];\n    /** the recipients' addresses, the length of this vector must be the same as amounts. */\n    recipients: string[];\n    /** the amounts to be transferred to recipients, following the same order */\n    amounts: string[];\n    /**\n     * gas object to be used in this transaction, node will pick one from the signer's possession if not\n     * provided\n     */\n    gas?: string | null | undefined;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n}\n/**\n * Send all IOTA coins to one recipient. This is for IOTA coin only and does not require a separate gas\n * coin object. Specifically, what pay_all_iota does are: 1. accumulate all IOTA from input coins and\n * deposit all IOTA to the first input coin 2. transfer the updated first coin to the recipient and\n * also use this first coin as gas coin object. 3. the balance of the first input coin after tx is\n * sum(input_coins) - actual_gas_cost. 4. all other input coins other than the first are deleted.\n */\nexport interface UnsafePayAllIotaParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** the IOTA coins to be used in this transaction, including the coin for gas payment. */\n    inputCoins: string[];\n    /** the recipient address, */\n    recipient: string;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n}\n/**\n * Send IOTA coins to a list of addresses, following a list of amounts. This is for IOTA coin only and\n * does not require a separate gas coin object. Specifically, what pay_iota does are: 1. debit each\n * input_coin to create new coin following the order of amounts and assign it to the corresponding\n * recipient. 2. accumulate all residual IOTA from input coins left and deposit all IOTA to the first\n * input coin, then use the first input coin as the gas coin object. 3. the balance of the first input\n * coin after tx is sum(input_coins) - sum(amounts) - actual_gas_cost 4. all other input coints other\n * than the first one are deleted.\n */\nexport interface UnsafePayIotaParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** the IOTA coins to be used in this transaction, including the coin for gas payment. */\n    inputCoins: string[];\n    /** the recipients' addresses, the length of this vector must be the same as amounts. */\n    recipients: string[];\n    /** the amounts to be transferred to recipients, following the same order */\n    amounts: string[];\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n}\n/** Create an unsigned transaction to publish a Move package. */\nexport interface UnsafePublishParams {\n    /** the transaction signer's IOTA address */\n    sender: string;\n    /** the compiled bytes of a Move package */\n    compiledModules: string[];\n    /** a list of transitive dependency addresses that this set of modules depends on. */\n    dependencies: string[];\n    /**\n     * gas object to be used in this transaction, node will pick one from the signer's possession if not\n     * provided\n     */\n    gas?: string | null | undefined;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n}\n/** Add stake to a validator's staking pool using multiple coins and amount. */\nexport interface UnsafeRequestAddStakeParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** Coin<IOTA> object to stake */\n    coins: string[];\n    /** stake amount */\n    amount?: string | null | undefined;\n    /** the validator's IOTA address */\n    validator: string;\n    /**\n     * gas object to be used in this transaction, node will pick one from the signer's possession if not\n     * provided\n     */\n    gas?: string | null | undefined;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n}\n/** Add timelocked stake to a validator's staking pool using multiple balances and amount. */\nexport interface UnsafeRequestAddTimelockedStakeParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** TimeLock<Balance<IOTA>> object to stake */\n    lockedBalance: string;\n    /** the validator's IOTA address */\n    validator: string;\n    /** gas object to be used in this transaction */\n    gas: string;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n}\n/** Withdraw stake from a validator's staking pool. */\nexport interface UnsafeRequestWithdrawStakeParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** StakedIota object ID */\n    stakedIota: string;\n    /**\n     * gas object to be used in this transaction, node will pick one from the signer's possession if not\n     * provided\n     */\n    gas?: string | null | undefined;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n}\n/** Withdraw timelocked stake from a validator's staking pool. */\nexport interface UnsafeRequestWithdrawTimelockedStakeParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** TimelockedStakedIota object ID */\n    timelockedStakedIota: string;\n    /** gas object to be used in this transaction */\n    gas: string;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n}\n/** Create an unsigned transaction to split a coin object into multiple coins. */\nexport interface UnsafeSplitCoinParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** the coin object to be spilt */\n    coinObjectId: string;\n    /** the amounts to split out from the coin */\n    splitAmounts: string[];\n    /**\n     * gas object to be used in this transaction, node will pick one from the signer's possession if not\n     * provided\n     */\n    gas?: string | null | undefined;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n}\n/** Create an unsigned transaction to split a coin object into multiple equal-size coins. */\nexport interface UnsafeSplitCoinEqualParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** the coin object to be spilt */\n    coinObjectId: string;\n    /** the number of coins to split into */\n    splitCount: string;\n    /**\n     * gas object to be used in this transaction, node will pick one from the signer's possession if not\n     * provided\n     */\n    gas?: string | null | undefined;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n}\n/**\n * Create an unsigned transaction to send IOTA coin object to an IOTA address. The IOTA object is also\n * used as the gas object.\n */\nexport interface UnsafeTransferIotaParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** the IOTA coin object to be used in this transaction */\n    iotaObjectId: string;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n    /** the recipient's IOTA address */\n    recipient: string;\n    /** the amount to be split out and transferred */\n    amount?: string | null | undefined;\n}\n/**\n * Create an unsigned transaction to transfer an object from one address to another. The object's type\n * must allow public transfers\n */\nexport interface UnsafeTransferObjectParams {\n    /** the transaction signer's IOTA address */\n    signer: string;\n    /** the ID of the object to be transferred */\n    objectId: string;\n    /**\n     * gas object to be used in this transaction, node will pick one from the signer's possession if not\n     * provided\n     */\n    gas?: string | null | undefined;\n    /** the gas budget, the transaction will fail if the gas cost exceed the budget */\n    gasBudget: string;\n    /** the recipient's IOTA address */\n    recipient: string;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
