{
  "version": 3,
  "sources": ["../../../../src/transactions/executor/serial.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@iota/bcs';\n\nimport { bcs } from '../../bcs/index.js';\nimport type { IotaClient, IotaTransactionBlockResponseOptions } from '../../client/index.js';\nimport type { Signer } from '../../cryptography/keypair.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { isTransaction, Transaction } from '../Transaction.js';\nimport { CachingTransactionExecutor } from './caching.js';\nimport { SerialQueue } from './queue.js';\n\nexport class SerialTransactionExecutor {\n    #queue = new SerialQueue();\n    #signer: Signer;\n    #cache: CachingTransactionExecutor;\n    #defaultGasBudget: bigint;\n\n    constructor({\n        signer,\n        defaultGasBudget = 50_000_000n,\n        ...options\n    }: Omit<ObjectCacheOptions, 'address'> & {\n        client: IotaClient;\n        signer: Signer;\n        /** The gasBudget to use if the transaction has not defined it's own gasBudget, defaults to `50_000_000n` */\n        defaultGasBudget?: bigint;\n    }) {\n        this.#signer = signer;\n        this.#defaultGasBudget = defaultGasBudget;\n        this.#cache = new CachingTransactionExecutor({\n            client: options.client,\n            cache: options.cache,\n        });\n    }\n\n    async applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n        return Promise.all([this.#cacheGasCoin(effects), this.#cache.cache.applyEffects(effects)]);\n    }\n\n    #cacheGasCoin = async (effects: typeof bcs.TransactionEffects.$inferType) => {\n        if (!effects.V1) {\n            return;\n        }\n\n        const gasCoin = getGasCoinFromEffects(effects).ref;\n        if (gasCoin) {\n            this.#cache.cache.setCustom('gasCoin', gasCoin);\n        } else {\n            this.#cache.cache.deleteCustom('gasCoin');\n        }\n    };\n\n    async buildTransaction(transaction: Transaction) {\n        return this.#queue.runTask(() => this.#buildTransaction(transaction));\n    }\n\n    #buildTransaction = async (transaction: Transaction) => {\n        const gasCoin = await this.#cache.cache.getCustom<{\n            objectId: string;\n            version: string;\n            digest: string;\n        }>('gasCoin');\n\n        const copy = Transaction.from(transaction);\n        if (gasCoin) {\n            copy.setGasPayment([gasCoin]);\n        }\n\n        copy.setGasBudgetIfNotSet(this.#defaultGasBudget);\n        copy.setSenderIfNotSet(this.#signer.toIotaAddress());\n\n        return this.#cache.buildTransaction({ transaction: copy });\n    };\n\n    resetCache() {\n        return this.#cache.reset();\n    }\n\n    waitForLastTransaction() {\n        return this.#cache.waitForLastTransaction();\n    }\n\n    executeTransaction(\n        transaction: Transaction | Uint8Array,\n        options?: IotaTransactionBlockResponseOptions,\n    ) {\n        return this.#queue.runTask(async () => {\n            const bytes = isTransaction(transaction)\n                ? await this.#buildTransaction(transaction)\n                : transaction;\n\n            const { signature } = await this.#signer.signTransaction(bytes);\n            const results = await this.#cache\n                .executeTransaction({\n                    signature,\n                    transaction: bytes,\n                    options,\n                })\n                .catch(async (error) => {\n                    await this.resetCache();\n                    throw error;\n                });\n\n            const effectsBytes = Uint8Array.from(results.rawEffects!);\n            const effects = bcs.TransactionEffects.parse(effectsBytes);\n            await this.applyEffects(effects);\n\n            return {\n                digest: results.digest,\n                effects: toB64(effectsBytes),\n            };\n        });\n    }\n}\n\nexport function getGasCoinFromEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n    if (!effects.V1) {\n        throw new Error('Unexpected effects version');\n    }\n\n    const gasObjectChange = effects.V1.changedObjects[effects.V1.gasObjectIndex!];\n\n    if (!gasObjectChange) {\n        throw new Error('Gas object not found in effects');\n    }\n\n    const [objectId, { outputState }] = gasObjectChange;\n\n    if (!outputState.ObjectWrite) {\n        throw new Error('Unexpected gas object state');\n    }\n\n    const [digest, owner] = outputState.ObjectWrite;\n\n    return {\n        ref: {\n            objectId,\n            digest,\n            version: effects.V1.lamportVersion,\n        },\n        owner: owner.AddressOwner || owner.ObjectOwner!,\n    };\n}\n"],
  "mappings": "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",
  "names": ["import_bcs"]
}
