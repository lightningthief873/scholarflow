{
  "version": 3,
  "sources": ["../../../../src/transactions/data/v1.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@iota/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n    array,\n    bigint,\n    boolean,\n    check,\n    integer,\n    is,\n    lazy,\n    literal,\n    nullable,\n    nullish,\n    number,\n    object,\n    optional,\n    parse,\n    pipe,\n    string,\n    union,\n    unknown,\n} from 'valibot';\n\nimport { TypeTagSerializer } from '../../bcs/index.js';\nimport type { StructTag as StructTagType, TypeTag as TypeTagType } from '../../bcs/types.js';\nimport { JsonU64, ObjectID, safeEnum, TransactionData } from './internal.js';\nimport type { Argument } from './internal.js';\n\nexport const ObjectRef = object({\n    digest: string(),\n    objectId: string(),\n    version: union([pipe(number(), integer()), string(), bigint()]),\n});\n\nconst ObjectArg = safeEnum({\n    ImmOrOwned: ObjectRef,\n    Shared: object({\n        objectId: ObjectID,\n        initialSharedVersion: JsonU64,\n        mutable: boolean(),\n    }),\n    Receiving: ObjectRef,\n});\n\nexport const NormalizedCallArg = safeEnum({\n    Object: ObjectArg,\n    Pure: array(pipe(number(), integer())),\n});\n\nconst TransactionInput = union([\n    object({\n        kind: literal('Input'),\n        index: pipe(number(), integer()),\n        value: unknown(),\n        type: optional(literal('object')),\n    }),\n    object({\n        kind: literal('Input'),\n        index: pipe(number(), integer()),\n        value: unknown(),\n        type: literal('pure'),\n    }),\n]);\n\nconst TransactionExpiration = union([\n    object({ Epoch: pipe(number(), integer()) }),\n    object({ None: nullable(literal(true)) }),\n]);\n\nconst StringEncodedBigint = pipe(\n    union([number(), string(), bigint()]),\n    check((val) => {\n        if (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n        try {\n            BigInt(val as string);\n            return true;\n        } catch {\n            return false;\n        }\n    }),\n);\n\nexport const TypeTag: GenericSchema<TypeTagType> = union([\n    object({ bool: nullable(literal(true)) }),\n    object({ u8: nullable(literal(true)) }),\n    object({ u64: nullable(literal(true)) }),\n    object({ u128: nullable(literal(true)) }),\n    object({ address: nullable(literal(true)) }),\n    object({ signer: nullable(literal(true)) }),\n    object({ vector: lazy(() => TypeTag) }),\n    object({ struct: lazy(() => StructTag) }),\n    object({ u16: nullable(literal(true)) }),\n    object({ u32: nullable(literal(true)) }),\n    object({ u256: nullable(literal(true)) }),\n]);\n\n// https://github.com/iotaledger/iota/blob/cea8742e810142a8145fd83c4c142d61e561004a/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag: GenericSchema<StructTagType> = object({\n    address: string(),\n    module: string(),\n    name: string(),\n    typeParams: array(TypeTag),\n});\n\nconst GasConfig = object({\n    budget: optional(StringEncodedBigint),\n    price: optional(StringEncodedBigint),\n    payment: optional(array(ObjectRef)),\n    owner: optional(string()),\n});\n\nconst TransactionArgumentTypes = [\n    TransactionInput,\n    object({ kind: literal('GasCoin') }),\n    object({ kind: literal('Result'), index: pipe(number(), integer()) }),\n    object({\n        kind: literal('NestedResult'),\n        index: pipe(number(), integer()),\n        resultIndex: pipe(number(), integer()),\n    }),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\n\nconst MoveCallTransaction = object({\n    kind: literal('MoveCall'),\n    target: pipe(\n        string(),\n        check((target) => target.split('::').length === 3),\n    ) as GenericSchema<`${string}::${string}::${string}`>,\n    typeArguments: array(string()),\n    arguments: array(TransactionArgument),\n});\n\nconst TransferObjectsTransaction = object({\n    kind: literal('TransferObjects'),\n    objects: array(TransactionArgument),\n    address: TransactionArgument,\n});\n\nconst SplitCoinsTransaction = object({\n    kind: literal('SplitCoins'),\n    coin: TransactionArgument,\n    amounts: array(TransactionArgument),\n});\n\nconst MergeCoinsTransaction = object({\n    kind: literal('MergeCoins'),\n    destination: TransactionArgument,\n    sources: array(TransactionArgument),\n});\n\nconst MakeMoveVecTransaction = object({\n    kind: literal('MakeMoveVec'),\n    type: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),\n    objects: array(TransactionArgument),\n});\n\nconst PublishTransaction = object({\n    kind: literal('Publish'),\n    modules: array(array(pipe(number(), integer()))),\n    dependencies: array(string()),\n});\n\nconst UpgradeTransaction = object({\n    kind: literal('Upgrade'),\n    modules: array(array(pipe(number(), integer()))),\n    dependencies: array(string()),\n    packageId: string(),\n    ticket: TransactionArgument,\n});\n\nconst TransactionTypes = [\n    MoveCallTransaction,\n    TransferObjectsTransaction,\n    SplitCoinsTransaction,\n    MergeCoinsTransaction,\n    PublishTransaction,\n    UpgradeTransaction,\n    MakeMoveVecTransaction,\n] as const;\n\nconst TransactionType = union([...TransactionTypes]);\n\nexport const SerializedTransactionDataV1 = object({\n    version: literal(1),\n    sender: optional(string()),\n    expiration: nullish(TransactionExpiration),\n    gasConfig: GasConfig,\n    inputs: array(TransactionInput),\n    transactions: array(TransactionType),\n});\n\nexport type SerializedTransactionDataV1 = InferOutput<typeof SerializedTransactionDataV1>;\n\nexport function serializeV1TransactionData(\n    transactionData: TransactionData,\n): SerializedTransactionDataV1 {\n    const inputs: InferOutput<typeof TransactionInput>[] = transactionData.inputs.map(\n        (input, index) => {\n            if (input.Object) {\n                return {\n                    kind: 'Input',\n                    index,\n                    value: {\n                        Object: input.Object.ImmOrOwnedObject\n                            ? {\n                                  ImmOrOwned: input.Object.ImmOrOwnedObject,\n                              }\n                            : input.Object.Receiving\n                              ? {\n                                    Receiving: {\n                                        digest: input.Object.Receiving.digest,\n                                        version: input.Object.Receiving.version,\n                                        objectId: input.Object.Receiving.objectId,\n                                    },\n                                }\n                              : {\n                                    Shared: {\n                                        mutable: input.Object.SharedObject.mutable,\n                                        initialSharedVersion:\n                                            input.Object.SharedObject.initialSharedVersion,\n                                        objectId: input.Object.SharedObject.objectId,\n                                    },\n                                },\n                    },\n                    type: 'object',\n                };\n            }\n            if (input.Pure) {\n                return {\n                    kind: 'Input',\n                    index,\n                    value: {\n                        Pure: Array.from(fromB64(input.Pure.bytes)),\n                    },\n                    type: 'pure',\n                };\n            }\n\n            if (input.UnresolvedPure) {\n                return {\n                    kind: 'Input',\n                    type: 'pure',\n                    index,\n                    value: input.UnresolvedPure.value,\n                };\n            }\n\n            if (input.UnresolvedObject) {\n                return {\n                    kind: 'Input',\n                    type: 'object',\n                    index,\n                    value: input.UnresolvedObject.objectId,\n                };\n            }\n\n            throw new Error('Invalid input');\n        },\n    );\n\n    return {\n        version: 1,\n        sender: transactionData.sender ?? undefined,\n        expiration:\n            transactionData.expiration?.$kind === 'Epoch'\n                ? { Epoch: Number(transactionData.expiration.Epoch) }\n                : transactionData.expiration\n                  ? { None: true }\n                  : null,\n        gasConfig: {\n            owner: transactionData.gasData.owner ?? undefined,\n            budget: transactionData.gasData.budget ?? undefined,\n            price: transactionData.gasData.price ?? undefined,\n            payment: transactionData.gasData.payment ?? undefined,\n        },\n        inputs,\n        transactions: transactionData.commands.map(\n            (command): InferOutput<typeof TransactionType> => {\n                if (command.MakeMoveVec) {\n                    return {\n                        kind: 'MakeMoveVec',\n                        type:\n                            command.MakeMoveVec.type === null\n                                ? { None: true }\n                                : {\n                                      Some: TypeTagSerializer.parseFromStr(\n                                          command.MakeMoveVec.type,\n                                      ),\n                                  },\n                        objects: command.MakeMoveVec.elements.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.MergeCoins) {\n                    return {\n                        kind: 'MergeCoins',\n                        destination: convertTransactionArgument(\n                            command.MergeCoins.destination,\n                            inputs,\n                        ),\n                        sources: command.MergeCoins.sources.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.MoveCall) {\n                    return {\n                        kind: 'MoveCall',\n                        target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n                        typeArguments: command.MoveCall.typeArguments,\n                        arguments: command.MoveCall.arguments.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.Publish) {\n                    return {\n                        kind: 'Publish',\n                        modules: command.Publish.modules.map((mod) => Array.from(fromB64(mod))),\n                        dependencies: command.Publish.dependencies,\n                    };\n                }\n                if (command.SplitCoins) {\n                    return {\n                        kind: 'SplitCoins',\n                        coin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n                        amounts: command.SplitCoins.amounts.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.TransferObjects) {\n                    return {\n                        kind: 'TransferObjects',\n                        objects: command.TransferObjects.objects.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                        address: convertTransactionArgument(\n                            command.TransferObjects.address,\n                            inputs,\n                        ),\n                    };\n                }\n\n                if (command.Upgrade) {\n                    return {\n                        kind: 'Upgrade',\n                        modules: command.Upgrade.modules.map((mod) => Array.from(fromB64(mod))),\n                        dependencies: command.Upgrade.dependencies,\n                        packageId: command.Upgrade.package,\n                        ticket: convertTransactionArgument(command.Upgrade.ticket, inputs),\n                    };\n                }\n\n                throw new Error(`Unknown transaction ${Object.keys(command)}`);\n            },\n        ),\n    };\n}\n\nfunction convertTransactionArgument(\n    arg: Argument,\n    inputs: InferOutput<typeof TransactionInput>[],\n): InferOutput<typeof TransactionArgument> {\n    if (arg.$kind === 'GasCoin') {\n        return { kind: 'GasCoin' };\n    }\n    if (arg.$kind === 'Result') {\n        return { kind: 'Result', index: arg.Result };\n    }\n    if (arg.$kind === 'NestedResult') {\n        return {\n            kind: 'NestedResult',\n            index: arg.NestedResult[0],\n            resultIndex: arg.NestedResult[1],\n        };\n    }\n    if (arg.$kind === 'Input') {\n        return inputs[arg.Input];\n    }\n\n    throw new Error(`Invalid argument ${Object.keys(arg)}`);\n}\n\nexport function transactionDataFromV1(data: SerializedTransactionDataV1): TransactionData {\n    return parse(TransactionData, {\n        version: 2,\n        sender: data.sender ?? null,\n        expiration: data.expiration\n            ? 'Epoch' in data.expiration\n                ? { Epoch: data.expiration.Epoch }\n                : { None: true }\n            : null,\n        gasData: {\n            owner: data.gasConfig.owner ?? null,\n            budget: data.gasConfig.budget?.toString() ?? null,\n            price: data.gasConfig.price?.toString() ?? null,\n            payment:\n                data.gasConfig.payment?.map((ref) => ({\n                    digest: ref.digest,\n                    objectId: ref.objectId,\n                    version: ref.version.toString(),\n                })) ?? null,\n        },\n        inputs: data.inputs.map((input) => {\n            if (input.kind === 'Input') {\n                if (is(NormalizedCallArg, input.value)) {\n                    const value = parse(NormalizedCallArg, input.value);\n\n                    if (value.Object) {\n                        if (value.Object.ImmOrOwned) {\n                            return {\n                                Object: {\n                                    ImmOrOwnedObject: {\n                                        objectId: value.Object.ImmOrOwned.objectId,\n                                        version: String(value.Object.ImmOrOwned.version),\n                                        digest: value.Object.ImmOrOwned.digest,\n                                    },\n                                },\n                            };\n                        }\n                        if (value.Object.Shared) {\n                            return {\n                                Object: {\n                                    SharedObject: {\n                                        mutable: value.Object.Shared.mutable ?? null,\n                                        initialSharedVersion:\n                                            value.Object.Shared.initialSharedVersion,\n                                        objectId: value.Object.Shared.objectId,\n                                    },\n                                },\n                            };\n                        }\n                        if (value.Object.Receiving) {\n                            return {\n                                Object: {\n                                    Receiving: {\n                                        digest: value.Object.Receiving.digest,\n                                        version: String(value.Object.Receiving.version),\n                                        objectId: value.Object.Receiving.objectId,\n                                    },\n                                },\n                            };\n                        }\n\n                        throw new Error('Invalid object input');\n                    }\n\n                    return {\n                        Pure: {\n                            bytes: toB64(new Uint8Array(value.Pure)),\n                        },\n                    };\n                }\n\n                if (input.type === 'object') {\n                    return {\n                        UnresolvedObject: {\n                            objectId: input.value as string,\n                        },\n                    };\n                }\n\n                return {\n                    UnresolvedPure: {\n                        value: input.value,\n                    },\n                };\n            }\n\n            throw new Error('Invalid input');\n        }),\n        commands: data.transactions.map((transaction) => {\n            switch (transaction.kind) {\n                case 'MakeMoveVec':\n                    return {\n                        MakeMoveVec: {\n                            type:\n                                'Some' in transaction.type\n                                    ? TypeTagSerializer.tagToString(transaction.type.Some)\n                                    : null,\n                            elements: transaction.objects.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                case 'MergeCoins': {\n                    return {\n                        MergeCoins: {\n                            destination: parseV1TransactionArgument(transaction.destination),\n                            sources: transaction.sources.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                }\n                case 'MoveCall': {\n                    const [pkg, mod, fn] = transaction.target.split('::');\n                    return {\n                        MoveCall: {\n                            package: pkg,\n                            module: mod,\n                            function: fn,\n                            typeArguments: transaction.typeArguments,\n                            arguments: transaction.arguments.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                }\n                case 'Publish': {\n                    return {\n                        Publish: {\n                            modules: transaction.modules.map((mod) => toB64(Uint8Array.from(mod))),\n                            dependencies: transaction.dependencies,\n                        },\n                    };\n                }\n                case 'SplitCoins': {\n                    return {\n                        SplitCoins: {\n                            coin: parseV1TransactionArgument(transaction.coin),\n                            amounts: transaction.amounts.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                }\n                case 'TransferObjects': {\n                    return {\n                        TransferObjects: {\n                            objects: transaction.objects.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                            address: parseV1TransactionArgument(transaction.address),\n                        },\n                    };\n                }\n                case 'Upgrade': {\n                    return {\n                        Upgrade: {\n                            modules: transaction.modules.map((mod) => toB64(Uint8Array.from(mod))),\n                            dependencies: transaction.dependencies,\n                            package: transaction.packageId,\n                            ticket: parseV1TransactionArgument(transaction.ticket),\n                        },\n                    };\n                }\n            }\n\n            throw new Error(`Unknown transaction ${Object.keys(transaction)}`);\n        }),\n    } satisfies InferInput<typeof TransactionData>);\n}\n\nfunction parseV1TransactionArgument(\n    arg: InferOutput<typeof TransactionArgument>,\n): InferInput<typeof Argument> {\n    switch (arg.kind) {\n        case 'GasCoin': {\n            return { GasCoin: true };\n        }\n        case 'Result':\n            return { Result: arg.index };\n        case 'NestedResult': {\n            return { NestedResult: [arg.index, arg.resultIndex] };\n        }\n        case 'Input': {\n            return { Input: arg.index };\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
