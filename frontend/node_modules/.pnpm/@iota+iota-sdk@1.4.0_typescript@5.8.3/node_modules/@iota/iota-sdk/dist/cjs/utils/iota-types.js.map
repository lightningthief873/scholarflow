{
  "version": 3,
  "sources": ["../../../src/utils/iota-types.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, splitGenericParameters } from '@iota/bcs';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n    try {\n        const buffer = fromB58(value);\n        return buffer.length === TX_DIGEST_LENGTH;\n    } catch (e) {\n        return false;\n    }\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/iotaledger/iota/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/iota-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const IOTA_ADDRESS_LENGTH = 32;\nexport function isValidIotaAddress(value: string): value is string {\n    return isHex(value) && getHexByteLength(value) === IOTA_ADDRESS_LENGTH;\n}\n\nexport function isValidIotaObjectId(value: string): boolean {\n    return isValidIotaAddress(value);\n}\n\ntype StructTag = {\n    address: string;\n    module: string;\n    name: string;\n    typeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n    if (!type.includes('::')) return type;\n\n    return parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n    const [address, module] = type.split('::');\n\n    const rest = type.slice(address.length + module.length + 4);\n    const name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n    const typeParams = rest.includes('<')\n        ? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n              (typeParam) => parseTypeTag(typeParam.trim()),\n          )\n        : [];\n\n    return {\n        address: normalizeIotaAddress(address),\n        module,\n        name,\n        typeParams,\n    };\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n    const { address, module, name, typeParams } =\n        typeof type === 'string' ? parseStructTag(type) : type;\n\n    const formattedTypeParams =\n        typeParams?.length > 0\n            ? `<${typeParams\n                  .map((typeParam) =>\n                      typeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n                  )\n                  .join(',')}>`\n            : '';\n\n    return `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Normalize an IOTA address to ensure consistent format.\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `IOTA_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n * @param value The address to normalize\n * @param forceAdd0x Whether to add 0x prefix without removing any existing 0x prefixes\n * @param validate Whether to validate the return address\n * @returns The normalized address\n * @throws Error if flag `validate` enabled and the address contains invalid hex characters\n */\nexport function normalizeIotaAddress(\n    value: string,\n    forceAdd0x: boolean = false,\n    validate: boolean = false,\n): string {\n    let address = value.toLowerCase().replace(/ /g, '');\n    if (!forceAdd0x && address.startsWith('0x')) {\n        address = address.slice(2);\n    }\n    address = `0x${address.padStart(IOTA_ADDRESS_LENGTH * 2, '0')}`;\n    if (validate && !isValidIotaAddress(address)) {\n        throw new Error(`Invalid IOTA address: ${value}`);\n    } else {\n        return address;\n    }\n}\n\nexport function normalizeIotaObjectId(\n    value: string,\n    forceAdd0x: boolean = false,\n    validate: boolean = false,\n): string {\n    return normalizeIotaAddress(value, forceAdd0x, validate);\n}\n\nfunction isHex(value: string): boolean {\n    return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n    return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,iBAAgD;AAEhD,MAAM,mBAAmB;AAGlB,SAAS,yBAAyB,OAAgC;AACrE,MAAI;AACA,UAAM,aAAS,oBAAQ,KAAK;AAC5B,WAAO,OAAO,WAAW;AAAA,EAC7B,SAAS,GAAG;AACR,WAAO;AAAA,EACX;AACJ;AAQO,MAAM,sBAAsB;AAC5B,SAAS,mBAAmB,OAAgC;AAC/D,SAAO,MAAM,KAAK,KAAK,iBAAiB,KAAK,MAAM;AACvD;AAEO,SAAS,oBAAoB,OAAwB;AACxD,SAAO,mBAAmB,KAAK;AACnC;AASA,SAAS,aAAa,MAAkC;AACpD,MAAI,CAAC,KAAK,SAAS,IAAI,EAAG,QAAO;AAEjC,SAAO,eAAe,IAAI;AAC9B;AAEO,SAAS,eAAe,MAAyB;AACpD,QAAM,CAAC,SAASA,OAAM,IAAI,KAAK,MAAM,IAAI;AAEzC,QAAM,OAAO,KAAK,MAAM,QAAQ,SAASA,QAAO,SAAS,CAAC;AAC1D,QAAM,OAAO,KAAK,SAAS,GAAG,IAAI,KAAK,MAAM,GAAG,KAAK,QAAQ,GAAG,CAAC,IAAI;AACrE,QAAM,aAAa,KAAK,SAAS,GAAG,QAC9B,mCAAuB,KAAK,MAAM,KAAK,QAAQ,GAAG,IAAI,GAAG,KAAK,YAAY,GAAG,CAAC,CAAC,EAAE;AAAA,IAC7E,CAAC,cAAc,aAAa,UAAU,KAAK,CAAC;AAAA,EAChD,IACA,CAAC;AAEP,SAAO;AAAA,IACH,SAAS,qBAAqB,OAAO;AAAA,IACrC,QAAAA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACJ;AAEO,SAAS,mBAAmB,MAAkC;AACjE,QAAM,EAAE,SAAS,QAAAA,SAAQ,MAAM,WAAW,IACtC,OAAO,SAAS,WAAW,eAAe,IAAI,IAAI;AAEtD,QAAM,sBACF,YAAY,SAAS,IACf,IAAI,WACC;AAAA,IAAI,CAAC,cACF,OAAO,cAAc,WAAW,YAAY,mBAAmB,SAAS;AAAA,EAC5E,EACC,KAAK,GAAG,CAAC,MACd;AAEV,SAAO,GAAG,OAAO,KAAKA,OAAM,KAAK,IAAI,GAAG,mBAAmB;AAC/D;AAmBO,SAAS,qBACZ,OACA,aAAsB,OACtB,WAAoB,OACd;AACN,MAAI,UAAU,MAAM,YAAY,EAAE,QAAQ,MAAM,EAAE;AAClD,MAAI,CAAC,cAAc,QAAQ,WAAW,IAAI,GAAG;AACzC,cAAU,QAAQ,MAAM,CAAC;AAAA,EAC7B;AACA,YAAU,KAAK,QAAQ,SAAS,sBAAsB,GAAG,GAAG,CAAC;AAC7D,MAAI,YAAY,CAAC,mBAAmB,OAAO,GAAG;AAC1C,UAAM,IAAI,MAAM,yBAAyB,KAAK,EAAE;AAAA,EACpD,OAAO;AACH,WAAO;AAAA,EACX;AACJ;AAEO,SAAS,sBACZ,OACA,aAAsB,OACtB,WAAoB,OACd;AACN,SAAO,qBAAqB,OAAO,YAAY,QAAQ;AAC3D;AAEA,SAAS,MAAM,OAAwB;AACnC,SAAO,yBAAyB,KAAK,KAAK,KAAK,MAAM,SAAS,MAAM;AACxE;AAEA,SAAS,iBAAiB,OAAuB;AAC7C,SAAO,WAAW,KAAK,KAAK,KAAK,MAAM,SAAS,KAAK,IAAI,MAAM,SAAS;AAC5E;",
  "names": ["module"]
}
