{
  "version": 3,
  "sources": ["../../../src/transactions/Commands.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@iota/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { normalizeIotaObjectId } from '../utils/iota-types.js';\nimport { Argument } from './data/internal.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport type { Transaction } from './Transaction.js';\n\nexport type TransactionArgument =\n    | InferInput<typeof Argument>\n    | ((tx: Transaction) => InferInput<typeof Argument>);\nexport type TransactionInput = CallArg;\n\n// Keep in sync with constants in\n// crates/iota-framework/packages/iota-framework/sources/package.move\nexport enum UpgradePolicy {\n    COMPATIBLE = 0,\n    ADDITIVE = 128,\n    DEP_ONLY = 192,\n}\n\ntype TransactionShape<T extends Command['$kind']> = { $kind: T } & {\n    [K in T]: Extract<Command, { [K in T]: any }>[T];\n};\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Commands = {\n    MoveCall(\n        input:\n            | {\n                  package: string;\n                  module: string;\n                  function: string;\n                  arguments?: Argument[];\n                  typeArguments?: string[];\n              }\n            | {\n                  target: string;\n                  arguments?: Argument[];\n                  typeArguments?: string[];\n              },\n    ): TransactionShape<'MoveCall'> {\n        const [pkg, mod = '', fn = ''] =\n            'target' in input\n                ? input.target.split('::')\n                : [input.package, input.module, input.function];\n\n        return {\n            $kind: 'MoveCall',\n            MoveCall: {\n                package: pkg,\n                module: mod,\n                function: fn,\n                typeArguments: input.typeArguments ?? [],\n                arguments: input.arguments ?? [],\n            },\n        };\n    },\n\n    TransferObjects(\n        objects: InferInput<typeof Argument>[],\n        address: InferInput<typeof Argument>,\n    ): TransactionShape<'TransferObjects'> {\n        return {\n            $kind: 'TransferObjects',\n            TransferObjects: {\n                objects: objects.map((o) => parse(Argument, o)),\n                address: parse(Argument, address),\n            },\n        };\n    },\n    SplitCoins(\n        coin: InferInput<typeof Argument>,\n        amounts: InferInput<typeof Argument>[],\n    ): TransactionShape<'SplitCoins'> {\n        return {\n            $kind: 'SplitCoins',\n            SplitCoins: {\n                coin: parse(Argument, coin),\n                amounts: amounts.map((o) => parse(Argument, o)),\n            },\n        };\n    },\n    MergeCoins(\n        destination: InferInput<typeof Argument>,\n        sources: InferInput<typeof Argument>[],\n    ): TransactionShape<'MergeCoins'> {\n        return {\n            $kind: 'MergeCoins',\n            MergeCoins: {\n                destination: parse(Argument, destination),\n                sources: sources.map((o) => parse(Argument, o)),\n            },\n        };\n    },\n    Publish({\n        modules,\n        dependencies,\n    }: {\n        modules: number[][] | string[];\n        dependencies: string[];\n    }): TransactionShape<'Publish'> {\n        return {\n            $kind: 'Publish',\n            Publish: {\n                modules: modules.map((module) =>\n                    typeof module === 'string' ? module : toB64(new Uint8Array(module)),\n                ),\n                dependencies: dependencies.map((dep) => normalizeIotaObjectId(dep)),\n            },\n        };\n    },\n    Upgrade({\n        modules,\n        dependencies,\n        package: packageId,\n        ticket,\n    }: {\n        modules: number[][] | string[];\n        dependencies: string[];\n        package: string;\n        ticket: InferInput<typeof Argument>;\n    }): TransactionShape<'Upgrade'> {\n        return {\n            $kind: 'Upgrade',\n            Upgrade: {\n                modules: modules.map((module) =>\n                    typeof module === 'string' ? module : toB64(new Uint8Array(module)),\n                ),\n                dependencies: dependencies.map((dep) => normalizeIotaObjectId(dep)),\n                package: packageId,\n                ticket: parse(Argument, ticket),\n            },\n        };\n    },\n    MakeMoveVec({\n        type,\n        elements,\n    }: {\n        type?: string;\n        elements: InferInput<typeof Argument>[];\n    }): TransactionShape<'MakeMoveVec'> {\n        return {\n            $kind: 'MakeMoveVec',\n            MakeMoveVec: {\n                type: type ?? null,\n                elements: elements.map((o) => parse(Argument, o)),\n            },\n        };\n    },\n    Intent({\n        name,\n        inputs = {},\n        data = {},\n    }: {\n        name: string;\n        inputs?: Record<string, InferInput<typeof Argument> | InferInput<typeof Argument>[]>;\n        data?: Record<string, unknown>;\n    }): TransactionShape<'$Intent'> {\n        return {\n            $kind: '$Intent',\n            $Intent: {\n                name,\n                inputs: Object.fromEntries(\n                    Object.entries(inputs).map(([key, value]) => [\n                        key,\n                        Array.isArray(value)\n                            ? value.map((o) => parse(Argument, o))\n                            : parse(Argument, value),\n                    ]),\n                ),\n                data,\n            },\n        };\n    },\n};\n"],
  "mappings": "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",
  "names": ["UpgradePolicy", "module"]
}
