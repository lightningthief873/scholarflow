{
  "version": 3,
  "sources": ["../../../src/transactions/pure.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isSerializedBcs } from '@iota/bcs';\nimport type { BcsType, SerializedBcs } from '@iota/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { Argument } from './data/internal.js';\n\nexport function createPure<T>(makePure: (value: SerializedBcs<any, any> | Uint8Array) => T) {\n    function pure<T extends PureTypeName>(\n        type: T extends PureTypeName ? ValidPureTypeName<T> : T,\n        value: ShapeFromPureTypeName<T>,\n    ): T;\n\n    function pure(\n        /**\n         * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n         * is assumed to be raw bytes, and will be used directly.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        value: SerializedBcs<any, any> | Uint8Array,\n    ): T;\n\n    function pure(\n        typeOrSerializedValue?: PureTypeName | SerializedBcs<any, any> | Uint8Array,\n        value?: unknown,\n    ): T {\n        if (typeof typeOrSerializedValue === 'string') {\n            return makePure(schemaFromName(typeOrSerializedValue).serialize(value as never));\n        }\n\n        if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n            return makePure(typeOrSerializedValue);\n        }\n\n        throw new Error('tx.pure must be called either a bcs type name, or a serialized bcs value');\n    }\n\n    pure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n    pure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n    pure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n    pure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n    pure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n    pure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n    pure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n    pure.string = (value: string) => makePure(bcs.String.serialize(value));\n    pure.address = (value: string) => makePure(bcs.Address.serialize(value));\n    pure.id = pure.address;\n    pure.vector = <Type extends PureTypeName>(\n        type: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n        value: Iterable<ShapeFromPureTypeName<Type>> & { length: number },\n    ) => {\n        return makePure(bcs.vector(schemaFromName(type as BasePureType)).serialize(value as never));\n    };\n    pure.option = <Type extends PureTypeName>(\n        type: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n        value: ShapeFromPureTypeName<Type> | null | undefined,\n    ) => {\n        return makePure(bcs.option(schemaFromName(type)).serialize(value as never));\n    };\n\n    return pure;\n}\n\nexport type BasePureType =\n    | 'u8'\n    | 'u16'\n    | 'u32'\n    | 'u64'\n    | 'u128'\n    | 'u256'\n    | 'bool'\n    | 'id'\n    | 'string'\n    | 'address';\n\nexport type PureTypeName = BasePureType | `vector<${string}>` | `option<${string}>`;\nexport type ValidPureTypeName<T extends string> = T extends BasePureType\n    ? PureTypeName\n    : T extends `vector<${infer U}>`\n      ? ValidPureTypeName<U>\n      : T extends `option<${infer U}>`\n        ? ValidPureTypeName<U>\n        : PureTypeValidationError<T>;\n\ntype ShapeFromPureTypeName<T extends PureTypeName> = T extends BasePureType\n    ? Parameters<ReturnType<typeof createPure<Argument>>[T]>[0]\n    : T extends `vector<${infer U extends PureTypeName}>`\n      ? ShapeFromPureTypeName<U>[]\n      : T extends `option<${infer U extends PureTypeName}>`\n        ? ShapeFromPureTypeName<U> | null\n        : never;\n\ntype PureTypeValidationError<T extends string> = T & {\n    error: `Invalid Pure type name: ${T}`;\n};\n\nfunction schemaFromName<T extends PureTypeName>(\n    name: T extends PureTypeName ? ValidPureTypeName<T> : T,\n): BcsType<ShapeFromPureTypeName<T>> {\n    switch (name) {\n        case 'u8':\n            return bcs.u8() as never;\n        case 'u16':\n            return bcs.u16() as never;\n        case 'u32':\n            return bcs.u32() as never;\n        case 'u64':\n            return bcs.u64() as never;\n        case 'u128':\n            return bcs.u128() as never;\n        case 'u256':\n            return bcs.u256() as never;\n        case 'bool':\n            return bcs.bool() as never;\n        case 'string':\n            return bcs.string() as never;\n        case 'id':\n        case 'address':\n            return bcs.Address as never;\n    }\n\n    const generic = name.match(/^(vector|option)<(.+)>$/);\n    if (generic) {\n        const [kind, inner] = generic.slice(1);\n        if (kind === 'vector') {\n            return bcs.vector(schemaFromName(inner as PureTypeName)) as never;\n        } else {\n            return bcs.option(schemaFromName(inner as PureTypeName)) as never;\n        }\n    }\n\n    throw new Error(`Invalid Pure type name: ${name}`);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,iBAAgC;AAGhC,IAAAA,cAAoB;AAGb,SAAS,WAAc,UAA8D;AAexF,WAAS,KACL,uBACA,OACC;AACD,QAAI,OAAO,0BAA0B,UAAU;AAC3C,aAAO,SAAS,eAAe,qBAAqB,EAAE,UAAU,KAAc,CAAC;AAAA,IACnF;AAEA,QAAI,iCAAiC,kBAAc,4BAAgB,qBAAqB,GAAG;AACvF,aAAO,SAAS,qBAAqB;AAAA,IACzC;AAEA,UAAM,IAAI,MAAM,0EAA0E;AAAA,EAC9F;AAEA,OAAK,KAAK,CAAC,UAAkB,SAAS,gBAAI,GAAG,UAAU,KAAK,CAAC;AAC7D,OAAK,MAAM,CAAC,UAAkB,SAAS,gBAAI,IAAI,UAAU,KAAK,CAAC;AAC/D,OAAK,MAAM,CAAC,UAAkB,SAAS,gBAAI,IAAI,UAAU,KAAK,CAAC;AAC/D,OAAK,MAAM,CAAC,UAAoC,SAAS,gBAAI,IAAI,UAAU,KAAK,CAAC;AACjF,OAAK,OAAO,CAAC,UAAoC,SAAS,gBAAI,KAAK,UAAU,KAAK,CAAC;AACnF,OAAK,OAAO,CAAC,UAAoC,SAAS,gBAAI,KAAK,UAAU,KAAK,CAAC;AACnF,OAAK,OAAO,CAAC,UAAmB,SAAS,gBAAI,KAAK,UAAU,KAAK,CAAC;AAClE,OAAK,SAAS,CAAC,UAAkB,SAAS,gBAAI,OAAO,UAAU,KAAK,CAAC;AACrE,OAAK,UAAU,CAAC,UAAkB,SAAS,gBAAI,QAAQ,UAAU,KAAK,CAAC;AACvE,OAAK,KAAK,KAAK;AACf,OAAK,SAAS,CACV,MACA,UACC;AACD,WAAO,SAAS,gBAAI,OAAO,eAAe,IAAoB,CAAC,EAAE,UAAU,KAAc,CAAC;AAAA,EAC9F;AACA,OAAK,SAAS,CACV,MACA,UACC;AACD,WAAO,SAAS,gBAAI,OAAO,eAAe,IAAI,CAAC,EAAE,UAAU,KAAc,CAAC;AAAA,EAC9E;AAEA,SAAO;AACX;AAmCA,SAAS,eACL,MACiC;AACjC,UAAQ,MAAM;AAAA,IACV,KAAK;AACD,aAAO,gBAAI,GAAG;AAAA,IAClB,KAAK;AACD,aAAO,gBAAI,IAAI;AAAA,IACnB,KAAK;AACD,aAAO,gBAAI,IAAI;AAAA,IACnB,KAAK;AACD,aAAO,gBAAI,IAAI;AAAA,IACnB,KAAK;AACD,aAAO,gBAAI,KAAK;AAAA,IACpB,KAAK;AACD,aAAO,gBAAI,KAAK;AAAA,IACpB,KAAK;AACD,aAAO,gBAAI,KAAK;AAAA,IACpB,KAAK;AACD,aAAO,gBAAI,OAAO;AAAA,IACtB,KAAK;AAAA,IACL,KAAK;AACD,aAAO,gBAAI;AAAA,EACnB;AAEA,QAAM,UAAU,KAAK,MAAM,yBAAyB;AACpD,MAAI,SAAS;AACT,UAAM,CAAC,MAAM,KAAK,IAAI,QAAQ,MAAM,CAAC;AACrC,QAAI,SAAS,UAAU;AACnB,aAAO,gBAAI,OAAO,eAAe,KAAqB,CAAC;AAAA,IAC3D,OAAO;AACH,aAAO,gBAAI,OAAO,eAAe,KAAqB,CAAC;AAAA,IAC3D;AAAA,EACJ;AAEA,QAAM,IAAI,MAAM,2BAA2B,IAAI,EAAE;AACrD;",
  "names": ["import_bcs"]
}
