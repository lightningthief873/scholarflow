{
  "version": 3,
  "sources": ["../../../../src/keypairs/passkey/keypair.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2025 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@iota/bcs';\nimport { secp256r1 } from '@noble/curves/p256';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\n\nimport { PasskeyAuthenticator } from '../../bcs/bcs.js';\nimport type { IntentScope, SignatureWithBytes } from '../../cryptography/index.js';\nimport { messageWithIntent, SIGNATURE_SCHEME_TO_FLAG, Signer } from '../../cryptography/index.js';\nimport type { PublicKey } from '../../cryptography/publickey.js';\nimport type { SignatureScheme } from '../../cryptography/signature-scheme.js';\nimport {\n    parseDerSPKI,\n    PASSKEY_PUBLIC_KEY_SIZE,\n    PASSKEY_SIGNATURE_SIZE,\n    PasskeyPublicKey,\n} from './publickey.js';\nimport type { AuthenticationCredential, RegistrationCredential } from './types.js';\n\ntype DeepPartialConfigKeys = 'rp' | 'user' | 'authenticatorSelection';\n\ntype DeepPartial<T> = T extends object\n    ? {\n          [P in keyof T]?: DeepPartial<T[P]>;\n      }\n    : T;\n\nexport type BrowserPasswordProviderOptions = Pick<\n    DeepPartial<PublicKeyCredentialCreationOptions>,\n    DeepPartialConfigKeys\n> &\n    Omit<\n        Partial<PublicKeyCredentialCreationOptions>,\n        DeepPartialConfigKeys | 'pubKeyCredParams' | 'challenge'\n    >;\n\nexport interface PasskeyProvider {\n    create(): Promise<RegistrationCredential>;\n    get(challenge: Uint8Array): Promise<AuthenticationCredential>;\n}\n\n// Default browser implementation\nexport class BrowserPasskeyProvider implements PasskeyProvider {\n    #name: string;\n    #options: BrowserPasswordProviderOptions;\n\n    constructor(name: string, options: BrowserPasswordProviderOptions) {\n        this.#name = name;\n        this.#options = options;\n    }\n\n    async create(): Promise<RegistrationCredential> {\n        return (await navigator.credentials.create({\n            publicKey: {\n                timeout: this.#options.timeout ?? 60000,\n                ...this.#options,\n                rp: {\n                    name: this.#name,\n                    ...this.#options.rp,\n                },\n                user: {\n                    name: this.#name,\n                    displayName: this.#name,\n                    ...this.#options.user,\n                    id: randomBytes(10),\n                },\n                challenge: new TextEncoder().encode('Create passkey wallet on IOTA'),\n                pubKeyCredParams: [{ alg: -7, type: 'public-key' }],\n                authenticatorSelection: {\n                    authenticatorAttachment: 'cross-platform',\n                    residentKey: 'required',\n                    requireResidentKey: true,\n                    userVerification: 'required',\n                    ...this.#options.authenticatorSelection,\n                },\n            },\n        })) as RegistrationCredential;\n    }\n\n    async get(challenge: Uint8Array): Promise<AuthenticationCredential> {\n        return (await navigator.credentials.get({\n            publicKey: {\n                challenge,\n                userVerification:\n                    this.#options.authenticatorSelection?.userVerification || 'required',\n                timeout: this.#options.timeout ?? 60000,\n            },\n        })) as AuthenticationCredential;\n    }\n}\n\n/**\n * @experimental\n * A passkey signer used for signing transactions. This is a client side implementation for [SIP-9](https://github.com/sui-foundation/sips/blob/main/sips/sip-9.md).\n */\nexport class PasskeyKeypair extends Signer {\n    private publicKey: Uint8Array;\n    private provider: PasskeyProvider;\n\n    /**\n     * Get the key scheme of passkey,\n     */\n    getKeyScheme(): SignatureScheme {\n        return 'Passkey';\n    }\n\n    /**\n     * Creates an instance of Passkey signer. If no passkey wallet had created before,\n     * use `getPasskeyInstance`. For example:\n     * ```\n     * const provider = new BrowserPasskeyProvider('IOTA Passkey Example',{\n     *     rp: {\n     *         name: 'IOTA Passkey Example',\n     *         id: window.location.hostname,\n     *     },\n     * });\n     * const signer = await PasskeyKeypair.getPasskeyInstance(provider);\n     * ```\n     *\n     * If there are existing passkey wallet, use `signAndRecover` to identify the correct\n     * public key and then initialize the instance. See usage in `signAndRecover`.\n     */\n    constructor(publicKey: Uint8Array, provider: PasskeyProvider) {\n        super();\n        this.publicKey = publicKey;\n        this.provider = provider;\n    }\n\n    /**\n     * Creates an instance of Passkey signer invoking the passkey from navigator.\n     * Note that this will invoke the passkey device to create a fresh credential.\n     * Should only be called if passkey wallet is created for the first time.\n     *\n     * @param provider - the passkey provider.\n     * @returns the passkey instance.\n     */\n    static async getPasskeyInstance(provider: PasskeyProvider): Promise<PasskeyKeypair> {\n        // create a passkey secp256r1 with the provider.\n        const credential = await provider.create();\n\n        if (!credential.response.getPublicKey()) {\n            throw new Error('Invalid credential create response');\n        } else {\n            const derSPKI = credential.response.getPublicKey()!;\n            const pubkeyUncompressed = parseDerSPKI(new Uint8Array(derSPKI));\n            const pubkey = secp256r1.ProjectivePoint.fromHex(pubkeyUncompressed);\n            const pubkeyCompressed = pubkey.toRawBytes(true);\n            return new PasskeyKeypair(pubkeyCompressed, provider);\n        }\n    }\n\n    /**\n     * Return the public key for this passkey.\n     */\n    getPublicKey(): PublicKey {\n        return new PasskeyPublicKey(this.publicKey);\n    }\n\n    /**\n     * Return the signature for the provided data (i.e. blake2b(intent_message)).\n     * This is sent to passkey as the challenge field.\n     */\n    async sign(data: Uint8Array) {\n        // asks the passkey to sign over challenge as the data.\n        const credential = await this.provider.get(data);\n\n        // parse authenticatorData (as bytes), clientDataJSON (decoded as string).\n        const authenticatorData = new Uint8Array(credential.response.authenticatorData);\n        const clientDataJSON = new Uint8Array(credential.response.clientDataJSON); // response.clientDataJSON is already UTF-8 encoded JSON\n        const decoder = new TextDecoder();\n        const clientDataJSONString: string = decoder.decode(clientDataJSON);\n\n        // parse the signature from DER format, normalize and convert to compressed format (33 bytes).\n        const sig = secp256r1.Signature.fromDER(new Uint8Array(credential.response.signature));\n        const normalized = sig.normalizeS().toCompactRawBytes();\n\n        if (\n            normalized.length !== PASSKEY_SIGNATURE_SIZE ||\n            this.publicKey.length !== PASSKEY_PUBLIC_KEY_SIZE\n        ) {\n            throw new Error('Invalid signature or public key length');\n        }\n\n        // construct userSignature as flag || sig || pubkey for the secp256r1 signature.\n        const arr = new Uint8Array(1 + normalized.length + this.publicKey.length);\n        arr.set([SIGNATURE_SCHEME_TO_FLAG['Secp256r1']]);\n        arr.set(normalized, 1);\n        arr.set(this.publicKey, 1 + normalized.length);\n\n        // serialize all fields into a passkey signature according to https://github.com/sui-foundation/sips/blob/main/sips/sip-9.md#signature-encoding\n        return PasskeyAuthenticator.serialize({\n            authenticatorData: authenticatorData,\n            clientDataJson: clientDataJSONString,\n            userSignature: arr,\n        }).toBytes();\n    }\n\n    /**\n     * This overrides the base class implementation that accepts the raw bytes and signs its\n     * digest of the intent message, then serialize it with the passkey flag.\n     */\n    async signWithIntent(bytes: Uint8Array, intent: IntentScope): Promise<SignatureWithBytes> {\n        // prepend it into an intent message and computes the digest.\n        const intentMessage = messageWithIntent(intent, bytes);\n        const digest = blake2b(intentMessage, { dkLen: 32 });\n\n        // sign the digest.\n        const signature = await this.sign(digest);\n\n        // prepend with the passkey flag.\n        const serializedSignature = new Uint8Array(1 + signature.length);\n        serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[this.getKeyScheme()]]);\n        serializedSignature.set(signature, 1);\n        return {\n            signature: toB64(serializedSignature),\n            bytes: toB64(bytes),\n        };\n    }\n\n    /**\n     * Given a message, asks the passkey device to sign it and return all (up to 4) possible public keys.\n     * See: https://bitcoin.stackexchange.com/questions/81232/how-is-public-key-extracted-from-message-digital-signature-address\n     *\n     * This is useful if the user previously created passkey wallet with the origin, but the wallet session\n     * does not have the public key / address. By calling this method twice with two different messages, the\n     * wallet can compare the returned public keys and uniquely identify the previously created passkey wallet\n     * using `findCommonPublicKey`.\n     *\n     * Alternatively, one call can be made and all possible public keys should be checked onchain to see if\n     * there is any assets.\n     *\n     * Once the correct public key is identified, a passkey instance can then be initialized with this public key.\n     *\n     * Example usage to recover wallet with two signing calls:\n     * ```\n     * const provider = new BrowserPasskeyProvider('IOTA Passkey Example',{\n     *     rp: {\n     *         name: 'IOTA Passkey Example',\n     *         id: window.location.hostname,\n     *     },\n     * });\n     * const testMessage = new TextEncoder().encode('Hello world!');\n     * const possiblePks = await PasskeyKeypair.signAndRecover(provider, testMessage);\n     * const testMessage2 = new TextEncoder().encode('Hello world 2!');\n     * const possiblePks2 = await PasskeyKeypair.signAndRecover(provider, testMessage2);\n     * const commonPk = findCommonPublicKey(possiblePks, possiblePks2);\n     * const signer = new PasskeyKeypair(provider, commonPk.toRawBytes());\n     * ```\n     *\n     * @param provider - the passkey provider.\n     * @param message - the message to sign.\n     * @returns all possible public keys.\n     */\n    static async signAndRecover(\n        provider: PasskeyProvider,\n        message: Uint8Array,\n    ): Promise<PublicKey[]> {\n        const credential = await provider.get(message);\n        const fullMessage = messageFromAssertionResponse(credential.response);\n        const sig = secp256r1.Signature.fromDER(new Uint8Array(credential.response.signature));\n\n        const res = [];\n        for (let i = 0; i < 4; i++) {\n            const s = sig.addRecoveryBit(i);\n            try {\n                const pubkey = s.recoverPublicKey(sha256(fullMessage));\n                const pk = new PasskeyPublicKey(pubkey.toRawBytes(true));\n                res.push(pk);\n            } catch {\n                continue;\n            }\n        }\n        return res;\n    }\n}\n\n/**\n * Finds the unique public key that exists in both arrays, throws error if the common\n * pubkey does not equal to one.\n *\n * @param arr1 - The first pubkeys array.\n * @param arr2 - The second pubkeys array.\n * @returns The only common pubkey in both arrays.\n */\nexport function findCommonPublicKey(arr1: PublicKey[], arr2: PublicKey[]): PublicKey {\n    const matchingPubkeys: PublicKey[] = [];\n    for (const pubkey1 of arr1) {\n        for (const pubkey2 of arr2) {\n            if (pubkey1.equals(pubkey2)) {\n                matchingPubkeys.push(pubkey1);\n            }\n        }\n    }\n    if (matchingPubkeys.length !== 1) {\n        throw new Error('No unique public key found');\n    }\n    return matchingPubkeys[0];\n}\n\n/**\n * Constructs the message that the passkey signature is produced over as authenticatorData || sha256(clientDataJSON).\n */\nfunction messageFromAssertionResponse(response: AuthenticatorAssertionResponse): Uint8Array {\n    const authenticatorData = new Uint8Array(response.authenticatorData);\n    const clientDataJSON = new Uint8Array(response.clientDataJSON);\n    const clientDataJSONDigest = sha256(clientDataJSON);\n    return new Uint8Array([...authenticatorData, ...clientDataJSONDigest]);\n}\n"],
  "mappings": "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",
  "names": []
}
