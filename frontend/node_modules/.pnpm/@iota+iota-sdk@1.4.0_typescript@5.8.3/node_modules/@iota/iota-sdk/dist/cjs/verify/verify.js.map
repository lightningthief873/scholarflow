{
  "version": 3,
  "sources": ["../../../src/verify/verify.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64 } from '@iota/bcs';\n\nimport type { PublicKey, SignatureFlag, SignatureScheme } from '../cryptography/index.js';\nimport { parseSerializedSignature, SIGNATURE_FLAG_TO_SCHEME } from '../cryptography/index.js';\nimport { Ed25519PublicKey } from '../keypairs/ed25519/publickey.js';\nimport { Secp256k1PublicKey } from '../keypairs/secp256k1/publickey.js';\nimport { Secp256r1PublicKey } from '../keypairs/secp256r1/publickey.js';\n// eslint-disable-next-line import/no-cycle\nimport { MultiSigPublicKey } from '../multisig/publickey.js';\nimport { PasskeyPublicKey } from '../keypairs/passkey/publickey.js';\n\nexport async function verifySignature(bytes: Uint8Array, signature: string): Promise<PublicKey> {\n    const parsedSignature = parseSignature(signature);\n\n    if (!(await parsedSignature.publicKey.verify(bytes, parsedSignature.serializedSignature))) {\n        throw new Error(`Signature is not valid for the provided data`);\n    }\n\n    return parsedSignature.publicKey;\n}\n\nexport async function verifyPersonalMessageSignature(\n    message: Uint8Array,\n    signature: string,\n): Promise<PublicKey> {\n    const parsedSignature = parseSignature(signature);\n\n    if (\n        !(await parsedSignature.publicKey.verifyPersonalMessage(\n            message,\n            parsedSignature.serializedSignature,\n        ))\n    ) {\n        throw new Error(`Signature is not valid for the provided message`);\n    }\n\n    return parsedSignature.publicKey;\n}\n\nexport async function verifyTransactionSignature(\n    transaction: Uint8Array,\n    signature: string,\n): Promise<PublicKey> {\n    const parsedSignature = parseSignature(signature);\n\n    if (\n        !(await parsedSignature.publicKey.verifyTransaction(\n            transaction,\n            parsedSignature.serializedSignature,\n        ))\n    ) {\n        throw new Error(`Signature is not valid for the provided Transaction`);\n    }\n\n    return parsedSignature.publicKey;\n}\n\nfunction parseSignature(signature: string) {\n    const parsedSignature = parseSerializedSignature(signature);\n\n    if (parsedSignature.signatureScheme === 'MultiSig') {\n        return {\n            ...parsedSignature,\n            publicKey: new MultiSigPublicKey(parsedSignature.multisig.multisig_pk),\n        };\n    }\n\n    const publicKey = publicKeyFromRawBytes(\n        parsedSignature.signatureScheme,\n        parsedSignature.publicKey,\n    );\n    return {\n        ...parsedSignature,\n        publicKey,\n    };\n}\n\nexport function publicKeyFromRawBytes(\n    signatureScheme: SignatureScheme,\n    bytes: Uint8Array,\n): PublicKey {\n    switch (signatureScheme) {\n        case 'ED25519':\n            return new Ed25519PublicKey(bytes);\n        case 'Secp256k1':\n            return new Secp256k1PublicKey(bytes);\n        case 'Secp256r1':\n            return new Secp256r1PublicKey(bytes);\n        case 'MultiSig':\n            return new MultiSigPublicKey(bytes);\n        case 'Passkey':\n            return new PasskeyPublicKey(bytes);\n        default:\n            throw new Error(`Unsupported signature scheme ${signatureScheme}`);\n    }\n}\n\nexport function publicKeyFromIotaBytes(publicKey: string | Uint8Array) {\n    const bytes = typeof publicKey === 'string' ? fromB64(publicKey) : publicKey;\n\n    const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0] as SignatureFlag];\n\n    return publicKeyFromRawBytes(signatureScheme, bytes.slice(1));\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,iBAAwB;AAGxB,0BAAmE;AACnE,uBAAiC;AACjC,IAAAA,oBAAmC;AACnC,IAAAA,oBAAmC;AAEnC,IAAAA,oBAAkC;AAClC,IAAAA,oBAAiC;AAEjC,eAAsB,gBAAgB,OAAmB,WAAuC;AAC5F,QAAM,kBAAkB,eAAe,SAAS;AAEhD,MAAI,CAAE,MAAM,gBAAgB,UAAU,OAAO,OAAO,gBAAgB,mBAAmB,GAAI;AACvF,UAAM,IAAI,MAAM,8CAA8C;AAAA,EAClE;AAEA,SAAO,gBAAgB;AAC3B;AAEA,eAAsB,+BAClB,SACA,WACkB;AAClB,QAAM,kBAAkB,eAAe,SAAS;AAEhD,MACI,CAAE,MAAM,gBAAgB,UAAU;AAAA,IAC9B;AAAA,IACA,gBAAgB;AAAA,EACpB,GACF;AACE,UAAM,IAAI,MAAM,iDAAiD;AAAA,EACrE;AAEA,SAAO,gBAAgB;AAC3B;AAEA,eAAsB,2BAClB,aACA,WACkB;AAClB,QAAM,kBAAkB,eAAe,SAAS;AAEhD,MACI,CAAE,MAAM,gBAAgB,UAAU;AAAA,IAC9B;AAAA,IACA,gBAAgB;AAAA,EACpB,GACF;AACE,UAAM,IAAI,MAAM,qDAAqD;AAAA,EACzE;AAEA,SAAO,gBAAgB;AAC3B;AAEA,SAAS,eAAe,WAAmB;AACvC,QAAM,sBAAkB,8CAAyB,SAAS;AAE1D,MAAI,gBAAgB,oBAAoB,YAAY;AAChD,WAAO;AAAA,MACH,GAAG;AAAA,MACH,WAAW,IAAI,oCAAkB,gBAAgB,SAAS,WAAW;AAAA,IACzE;AAAA,EACJ;AAEA,QAAM,YAAY;AAAA,IACd,gBAAgB;AAAA,IAChB,gBAAgB;AAAA,EACpB;AACA,SAAO;AAAA,IACH,GAAG;AAAA,IACH;AAAA,EACJ;AACJ;AAEO,SAAS,sBACZ,iBACA,OACS;AACT,UAAQ,iBAAiB;AAAA,IACrB,KAAK;AACD,aAAO,IAAI,kCAAiB,KAAK;AAAA,IACrC,KAAK;AACD,aAAO,IAAI,qCAAmB,KAAK;AAAA,IACvC,KAAK;AACD,aAAO,IAAI,qCAAmB,KAAK;AAAA,IACvC,KAAK;AACD,aAAO,IAAI,oCAAkB,KAAK;AAAA,IACtC,KAAK;AACD,aAAO,IAAI,mCAAiB,KAAK;AAAA,IACrC;AACI,YAAM,IAAI,MAAM,gCAAgC,eAAe,EAAE;AAAA,EACzE;AACJ;AAEO,SAAS,uBAAuB,WAAgC;AACnE,QAAM,QAAQ,OAAO,cAAc,eAAW,oBAAQ,SAAS,IAAI;AAEnE,QAAM,kBAAkB,6CAAyB,MAAM,CAAC,CAAkB;AAE1E,SAAO,sBAAsB,iBAAiB,MAAM,MAAM,CAAC,CAAC;AAChE;",
  "names": ["import_publickey"]
}
