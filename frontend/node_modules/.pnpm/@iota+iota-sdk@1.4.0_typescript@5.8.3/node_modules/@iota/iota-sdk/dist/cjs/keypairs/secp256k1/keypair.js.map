{
  "version": 3,
  "sources": ["../../../../src/keypairs/secp256k1/keypair.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex } from '@noble/hashes/utils';\nimport { HDKey } from '@scure/bip32';\n\nimport { encodeIotaPrivateKey, Keypair } from '../../cryptography/keypair.js';\nimport { isValidBIP32Path, mnemonicToSeed } from '../../cryptography/mnemonics.js';\nimport type { PublicKey } from '../../cryptography/publickey.js';\nimport type { SignatureScheme } from '../../cryptography/signature-scheme.js';\nimport { Secp256k1PublicKey } from './publickey.js';\n\nexport const DEFAULT_SECP256K1_DERIVATION_PATH = \"m/54'/4218'/0'/0/0\";\n\n/**\n * Secp256k1 Keypair data\n */\nexport interface Secp256k1KeypairData {\n    publicKey: Uint8Array;\n    secretKey: Uint8Array;\n}\n\n/**\n * An Secp256k1 Keypair used for signing transactions.\n */\nexport class Secp256k1Keypair extends Keypair {\n    private keypair: Secp256k1KeypairData;\n\n    /**\n     * Create a new keypair instance.\n     * Generate random keypair if no {@link Secp256k1Keypair} is provided.\n     *\n     * @param keypair secp256k1 keypair\n     */\n    constructor(keypair?: Secp256k1KeypairData) {\n        super();\n        if (keypair) {\n            this.keypair = keypair;\n        } else {\n            const secretKey: Uint8Array = secp256k1.utils.randomPrivateKey();\n            const publicKey: Uint8Array = secp256k1.getPublicKey(secretKey, true);\n\n            this.keypair = { publicKey, secretKey };\n        }\n    }\n\n    /**\n     * Get the key scheme of the keypair Secp256k1\n     */\n    getKeyScheme(): SignatureScheme {\n        return 'Secp256k1';\n    }\n\n    /**\n     * Generate a new random keypair\n     */\n    static generate(): Secp256k1Keypair {\n        return new Secp256k1Keypair();\n    }\n\n    /**\n     * Create a keypair from a raw secret key byte array.\n     *\n     * This method should only be used to recreate a keypair from a previously\n     * generated secret key. Generating keypairs from a random seed should be done\n     * with the {@link Keypair.fromSeed} method.\n     *\n     * @throws error if the provided secret key is invalid and validation is not skipped.\n     *\n     * @param secretKey secret key byte array\n     * @param options: skip secret key validation\n     */\n\n    static fromSecretKey(\n        secretKey: Uint8Array,\n        options?: { skipValidation?: boolean },\n    ): Secp256k1Keypair {\n        const publicKey: Uint8Array = secp256k1.getPublicKey(secretKey, true);\n        if (!options || !options.skipValidation) {\n            const encoder = new TextEncoder();\n            const signData = encoder.encode('iota validation');\n            const msgHash = bytesToHex(blake2b(signData, { dkLen: 32 }));\n            const signature = secp256k1.sign(msgHash, secretKey);\n            if (!secp256k1.verify(signature, msgHash, publicKey, { lowS: true })) {\n                throw new Error('Provided secretKey is invalid');\n            }\n        }\n        return new Secp256k1Keypair({ publicKey, secretKey });\n    }\n\n    /**\n     * Generate a keypair from a 32 byte seed.\n     *\n     * @param seed seed byte array\n     */\n    static fromSeed(seed: Uint8Array): Secp256k1Keypair {\n        const publicKey = secp256k1.getPublicKey(seed, true);\n        return new Secp256k1Keypair({ publicKey, secretKey: seed });\n    }\n\n    /**\n     * The public key for this keypair\n     */\n    getPublicKey(): PublicKey {\n        return new Secp256k1PublicKey(this.keypair.publicKey);\n    }\n    /**\n     * The Bech32 secret key string for this Secp256k1 keypair\n     */\n    getSecretKey(): string {\n        return encodeIotaPrivateKey(this.keypair.secretKey, this.getKeyScheme());\n    }\n\n    /**\n     * Return the signature for the provided data.\n     */\n    async sign(data: Uint8Array) {\n        const msgHash = sha256(data);\n        const sig = secp256k1.sign(msgHash, this.keypair.secretKey, {\n            lowS: true,\n        });\n        return sig.toCompactRawBytes();\n    }\n\n    /**\n     * Derive Secp256k1 keypair from mnemonics and path. The mnemonics must be normalized\n     * and validated against the english wordlist.\n     *\n     * If path is none, it will default to m/54'/4218'/0'/0/0, otherwise the path must\n     * be compliant to BIP-32 in form m/54'/4218'/{account_index}'/{change_index}/{address_index}.\n     */\n    static deriveKeypair(mnemonics: string, path?: string): Secp256k1Keypair {\n        if (path == null) {\n            path = DEFAULT_SECP256K1_DERIVATION_PATH;\n        }\n        if (!isValidBIP32Path(path)) {\n            throw new Error('Invalid derivation path');\n        }\n        const key = HDKey.fromMasterSeed(mnemonicToSeed(mnemonics)).derive(path);\n        if (key.publicKey == null || key.privateKey == null) {\n            throw new Error('Invalid key');\n        }\n        return new Secp256k1Keypair({\n            publicKey: key.publicKey,\n            secretKey: key.privateKey,\n        });\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,uBAA0B;AAC1B,qBAAwB;AACxB,oBAAuB;AACvB,mBAA2B;AAC3B,mBAAsB;AAEtB,qBAA8C;AAC9C,uBAAiD;AAGjD,uBAAmC;AAE5B,MAAM,oCAAoC;AAa1C,MAAM,yBAAyB,uBAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS1C,YAAY,SAAgC;AACxC,UAAM;AACN,QAAI,SAAS;AACT,WAAK,UAAU;AAAA,IACnB,OAAO;AACH,YAAM,YAAwB,2BAAU,MAAM,iBAAiB;AAC/D,YAAM,YAAwB,2BAAU,aAAa,WAAW,IAAI;AAEpE,WAAK,UAAU,EAAE,WAAW,UAAU;AAAA,IAC1C;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,eAAgC;AAC5B,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,WAA6B;AAChC,WAAO,IAAI,iBAAiB;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,OAAO,cACH,WACA,SACgB;AAChB,UAAM,YAAwB,2BAAU,aAAa,WAAW,IAAI;AACpE,QAAI,CAAC,WAAW,CAAC,QAAQ,gBAAgB;AACrC,YAAM,UAAU,IAAI,YAAY;AAChC,YAAM,WAAW,QAAQ,OAAO,iBAAiB;AACjD,YAAM,cAAU,6BAAW,wBAAQ,UAAU,EAAE,OAAO,GAAG,CAAC,CAAC;AAC3D,YAAM,YAAY,2BAAU,KAAK,SAAS,SAAS;AACnD,UAAI,CAAC,2BAAU,OAAO,WAAW,SAAS,WAAW,EAAE,MAAM,KAAK,CAAC,GAAG;AAClE,cAAM,IAAI,MAAM,+BAA+B;AAAA,MACnD;AAAA,IACJ;AACA,WAAO,IAAI,iBAAiB,EAAE,WAAW,UAAU,CAAC;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,SAAS,MAAoC;AAChD,UAAM,YAAY,2BAAU,aAAa,MAAM,IAAI;AACnD,WAAO,IAAI,iBAAiB,EAAE,WAAW,WAAW,KAAK,CAAC;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAKA,eAA0B;AACtB,WAAO,IAAI,oCAAmB,KAAK,QAAQ,SAAS;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA,EAIA,eAAuB;AACnB,eAAO,qCAAqB,KAAK,QAAQ,WAAW,KAAK,aAAa,CAAC;AAAA,EAC3E;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAK,MAAkB;AACzB,UAAM,cAAU,sBAAO,IAAI;AAC3B,UAAM,MAAM,2BAAU,KAAK,SAAS,KAAK,QAAQ,WAAW;AAAA,MACxD,MAAM;AAAA,IACV,CAAC;AACD,WAAO,IAAI,kBAAkB;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,cAAc,WAAmB,MAAiC;AACrE,QAAI,QAAQ,MAAM;AACd,aAAO;AAAA,IACX;AACA,QAAI,KAAC,mCAAiB,IAAI,GAAG;AACzB,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC7C;AACA,UAAM,MAAM,mBAAM,mBAAe,iCAAe,SAAS,CAAC,EAAE,OAAO,IAAI;AACvE,QAAI,IAAI,aAAa,QAAQ,IAAI,cAAc,MAAM;AACjD,YAAM,IAAI,MAAM,aAAa;AAAA,IACjC;AACA,WAAO,IAAI,iBAAiB;AAAA,MACxB,WAAW,IAAI;AAAA,MACf,WAAW,IAAI;AAAA,IACnB,CAAC;AAAA,EACL;AACJ;",
  "names": []
}
