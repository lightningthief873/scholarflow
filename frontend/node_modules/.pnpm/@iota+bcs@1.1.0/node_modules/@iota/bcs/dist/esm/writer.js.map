{
  "version": 3,
  "sources": ["../../src/writer.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n    /** The initial size (in bytes) of the buffer that will be allocated */\n    initialSize?: number;\n    /** The maximum size (in bytes) that the buffer is allowed to grow to */\n    maxSize?: number;\n    /** The amount of bytes that will be allocated whenever additional memory is required */\n    allocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n    private dataView: DataView;\n    private bytePosition: number = 0;\n    private size: number;\n    private maxSize: number;\n    private allocateSize: number;\n\n    constructor({\n        initialSize = 1024,\n        maxSize = Infinity,\n        allocateSize = 1024,\n    }: BcsWriterOptions = {}) {\n        this.size = initialSize;\n        this.maxSize = maxSize;\n        this.allocateSize = allocateSize;\n        this.dataView = new DataView(new ArrayBuffer(initialSize));\n    }\n\n    private ensureSizeOrGrow(bytes: number) {\n        const requiredSize = this.bytePosition + bytes;\n        if (requiredSize > this.size) {\n            const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n            if (requiredSize > nextSize) {\n                throw new Error(\n                    `SizeLimitExceeded: Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n                );\n            }\n\n            this.size = nextSize;\n            const nextBuffer = new ArrayBuffer(this.size);\n            new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n            this.dataView = new DataView(nextBuffer);\n        }\n    }\n\n    /**\n     * Shift current cursor position by `bytes`.\n     *\n     * @param {Number} bytes Number of bytes to\n     * @returns {this} Self for possible chaining.\n     */\n    shift(bytes: number): this {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n     * Write a U8 value into a buffer and shift cursor position by 1.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write8(value: number | bigint): this {\n        this.ensureSizeOrGrow(1);\n        this.dataView.setUint8(this.bytePosition, Number(value));\n        return this.shift(1);\n    }\n    /**\n     * Write a U16 value into a buffer and shift cursor position by 2.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write16(value: number | bigint): this {\n        this.ensureSizeOrGrow(2);\n        this.dataView.setUint16(this.bytePosition, Number(value), true);\n        return this.shift(2);\n    }\n    /**\n     * Write a U32 value into a buffer and shift cursor position by 4.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write32(value: number | bigint): this {\n        this.ensureSizeOrGrow(4);\n        this.dataView.setUint32(this.bytePosition, Number(value), true);\n        return this.shift(4);\n    }\n    /**\n     * Write a U64 value into a buffer and shift cursor position by 8.\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write64(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a U128 value into a buffer and shift cursor position by 16.\n     *\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write128(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a U256 value into a buffer and shift cursor position by 16.\n     *\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write256(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a ULEB value into a buffer and shift cursor position by number of bytes\n     * written.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    writeULEB(value: number): this {\n        ulebEncode(value).forEach((el) => this.write8(el));\n        return this;\n    }\n    /**\n     * Write a vector into a buffer by first writing the vector length and then calling\n     * a callback on each passed value.\n     *\n     * @param {Array<Any>} vector Array of elements to write.\n     * @param {WriteVecCb} cb Callback to call on each element of the vector.\n     * @returns {this}\n     */\n    writeVec(\n        vector: any[],\n        cb: (writer: BcsWriter, el: any, i: number, len: number) => void,\n    ): this {\n        this.writeULEB(vector.length);\n        Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n        return this;\n    }\n\n    /**\n     * Adds support for iterations over the object.\n     * @returns {Uint8Array}\n     */\n    *[Symbol.iterator](): Iterator<number, Iterable<number>> {\n        for (let i = 0; i < this.bytePosition; i++) {\n            yield this.dataView.getUint8(i);\n        }\n        return this.toBytes();\n    }\n\n    /**\n     * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n     * @returns {Uint8Array} Resulting bcs.\n     */\n    toBytes(): Uint8Array {\n        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n    }\n\n    /**\n     * Represent data as 'hex' or 'base64'\n     * @param encoding Encoding to use: 'base64' or 'hex'\n     */\n    toString(encoding: Encoding): string {\n        return encodeStr(this.toBytes(), encoding);\n    }\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n    const result = new Uint8Array(size);\n    let i = 0;\n    while (bigint > 0) {\n        result[i] = Number(bigint % BigInt(256));\n        bigint = bigint / BigInt(256);\n        i += 1;\n    }\n    return result;\n}\n"],
  "mappings": "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",
  "names": []
}
