{
  "version": 3,
  "sources": ["../../src/reader.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n    private dataView: DataView;\n    private bytePosition: number = 0;\n\n    /**\n     * @param {Uint8Array} data Data to use as a buffer.\n     */\n    constructor(data: Uint8Array) {\n        this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    }\n    /**\n     * Shift current cursor position by `bytes`.\n     *\n     * @param {Number} bytes Number of bytes to\n     * @returns {this} Self for possible chaining.\n     */\n    shift(bytes: number) {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n     * Read U8 value from the buffer and shift cursor by 1.\n     * @returns\n     */\n    read8(): number {\n        const value = this.dataView.getUint8(this.bytePosition);\n        this.shift(1);\n        return value;\n    }\n    /**\n     * Read U16 value from the buffer and shift cursor by 2.\n     * @returns\n     */\n    read16(): number {\n        const value = this.dataView.getUint16(this.bytePosition, true);\n        this.shift(2);\n        return value;\n    }\n    /**\n     * Read U32 value from the buffer and shift cursor by 4.\n     * @returns\n     */\n    read32(): number {\n        const value = this.dataView.getUint32(this.bytePosition, true);\n        this.shift(4);\n        return value;\n    }\n    /**\n     * Read U64 value from the buffer and shift cursor by 8.\n     * @returns\n     */\n    read64(): string {\n        const value1 = this.read32();\n        const value2 = this.read32();\n\n        const result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read U128 value from the buffer and shift cursor by 16.\n     */\n    read128(): string {\n        const value1 = BigInt(this.read64());\n        const value2 = BigInt(this.read64());\n        const result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read U128 value from the buffer and shift cursor by 32.\n     * @returns\n     */\n    read256(): string {\n        const value1 = BigInt(this.read128());\n        const value2 = BigInt(this.read128());\n        const result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read `num` number of bytes from the buffer and shift cursor by `num`.\n     * @param num Number of bytes to read.\n     */\n    readBytes(num: number): Uint8Array {\n        const start = this.bytePosition + this.dataView.byteOffset;\n        const value = new Uint8Array(this.dataView.buffer, start, num);\n\n        this.shift(num);\n\n        return value;\n    }\n    /**\n     * Read ULEB value - an integer of varying size. Used for enum indexes and\n     * vector lengths.\n     * @returns {Number} The ULEB value.\n     */\n    readULEB(): number {\n        const start = this.bytePosition + this.dataView.byteOffset;\n        const buffer = new Uint8Array(this.dataView.buffer, start);\n        const { value, length } = ulebDecode(buffer);\n\n        this.shift(length);\n\n        return value;\n    }\n    /**\n     * Read a BCS vector: read a length and then apply function `cb` X times\n     * where X is the length of the vector, defined as ULEB in BCS bytes.\n     * @param cb Callback to process elements of vector.\n     * @returns {Array<Any>} Array of the resulting values, returned by callback.\n     */\n    readVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n        const length = this.readULEB();\n        const result = [];\n        for (let i = 0; i < length; i++) {\n            result.push(cb(this, i, length));\n        }\n        return result;\n    }\n}\n"],
  "mappings": "AAIA,SAAS,kBAAkB;AAgCpB,MAAM,UAAU;AAAA;AAAA;AAAA;AAAA,EAOnB,YAAY,MAAkB;AAL9B,SAAQ,eAAuB;AAM3B,SAAK,WAAW,IAAI,SAAS,KAAK,QAAQ,KAAK,YAAY,KAAK,UAAU;AAAA,EAC9E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,OAAe;AACjB,SAAK,gBAAgB;AACrB,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,QAAgB;AACZ,UAAM,QAAQ,KAAK,SAAS,SAAS,KAAK,YAAY;AACtD,SAAK,MAAM,CAAC;AACZ,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,SAAiB;AACb,UAAM,QAAQ,KAAK,SAAS,UAAU,KAAK,cAAc,IAAI;AAC7D,SAAK,MAAM,CAAC;AACZ,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,SAAiB;AACb,UAAM,QAAQ,KAAK,SAAS,UAAU,KAAK,cAAc,IAAI;AAC7D,SAAK,MAAM,CAAC;AACZ,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,SAAiB;AACb,UAAM,SAAS,KAAK,OAAO;AAC3B,UAAM,SAAS,KAAK,OAAO;AAE3B,UAAM,SAAS,OAAO,SAAS,EAAE,IAAI,OAAO,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG;AAExE,WAAO,OAAO,OAAO,MAAM,EAAE,SAAS,EAAE;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAIA,UAAkB;AACd,UAAM,SAAS,OAAO,KAAK,OAAO,CAAC;AACnC,UAAM,SAAS,OAAO,KAAK,OAAO,CAAC;AACnC,UAAM,SAAS,OAAO,SAAS,EAAE,IAAI,OAAO,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG;AAEzE,WAAO,OAAO,OAAO,MAAM,EAAE,SAAS,EAAE;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,UAAkB;AACd,UAAM,SAAS,OAAO,KAAK,QAAQ,CAAC;AACpC,UAAM,SAAS,OAAO,KAAK,QAAQ,CAAC;AACpC,UAAM,SAAS,OAAO,SAAS,EAAE,IAAI,OAAO,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG;AAEzE,WAAO,OAAO,OAAO,MAAM,EAAE,SAAS,EAAE;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,KAAyB;AAC/B,UAAM,QAAQ,KAAK,eAAe,KAAK,SAAS;AAChD,UAAM,QAAQ,IAAI,WAAW,KAAK,SAAS,QAAQ,OAAO,GAAG;AAE7D,SAAK,MAAM,GAAG;AAEd,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAmB;AACf,UAAM,QAAQ,KAAK,eAAe,KAAK,SAAS;AAChD,UAAM,SAAS,IAAI,WAAW,KAAK,SAAS,QAAQ,KAAK;AACzD,UAAM,EAAE,OAAO,OAAO,IAAI,WAAW,MAAM;AAE3C,SAAK,MAAM,MAAM;AAEjB,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,IAAkE;AACtE,UAAM,SAAS,KAAK,SAAS;AAC7B,UAAM,SAAS,CAAC;AAChB,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC7B,aAAO,KAAK,GAAG,MAAM,GAAG,MAAM,CAAC;AAAA,IACnC;AACA,WAAO;AAAA,EACX;AACJ;",
  "names": []
}
