{
  "version": 3,
  "sources": ["../../src/bcs-type.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58.js';\nimport { fromB64, toB64 } from './b64.js';\nimport { fromHEX, toHEX } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n    name?: string;\n    validate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n    $inferType!: T;\n    $inferInput!: Input;\n    name: string;\n    read: (reader: BcsReader) => T;\n    serializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n    validate: (value: Input) => void;\n    #write: (value: Input, writer: BcsWriter) => void;\n    #serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n    constructor(\n        options: {\n            name: string;\n            read: (reader: BcsReader) => T;\n            write: (value: Input, writer: BcsWriter) => void;\n            serialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n            serializedSize?: (value: Input) => number | null;\n            validate?: (value: Input) => void;\n        } & BcsTypeOptions<T, Input>,\n    ) {\n        this.name = options.name;\n        this.read = options.read;\n        this.serializedSize = options.serializedSize ?? (() => null);\n        this.#write = options.write;\n        this.#serialize =\n            options.serialize ??\n            ((value, options) => {\n                const writer = new BcsWriter({\n                    initialSize: this.serializedSize(value) ?? undefined,\n                    ...options,\n                });\n                this.#write(value, writer);\n                return writer.toBytes();\n            });\n\n        this.validate = options.validate ?? (() => {});\n    }\n\n    write(value: Input, writer: BcsWriter) {\n        this.validate(value);\n        this.#write(value, writer);\n    }\n\n    serialize(value: Input, options?: BcsWriterOptions) {\n        this.validate(value);\n        return new SerializedBcs(this, this.#serialize(value, options));\n    }\n\n    parse(bytes: Uint8Array): T {\n        const reader = new BcsReader(bytes);\n        return this.read(reader);\n    }\n\n    fromHex(hex: string) {\n        return this.parse(fromHEX(hex));\n    }\n\n    fromBase58(b64: string) {\n        return this.parse(fromB58(b64));\n    }\n\n    fromBase64(b64: string) {\n        return this.parse(fromB64(b64));\n    }\n\n    transform<T2 = T, Input2 = Input>({\n        name,\n        input,\n        output,\n        validate,\n    }: {\n        input?: (val: Input2) => Input;\n        output?: (value: T) => T2;\n    } & BcsTypeOptions<T2, Input2>) {\n        return new BcsType<T2, Input2>({\n            name: name ?? this.name,\n            read: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n            write: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n            serializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n            serialize: (value, options) =>\n                this.#serialize(input ? input(value) : (value as never), options),\n            validate: (value) => {\n                validate?.(value);\n                this.validate(input ? input(value) : (value as never));\n            },\n        });\n    }\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@iota/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n    return !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n    #schema: BcsType<T, Input>;\n    #bytes: Uint8Array;\n\n    // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n    // of the @iota/bcs package are installed\n    get [SERIALIZED_BCS_BRAND]() {\n        return true;\n    }\n\n    constructor(type: BcsType<T, Input>, schema: Uint8Array) {\n        this.#schema = type;\n        this.#bytes = schema;\n    }\n\n    toBytes() {\n        return this.#bytes;\n    }\n\n    toHex() {\n        return toHEX(this.#bytes);\n    }\n\n    toBase64() {\n        return toB64(this.#bytes);\n    }\n\n    toBase58() {\n        return toB58(this.#bytes);\n    }\n\n    parse() {\n        return this.#schema.parse(this.#bytes);\n    }\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n    size,\n    ...options\n}: {\n    name: string;\n    size: number;\n    read: (reader: BcsReader) => T;\n    write: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n    return new BcsType<T, Input>({\n        ...options,\n        serializedSize: () => size,\n    });\n}\n\nexport function uIntBcsType({\n    readMethod,\n    writeMethod,\n    ...options\n}: {\n    name: string;\n    size: number;\n    readMethod: `read${8 | 16 | 32}`;\n    writeMethod: `write${8 | 16 | 32}`;\n    maxValue: number;\n} & BcsTypeOptions<number, number>) {\n    return fixedSizeBcsType<number>({\n        ...options,\n        read: (reader) => reader[readMethod](),\n        write: (value, writer) => writer[writeMethod](value),\n        validate: (value) => {\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(\n                    `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n                );\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function bigUIntBcsType({\n    readMethod,\n    writeMethod,\n    ...options\n}: {\n    name: string;\n    size: number;\n    readMethod: `read${64 | 128 | 256}`;\n    writeMethod: `write${64 | 128 | 256}`;\n    maxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n    return fixedSizeBcsType<string, string | number | bigint>({\n        ...options,\n        read: (reader) => reader[readMethod](),\n        write: (value, writer) => writer[writeMethod](BigInt(value)),\n        validate: (val) => {\n            const value = BigInt(val);\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(\n                    `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n                );\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n    serialize,\n    ...options\n}: {\n    name: string;\n    read: (reader: BcsReader) => T;\n    serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n    const type = new BcsType<T, Input>({\n        ...options,\n        serialize,\n        write: (value, writer) => {\n            for (const byte of type.serialize(value).toBytes()) {\n                writer.write8(byte);\n            }\n        },\n    });\n\n    return type;\n}\n\nexport function stringLikeBcsType({\n    toBytes,\n    fromBytes,\n    ...options\n}: {\n    name: string;\n    toBytes: (value: string) => Uint8Array;\n    fromBytes: (bytes: Uint8Array) => string;\n    serializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n    return new BcsType<string>({\n        ...options,\n        read: (reader) => {\n            const length = reader.readULEB();\n            const bytes = reader.readBytes(length);\n\n            return fromBytes(bytes);\n        },\n        write: (hex, writer) => {\n            const bytes = toBytes(hex);\n            writer.writeULEB(bytes.length);\n            for (let i = 0; i < bytes.length; i++) {\n                writer.write8(bytes[i]);\n            }\n        },\n        serialize: (value) => {\n            const bytes = toBytes(value);\n            const size = ulebEncode(bytes.length);\n            const result = new Uint8Array(size.length + bytes.length);\n            result.set(size, 0);\n            result.set(bytes, size.length);\n\n            return result;\n        },\n        validate: (value) => {\n            if (typeof value !== 'string') {\n                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n    let lazyType: BcsType<T, Input> | null = null;\n    function getType() {\n        if (!lazyType) {\n            lazyType = cb();\n        }\n        return lazyType;\n    }\n\n    return new BcsType<T, Input>({\n        name: 'lazy' as never,\n        read: (data) => getType().read(data),\n        serializedSize: (value) => getType().serializedSize(value),\n        write: (value, writer) => getType().write(value, writer),\n        serialize: (value, options) => getType().serialize(value, options).toBytes(),\n    });\n}\n"],
  "mappings": "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",
  "names": ["options"]
}
