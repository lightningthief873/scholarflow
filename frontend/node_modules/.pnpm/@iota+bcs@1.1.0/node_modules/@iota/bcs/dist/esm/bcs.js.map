{
  "version": 3,
  "sources": ["../../src/bcs.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n    BcsType,\n    bigUIntBcsType,\n    dynamicSizeBcsType,\n    fixedSizeBcsType,\n    lazyBcsType,\n    stringLikeBcsType,\n    uIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n    /**\n     * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n     * @example\n     * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n     */\n    u8(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u8',\n            readMethod: 'read8',\n            writeMethod: 'write8',\n            size: 1,\n            maxValue: 2 ** 8 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n     * @example\n     * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n     */\n    u16(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u16',\n            readMethod: 'read16',\n            writeMethod: 'write16',\n            size: 2,\n            maxValue: 2 ** 16 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n     * @example\n     * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n     */\n    u32(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u32',\n            readMethod: 'read32',\n            writeMethod: 'write32',\n            size: 4,\n            maxValue: 2 ** 32 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n     * @example\n     * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n     */\n    u64(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u64',\n            readMethod: 'read64',\n            writeMethod: 'write64',\n            size: 8,\n            maxValue: 2n ** 64n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n     * @example\n     * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n     */\n    u128(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u128',\n            readMethod: 'read128',\n            writeMethod: 'write128',\n            size: 16,\n            maxValue: 2n ** 128n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n     * @example\n     * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n     */\n    u256(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u256',\n            readMethod: 'read256',\n            writeMethod: 'write256',\n            size: 32,\n            maxValue: 2n ** 256n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write boolean values.\n     * @example\n     * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n     */\n    bool(options?: BcsTypeOptions<boolean>) {\n        return fixedSizeBcsType<boolean>({\n            name: 'bool',\n            size: 1,\n            read: (reader) => reader.read8() === 1,\n            write: (value, writer) => writer.write8(value ? 1 : 0),\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'boolean') {\n                    throw new TypeError(`Expected boolean, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n     * @example\n     *\n     */\n    uleb128(options?: BcsTypeOptions<number>) {\n        return dynamicSizeBcsType<number>({\n            name: 'uleb128',\n            read: (reader) => reader.readULEB(),\n            serialize: (value) => {\n                return Uint8Array.from(ulebEncode(value));\n            },\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a fixed length byte array\n     * @param size The number of bytes this types represents\n     * @example\n     * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n     */\n    bytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n        return fixedSizeBcsType<Uint8Array>({\n            name: `bytes[${size}]`,\n            size,\n            read: (reader) => reader.readBytes(size),\n            write: (value, writer) => {\n                for (let i = 0; i < size; i++) {\n                    writer.write8(value[i] ?? 0);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a variable length byte array\n     *\n     * @example\n     * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n     */\n    byteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n        return new BcsType<Uint8Array, Iterable<number>>({\n            name: `bytesVector`,\n            read: (reader) => {\n                const length = reader.readULEB();\n\n                return reader.readBytes(length);\n            },\n            write: (value, writer) => {\n                const array = new Uint8Array(value);\n                writer.writeULEB(array.length);\n                for (let i = 0; i < array.length; i++) {\n                    writer.write8(array[i] ?? 0);\n                }\n            },\n            ...options,\n            serializedSize: (value) => {\n                const length = 'length' in value ? (value.length as number) : null;\n                return length == null ? null : ulebEncode(length).length + length;\n            },\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n     * @example\n     * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n     */\n    string(options?: BcsTypeOptions<string>) {\n        return stringLikeBcsType({\n            name: 'string',\n            toBytes: (value) => new TextEncoder().encode(value),\n            fromBytes: (bytes) => new TextDecoder().decode(bytes),\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that represents a fixed length array of a given type\n     * @param size The number of elements in the array\n     * @param type The BcsType of each element in the array\n     * @example\n     * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n     */\n    fixedArray<T, Input>(\n        size: number,\n        type: BcsType<T, Input>,\n        options?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n    ) {\n        return new BcsType<T[], Iterable<Input> & { length: number }>({\n            name: `${type.name}[${size}]`,\n            read: (reader) => {\n                const result: T[] = new Array(size);\n                for (let i = 0; i < size; i++) {\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer) => {\n                for (const item of value) {\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing an optional value\n     * @param type The BcsType of the optional value\n     * @example\n     * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n     * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n     */\n    option<T, Input>(type: BcsType<T, Input>) {\n        return bcs\n            .enum(`Option<${type.name}>`, {\n                None: null,\n                Some: type,\n            })\n            .transform({\n                input: (value: Input | null | undefined) => {\n                    if (value == null) {\n                        return { None: true };\n                    }\n\n                    return { Some: value };\n                },\n                output: (value) => {\n                    if (value.$kind === 'Some') {\n                        return value.Some;\n                    }\n\n                    return null;\n                },\n            });\n    },\n\n    /**\n     * Creates a BcsType representing a variable length vector of a given type\n     * @param type The BcsType of each element in the vector\n     *\n     * @example\n     * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n     */\n    vector<T, Input>(\n        type: BcsType<T, Input>,\n        options?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n    ) {\n        return new BcsType<T[], Iterable<Input> & { length: number }>({\n            name: `vector<${type.name}>`,\n            read: (reader) => {\n                const length = reader.readULEB();\n                const result: T[] = new Array(length);\n                for (let i = 0; i < length; i++) {\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer) => {\n                writer.writeULEB(value.length);\n                for (const item of value) {\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a tuple of a given set of types\n     * @param types The BcsTypes for each element in the tuple\n     *\n     * @example\n     * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n     * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n     */\n    tuple<const Types extends readonly BcsType<any>[]>(\n        types: Types,\n        options?: BcsTypeOptions<\n            {\n                -readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n            },\n            {\n                [K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n            }\n        >,\n    ) {\n        return new BcsType<\n            {\n                -readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n            },\n            {\n                [K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n            }\n        >({\n            name: `(${types.map((t) => t.name).join(', ')})`,\n            serializedSize: (values) => {\n                let total = 0;\n                for (let i = 0; i < types.length; i++) {\n                    const size = types[i].serializedSize(values[i]);\n                    if (size == null) {\n                        return null;\n                    }\n\n                    total += size;\n                }\n\n                return total;\n            },\n            read: (reader) => {\n                const result: unknown[] = [];\n                for (const type of types) {\n                    result.push(type.read(reader));\n                }\n                return result as never;\n            },\n            write: (value, writer) => {\n                for (let i = 0; i < types.length; i++) {\n                    types[i].write(value[i], writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!Array.isArray(value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== types.length) {\n                    throw new TypeError(\n                        `Expected array of length ${types.length}, found ${value.length}`,\n                    );\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a struct of a given set of fields\n     * @param name The name of the struct\n     * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n     *\n     * @example\n     * const struct = bcs.struct('MyStruct', {\n     *  a: bcs.u8(),\n     *  b: bcs.string(),\n     * })\n     * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n     */\n    struct<T extends Record<string, BcsType<any>>>(\n        name: string,\n        fields: T,\n        options?: Omit<\n            BcsTypeOptions<\n                {\n                    [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n                },\n                {\n                    [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n                }\n            >,\n            'name'\n        >,\n    ) {\n        const canonicalOrder = Object.entries(fields);\n\n        return new BcsType<\n            {\n                [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n            },\n            {\n                [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n            }\n        >({\n            name,\n            serializedSize: (values) => {\n                let total = 0;\n                for (const [field, type] of canonicalOrder) {\n                    const size = type.serializedSize(values[field]);\n                    if (size == null) {\n                        return null;\n                    }\n\n                    total += size;\n                }\n\n                return total;\n            },\n            read: (reader) => {\n                const result: Record<string, unknown> = {};\n                for (const [field, type] of canonicalOrder) {\n                    result[field] = type.read(reader);\n                }\n\n                return result as never;\n            },\n            write: (value, writer) => {\n                for (const [field, type] of canonicalOrder) {\n                    type.write(value[field], writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'object' || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing an enum of a given set of options\n     * @param name The name of the enum\n     * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n     * null can be used to represent a variant with no data.\n     *\n     * @example\n     * const enum = bcs.enum('MyEnum', {\n     *   A: bcs.u8(),\n     *   B: bcs.string(),\n     *   C: null,\n     * })\n     * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n     * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n     * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n     */\n    enum<T extends Record<string, BcsType<any> | null>>(\n        name: string,\n        values: T,\n        options?: Omit<\n            BcsTypeOptions<\n                EnumOutputShape<{\n                    [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n                }>,\n                EnumInputShape<{\n                    [K in keyof T]: T[K] extends BcsType<any, infer U>\n                        ? U\n                        : boolean | object | null;\n                }>\n            >,\n            'name'\n        >,\n    ) {\n        const canonicalOrder = Object.entries(values as object);\n        return new BcsType<\n            EnumOutputShape<{\n                [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n            }>,\n            EnumInputShape<{\n                [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n            }>\n        >({\n            name,\n            read: (reader) => {\n                const index = reader.readULEB();\n\n                const enumEntry = canonicalOrder[index];\n                if (!enumEntry) {\n                    throw new TypeError(`Unknown value ${index} for enum ${name}`);\n                }\n\n                const [kind, type] = enumEntry;\n\n                return {\n                    [kind]: type?.read(reader) ?? true,\n                    $kind: kind,\n                } as never;\n            },\n            write: (value, writer) => {\n                const [name, val] = Object.entries(value).filter(([name]) =>\n                    Object.hasOwn(values, name),\n                )[0];\n\n                for (let i = 0; i < canonicalOrder.length; i++) {\n                    const [optionName, optionType] = canonicalOrder[i];\n                    if (optionName === name) {\n                        writer.writeULEB(i);\n                        optionType?.write(val, writer);\n                        return;\n                    }\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'object' || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n\n                const keys = Object.keys(value).filter(\n                    (k) => value[k] !== undefined && Object.hasOwn(values, k),\n                );\n\n                if (keys.length !== 1) {\n                    throw new TypeError(\n                        `Expected object with one key, but found ${keys.length} for type ${name}}`,\n                    );\n                }\n\n                const [variant] = keys;\n\n                if (!Object.hasOwn(values, variant)) {\n                    throw new TypeError(`Invalid enum variant ${variant}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a map of a given key and value type\n     * @param keyType The BcsType of the key\n     * @param valueType The BcsType of the value\n     * @example\n     * const map = bcs.map(bcs.u8(), bcs.string())\n     * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n     */\n    map<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n        return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n            name: `Map<${keyType.name}, ${valueType.name}>`,\n            input: (value: Map<InputK, InputV>) => {\n                return [...value.entries()];\n            },\n            output: (value) => {\n                const result = new Map<K, V>();\n                for (const [key, val] of value) {\n                    result.set(key, val);\n                }\n                return result;\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n     * @param cb A callback that returns the BcsType\n     */\n    lazy<T extends BcsType<any>>(cb: () => T): T {\n        return lazyBcsType(cb) as T;\n    },\n};\n"],
  "mappings": "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",
  "names": ["name"]
}
