{
  "version": 3,
  "sources": ["../../../src/hooks/useIotaClientInfiniteQuery.ts", "../../../src/hooks/useIotaClient.ts", "../../../src/components/IotaClientProvider.tsx"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { IotaClient } from '@iota/iota-sdk/client';\nimport type {\n    InfiniteData,\n    UseInfiniteQueryOptions,\n    UseInfiniteQueryResult,\n} from '@tanstack/react-query';\nimport { useInfiniteQuery } from '@tanstack/react-query';\n\nimport type { PartialBy } from '../types/utilityTypes.js';\nimport { useIotaClientContext } from './useIotaClient.js';\n\ninterface PaginatedResult {\n    data?: unknown;\n    nextCursor?: unknown;\n    hasNextPage: boolean;\n}\n\nexport type IotaRpcPaginatedMethodName = {\n    [K in keyof IotaClient]: IotaClient[K] extends (input: any) => Promise<PaginatedResult>\n        ? K\n        : never;\n}[keyof IotaClient];\n\nexport type IotaRpcPaginatedMethods = {\n    [K in IotaRpcPaginatedMethodName]: IotaClient[K] extends (\n        input: infer Params,\n    ) => Promise<\n        infer Result extends { hasNextPage?: boolean | null; nextCursor?: infer Cursor | null }\n    >\n        ? {\n              name: K;\n              result: Result;\n              params: Params;\n              cursor: Cursor;\n          }\n        : never;\n};\n\nexport type UseIotaClientInfiniteQueryOptions<\n    T extends keyof IotaRpcPaginatedMethods,\n    TData,\n> = PartialBy<\n    Omit<\n        UseInfiniteQueryOptions<\n            IotaRpcPaginatedMethods[T]['result'],\n            Error,\n            TData,\n            IotaRpcPaginatedMethods[T]['result'],\n            unknown[]\n        >,\n        'queryFn' | 'initialPageParam' | 'getNextPageParam'\n    >,\n    'queryKey'\n>;\n\nexport function useIotaClientInfiniteQuery<\n    T extends keyof IotaRpcPaginatedMethods,\n    TData = InfiniteData<IotaRpcPaginatedMethods[T]['result']>,\n>(\n    method: T,\n    params: IotaRpcPaginatedMethods[T]['params'],\n    {\n        queryKey = [],\n        enabled = !!params,\n        ...options\n    }: UseIotaClientInfiniteQueryOptions<T, TData> = {},\n): UseInfiniteQueryResult<TData, Error> {\n    const iotaContext = useIotaClientContext();\n\n    return useInfiniteQuery({\n        ...options,\n        initialPageParam: null,\n        queryKey: [iotaContext.network, method, params, ...queryKey],\n        enabled,\n        queryFn: ({ pageParam }) =>\n            iotaContext.client[method]({\n                ...(params ?? {}),\n                cursor: pageParam,\n            } as never),\n        getNextPageParam: (lastPage) =>\n            lastPage.hasNextPage ? (lastPage.nextCursor ?? null) : null,\n    });\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { IotaClient } from '@iota/iota-sdk/client';\nimport { useContext } from 'react';\n\nimport { IotaClientContext } from '../components/IotaClientProvider.js';\n\nexport function useIotaClientContext() {\n    const iotaClient = useContext(IotaClientContext);\n\n    if (!iotaClient) {\n        throw new Error(\n            'Could not find IotaClientContext. Ensure that you have set up the IotaClientProvider',\n        );\n    }\n\n    return iotaClient;\n}\n\nexport function useIotaClient(): IotaClient {\n    return useIotaClientContext().client;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { getNetwork, isIotaClient, Network, IotaClient } from '@iota/iota-sdk/client';\nimport type { IotaClientOptions } from '@iota/iota-sdk/client';\nimport { createContext, useMemo, useState } from 'react';\n\nimport type { NetworkConfig } from '../hooks/networkConfig.js';\n\ntype NetworkConfigs<T extends NetworkConfig | IotaClient = NetworkConfig | IotaClient> = Record<\n    string,\n    T\n>;\n\nexport interface IotaClientProviderContext {\n    client: IotaClient;\n    networks: NetworkConfigs;\n    network: string;\n    config: NetworkConfig | null;\n    selectNetwork: (network: string) => void;\n}\n\nexport const IotaClientContext = createContext<IotaClientProviderContext | null>(null);\n\nexport type IotaClientProviderProps<T extends NetworkConfigs> = {\n    createClient?: (name: keyof T, config: T[keyof T]) => IotaClient;\n    children: React.ReactNode;\n    networks?: T;\n    onNetworkChange?: (network: keyof T & string) => void;\n} & (\n    | {\n          defaultNetwork?: keyof T & string;\n          network?: never;\n      }\n    | {\n          defaultNetwork?: never;\n          network?: keyof T & string;\n      }\n);\n\nconst DEFAULT_NETWORKS = {\n    localnet: { url: getNetwork(Network.Localnet)?.url },\n};\n\nconst DEFAULT_CREATE_CLIENT = function createClient(\n    _name: string,\n    config: NetworkConfig | IotaClient,\n) {\n    if (isIotaClient(config)) {\n        return config;\n    }\n\n    return new IotaClient(config);\n};\n\nexport function IotaClientProvider<T extends NetworkConfigs>(props: IotaClientProviderProps<T>) {\n    const { onNetworkChange, network, children } = props;\n    const networks = (props.networks ?? DEFAULT_NETWORKS) as T;\n    const createClient =\n        (props.createClient as typeof DEFAULT_CREATE_CLIENT) ?? DEFAULT_CREATE_CLIENT;\n\n    const [selectedNetwork, setSelectedNetwork] = useState<keyof T & string>(\n        props.network ?? props.defaultNetwork ?? (Object.keys(networks)[0] as keyof T & string),\n    );\n\n    const currentNetwork = props.network ?? selectedNetwork;\n\n    const client = useMemo(() => {\n        return createClient(currentNetwork, networks[currentNetwork]);\n    }, [createClient, currentNetwork, networks]);\n\n    const ctx = useMemo((): IotaClientProviderContext => {\n        return {\n            client,\n            networks,\n            network: currentNetwork,\n            config:\n                networks[currentNetwork] instanceof IotaClient\n                    ? null\n                    : (networks[currentNetwork] as IotaClientOptions),\n            selectNetwork: (newNetwork) => {\n                if (currentNetwork === newNetwork) {\n                    return;\n                }\n\n                if (!network && newNetwork !== selectedNetwork) {\n                    setSelectedNetwork(newNetwork);\n                }\n\n                onNetworkChange?.(newNetwork);\n            },\n        };\n    }, [client, networks, selectedNetwork, currentNetwork, network, onNetworkChange]);\n\n    return <IotaClientContext.Provider value={ctx}>{children}</IotaClientContext.Provider>;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA,yBAAiC;;;ACLjC,IAAAA,gBAA2B;;;ACD3B,oBAA8D;AAE9D,mBAAiD;AAyFtC;AAxEJ,IAAM,wBAAoB,4BAAgD,IAAI;AAkBrF,IAAM,mBAAmB;AAAA,EACrB,UAAU,EAAE,SAAK,0BAAW,sBAAQ,QAAQ,GAAG,IAAI;AACvD;;;ADlCO,SAAS,uBAAuB;AACnC,QAAM,iBAAa,0BAAW,iBAAiB;AAE/C,MAAI,CAAC,YAAY;AACb,UAAM,IAAI;AAAA,MACN;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO;AACX;;;ADwCO,SAAS,2BAIZ,QACA,QACA;AAAA,EACI,WAAW,CAAC;AAAA,EACZ,UAAU,CAAC,CAAC;AAAA,EACZ,GAAG;AACP,IAAiD,CAAC,GACd;AACpC,QAAM,cAAc,qBAAqB;AAEzC,aAAO,qCAAiB;AAAA,IACpB,GAAG;AAAA,IACH,kBAAkB;AAAA,IAClB,UAAU,CAAC,YAAY,SAAS,QAAQ,QAAQ,GAAG,QAAQ;AAAA,IAC3D;AAAA,IACA,SAAS,CAAC,EAAE,UAAU,MAClB,YAAY,OAAO,MAAM,EAAE;AAAA,MACvB,GAAI,UAAU,CAAC;AAAA,MACf,QAAQ;AAAA,IACZ,CAAU;AAAA,IACd,kBAAkB,CAAC,aACf,SAAS,cAAe,SAAS,cAAc,OAAQ;AAAA,EAC/D,CAAC;AACL;",
  "names": ["import_react"]
}
