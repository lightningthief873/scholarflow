{
  "version": 3,
  "sources": ["../../../../src/hooks/wallet/useSignAndExecuteTransaction.ts", "../../../../src/constants/walletMutationKeys.ts", "../../../../src/errors/walletErrors.ts", "../../../../src/hooks/useIotaClient.ts", "../../../../src/components/IotaClientProvider.tsx", "../../../../src/hooks/wallet/useWalletStore.ts", "../../../../src/contexts/walletContext.ts", "../../../../src/hooks/wallet/useCurrentAccount.ts", "../../../../src/hooks/wallet/useCurrentWallet.ts", "../../../../src/hooks/wallet/useReportTransactionEffects.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Transaction } from '@iota/iota-sdk/transactions';\nimport { toB64 } from '@iota/iota-sdk/utils';\nimport type {\n    IotaSignAndExecuteTransactionInput,\n    IotaSignAndExecuteTransactionOutput,\n} from '@iota/wallet-standard';\nimport { signTransaction } from '@iota/wallet-standard';\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query';\nimport { useMutation } from '@tanstack/react-query';\n\nimport { walletMutationKeys } from '../../constants/walletMutationKeys.js';\nimport {\n    WalletFeatureNotSupportedError,\n    WalletNoAccountSelectedError,\n    WalletNotConnectedError,\n} from '../../errors/walletErrors.js';\nimport type { PartialBy } from '../../types/utilityTypes.js';\nimport { useIotaClient } from '../useIotaClient.js';\nimport { useCurrentAccount } from './useCurrentAccount.js';\nimport { useCurrentWallet } from './useCurrentWallet.js';\nimport { useReportTransactionEffects } from './useReportTransactionEffects.js';\n\ntype UseSignAndExecuteTransactionArgs = PartialBy<\n    Omit<IotaSignAndExecuteTransactionInput, 'transaction'>,\n    'account' | 'chain'\n> & {\n    transaction: Transaction | string;\n    waitForTransaction?: boolean;\n};\n\ntype UseSignAndExecuteTransactionResult = IotaSignAndExecuteTransactionOutput;\n\ntype UseSignAndExecuteTransactionError =\n    | WalletFeatureNotSupportedError\n    | WalletNoAccountSelectedError\n    | WalletNotConnectedError\n    | Error;\n\ntype ExecuteTransactionResult =\n    | {\n          digest: string;\n          rawEffects?: number[];\n      }\n    | {\n          effects?: {\n              bcs?: string;\n          };\n      };\n\ntype UseSignAndExecuteTransactionMutationOptions<Result extends ExecuteTransactionResult> = Omit<\n    UseMutationOptions<\n        Result,\n        UseSignAndExecuteTransactionError,\n        UseSignAndExecuteTransactionArgs,\n        unknown\n    >,\n    'mutationFn'\n> & {\n    execute?: ({ bytes, signature }: { bytes: string; signature: string }) => Promise<Result>;\n};\n\n/**\n * Mutation hook for prompting the user to sign and execute a transaction.\n */\nexport function useSignAndExecuteTransaction<\n    Result extends ExecuteTransactionResult = UseSignAndExecuteTransactionResult,\n>({\n    mutationKey,\n    execute,\n    ...mutationOptions\n}: UseSignAndExecuteTransactionMutationOptions<Result> = {}): UseMutationResult<\n    Result,\n    UseSignAndExecuteTransactionError,\n    UseSignAndExecuteTransactionArgs\n> {\n    const { currentWallet, supportedIntents } = useCurrentWallet();\n    const currentAccount = useCurrentAccount();\n    const client = useIotaClient();\n    const { mutate: reportTransactionEffects } = useReportTransactionEffects();\n\n    const executeTransaction: ({\n        bytes,\n        signature,\n    }: {\n        bytes: string;\n        signature: string;\n    }) => Promise<ExecuteTransactionResult> =\n        execute ??\n        (async ({ bytes, signature }) => {\n            const { digest, rawEffects } = await client.executeTransactionBlock({\n                transactionBlock: bytes,\n                signature,\n                options: {\n                    showRawEffects: true,\n                },\n            });\n\n            return {\n                digest,\n                rawEffects,\n                effects: toB64(new Uint8Array(rawEffects!)),\n                bytes,\n                signature,\n            };\n        });\n\n    return useMutation({\n        mutationKey: walletMutationKeys.signAndExecuteTransaction(mutationKey),\n        mutationFn: async ({ transaction, ...signTransactionArgs }): Promise<Result> => {\n            if (!currentWallet) {\n                throw new WalletNotConnectedError('No wallet is connected.');\n            }\n\n            const signerAccount = signTransactionArgs.account ?? currentAccount;\n            if (!signerAccount) {\n                throw new WalletNoAccountSelectedError(\n                    'No wallet account is selected to sign the transaction with.',\n                );\n            }\n            const chain = signTransactionArgs.chain ?? signerAccount?.chains[0];\n\n            if (!currentWallet.features['iota:signTransaction']) {\n                throw new WalletFeatureNotSupportedError(\n                    \"This wallet doesn't support the `signTransaction` feature.\",\n                );\n            }\n\n            const { signature, bytes } = await signTransaction(currentWallet, {\n                ...signTransactionArgs,\n                transaction: {\n                    async toJSON() {\n                        return typeof transaction === 'string'\n                            ? transaction\n                            : await transaction.toJSON({\n                                  supportedIntents,\n                                  client,\n                              });\n                    },\n                },\n                account: signerAccount,\n                chain: signTransactionArgs.chain ?? signerAccount.chains[0],\n            });\n\n            const result = await executeTransaction({ bytes, signature });\n\n            let effects: string;\n\n            if ('effects' in result && result.effects?.bcs) {\n                effects = result.effects.bcs;\n            } else if ('rawEffects' in result) {\n                effects = toB64(new Uint8Array(result.rawEffects!));\n            } else {\n                throw new Error('Could not parse effects from transaction result.');\n            }\n\n            reportTransactionEffects({ effects, account: signerAccount, chain });\n\n            if (signTransactionArgs.waitForTransaction && 'digest' in result) {\n                await client.waitForTransaction({\n                    digest: result.digest,\n                });\n            }\n\n            return result as Result;\n        },\n        ...mutationOptions,\n    });\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { MutationKey } from '@tanstack/react-query';\n\nexport const walletMutationKeys = {\n    all: { baseScope: 'wallet' },\n    connectWallet: formMutationKeyFn('connect-wallet'),\n    autoconnectWallet: formMutationKeyFn('autoconnect-wallet'),\n    disconnectWallet: formMutationKeyFn('disconnect-wallet'),\n    signPersonalMessage: formMutationKeyFn('sign-personal-message'),\n    signTransaction: formMutationKeyFn('sign-transaction'),\n    signAndExecuteTransaction: formMutationKeyFn('sign-and-execute-transaction'),\n    switchAccount: formMutationKeyFn('switch-account'),\n    reportTransactionEffects: formMutationKeyFn('report-transaction-effects'),\n};\n\nfunction formMutationKeyFn(baseEntity: string) {\n    return function mutationKeyFn(additionalKeys: MutationKey = []) {\n        return [{ ...walletMutationKeys.all, baseEntity }, ...additionalKeys];\n    };\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * An error that is instantiated when someone attempts to perform an action that requires an active wallet connection.\n */\nexport class WalletNotConnectedError extends Error {}\n\n/**\n * An error that is instantiated when someone attempts to perform an action that requires a selected wallet account.\n * This is more of an edge case stemming from the fact that wallets don't technically require you to authorize any\n * accounts when connecting a wallet.\n */\nexport class WalletNoAccountSelectedError extends Error {}\n\n/**\n * An error that is instantiated when someone attempts to perform an action that isn't supported by a wallet.\n */\nexport class WalletFeatureNotSupportedError extends Error {}\n\n/**\n * An error that is instantiated when a wallet account can't be found for a specific wallet.\n */\nexport class WalletAccountNotFoundError extends Error {}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { IotaClient } from '@iota/iota-sdk/client';\nimport { useContext } from 'react';\n\nimport { IotaClientContext } from '../components/IotaClientProvider.js';\n\nexport function useIotaClientContext() {\n    const iotaClient = useContext(IotaClientContext);\n\n    if (!iotaClient) {\n        throw new Error(\n            'Could not find IotaClientContext. Ensure that you have set up the IotaClientProvider',\n        );\n    }\n\n    return iotaClient;\n}\n\nexport function useIotaClient(): IotaClient {\n    return useIotaClientContext().client;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { getNetwork, isIotaClient, Network, IotaClient } from '@iota/iota-sdk/client';\nimport type { IotaClientOptions } from '@iota/iota-sdk/client';\nimport { createContext, useMemo, useState } from 'react';\n\nimport type { NetworkConfig } from '../hooks/networkConfig.js';\n\ntype NetworkConfigs<T extends NetworkConfig | IotaClient = NetworkConfig | IotaClient> = Record<\n    string,\n    T\n>;\n\nexport interface IotaClientProviderContext {\n    client: IotaClient;\n    networks: NetworkConfigs;\n    network: string;\n    config: NetworkConfig | null;\n    selectNetwork: (network: string) => void;\n}\n\nexport const IotaClientContext = createContext<IotaClientProviderContext | null>(null);\n\nexport type IotaClientProviderProps<T extends NetworkConfigs> = {\n    createClient?: (name: keyof T, config: T[keyof T]) => IotaClient;\n    children: React.ReactNode;\n    networks?: T;\n    onNetworkChange?: (network: keyof T & string) => void;\n} & (\n    | {\n          defaultNetwork?: keyof T & string;\n          network?: never;\n      }\n    | {\n          defaultNetwork?: never;\n          network?: keyof T & string;\n      }\n);\n\nconst DEFAULT_NETWORKS = {\n    localnet: { url: getNetwork(Network.Localnet)?.url },\n};\n\nconst DEFAULT_CREATE_CLIENT = function createClient(\n    _name: string,\n    config: NetworkConfig | IotaClient,\n) {\n    if (isIotaClient(config)) {\n        return config;\n    }\n\n    return new IotaClient(config);\n};\n\nexport function IotaClientProvider<T extends NetworkConfigs>(props: IotaClientProviderProps<T>) {\n    const { onNetworkChange, network, children } = props;\n    const networks = (props.networks ?? DEFAULT_NETWORKS) as T;\n    const createClient =\n        (props.createClient as typeof DEFAULT_CREATE_CLIENT) ?? DEFAULT_CREATE_CLIENT;\n\n    const [selectedNetwork, setSelectedNetwork] = useState<keyof T & string>(\n        props.network ?? props.defaultNetwork ?? (Object.keys(networks)[0] as keyof T & string),\n    );\n\n    const currentNetwork = props.network ?? selectedNetwork;\n\n    const client = useMemo(() => {\n        return createClient(currentNetwork, networks[currentNetwork]);\n    }, [createClient, currentNetwork, networks]);\n\n    const ctx = useMemo((): IotaClientProviderContext => {\n        return {\n            client,\n            networks,\n            network: currentNetwork,\n            config:\n                networks[currentNetwork] instanceof IotaClient\n                    ? null\n                    : (networks[currentNetwork] as IotaClientOptions),\n            selectNetwork: (newNetwork) => {\n                if (currentNetwork === newNetwork) {\n                    return;\n                }\n\n                if (!network && newNetwork !== selectedNetwork) {\n                    setSelectedNetwork(newNetwork);\n                }\n\n                onNetworkChange?.(newNetwork);\n            },\n        };\n    }, [client, networks, selectedNetwork, currentNetwork, network, onNetworkChange]);\n\n    return <IotaClientContext.Provider value={ctx}>{children}</IotaClientContext.Provider>;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useContext } from 'react';\nimport { useStore } from 'zustand';\n\nimport { WalletContext } from '../../contexts/walletContext.js';\nimport type { StoreState } from '../../walletStore.js';\n\nexport function useWalletStore<T>(selector: (state: StoreState) => T): T {\n    const store = useContext(WalletContext);\n    if (!store) {\n        throw new Error(\n            'Could not find WalletContext. Ensure that you have set up the WalletProvider.',\n        );\n    }\n    return useStore(store, selector);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { createContext } from 'react';\n\nimport type { WalletStore } from '../walletStore.js';\n\nexport const WalletContext = createContext<WalletStore | null>(null);\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalletAccount } from '@iota/wallet-standard';\n\nimport { useWalletStore } from './useWalletStore.js';\n\n/**\n * Retrieves the wallet account that is currently selected, if one exists.\n */\nexport function useCurrentAccount(): WalletAccount | null {\n    return useWalletStore((state) => state.currentAccount);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useWalletStore } from './useWalletStore.js';\n\n/**\n * Retrieves the wallet that is currently connected to the dApp, if one exists.\n */\nexport function useCurrentWallet() {\n    const currentWallet = useWalletStore((state) => state.currentWallet);\n    const connectionStatus = useWalletStore((state) => state.connectionStatus);\n    const supportedIntents = useWalletStore((state) => state.supportedIntents);\n\n    switch (connectionStatus) {\n        case 'connecting':\n            return {\n                connectionStatus,\n                currentWallet: null,\n                isDisconnected: false,\n                isConnecting: true,\n                isConnected: false,\n                supportedIntents: [],\n            } as const;\n        case 'disconnected':\n            return {\n                connectionStatus,\n                currentWallet: null,\n                isDisconnected: true,\n                isConnecting: false,\n                isConnected: false,\n                supportedIntents: [],\n            } as const;\n        case 'connected': {\n            return {\n                connectionStatus,\n                currentWallet: currentWallet!,\n                isDisconnected: false,\n                isConnecting: false,\n                isConnected: true,\n                supportedIntents,\n            } as const;\n        }\n    }\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@iota/iota-sdk/utils';\nimport type { IotaReportTransactionEffectsInput } from '@iota/wallet-standard';\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query';\nimport { useMutation } from '@tanstack/react-query';\n\nimport { walletMutationKeys } from '../../constants/walletMutationKeys.js';\nimport type { WalletFeatureNotSupportedError } from '../../errors/walletErrors.js';\nimport {\n    WalletNoAccountSelectedError,\n    WalletNotConnectedError,\n} from '../../errors/walletErrors.js';\nimport type { PartialBy } from '../../types/utilityTypes.js';\nimport { useCurrentAccount } from './useCurrentAccount.js';\nimport { useCurrentWallet } from './useCurrentWallet.js';\n\ntype UseReportTransactionEffectsArgs = Omit<\n    PartialBy<IotaReportTransactionEffectsInput, 'account' | 'chain'>,\n    'effects'\n> & {\n    effects: string | number[];\n};\n\ntype UseReportTransactionEffectsError =\n    | WalletFeatureNotSupportedError\n    | WalletNoAccountSelectedError\n    | WalletNotConnectedError\n    | Error;\n\ntype UseReportTransactionEffectsMutationOptions = Omit<\n    UseMutationOptions<\n        void,\n        UseReportTransactionEffectsError,\n        UseReportTransactionEffectsArgs,\n        unknown\n    >,\n    'mutationFn'\n>;\n\n/**\n * Mutation hook for prompting the user to sign a message.\n */\nexport function useReportTransactionEffects({\n    mutationKey,\n    ...mutationOptions\n}: UseReportTransactionEffectsMutationOptions = {}): UseMutationResult<\n    void,\n    UseReportTransactionEffectsError,\n    UseReportTransactionEffectsArgs\n> {\n    const { currentWallet } = useCurrentWallet();\n    const currentAccount = useCurrentAccount();\n\n    return useMutation({\n        mutationKey: walletMutationKeys.reportTransactionEffects(mutationKey),\n        mutationFn: async ({\n            effects,\n            chain = currentWallet?.chains[0],\n            account = currentAccount,\n        }) => {\n            if (!currentWallet) {\n                throw new WalletNotConnectedError('No wallet is connected.');\n            }\n\n            if (!account) {\n                throw new WalletNoAccountSelectedError(\n                    'No wallet account is selected to report transaction effects for',\n                );\n            }\n\n            const reportTransactionEffectsFeature =\n                currentWallet.features['iota:reportTransactionEffects'];\n\n            if (reportTransactionEffectsFeature) {\n                return await reportTransactionEffectsFeature.reportTransactionEffects({\n                    effects: Array.isArray(effects) ? toB64(new Uint8Array(effects)) : effects,\n                    account,\n                    chain: chain ?? currentWallet?.chains[0],\n                });\n            }\n        },\n        ...mutationOptions,\n    });\n}\n"],
  "mappings": ";AAKA,SAAS,SAAAA,cAAa;AAKtB,SAAS,uBAAuB;AAEhC,SAAS,eAAAC,oBAAmB;;;ACNrB,IAAM,qBAAqB;AAAA,EAC9B,KAAK,EAAE,WAAW,SAAS;AAAA,EAC3B,eAAe,kBAAkB,gBAAgB;AAAA,EACjD,mBAAmB,kBAAkB,oBAAoB;AAAA,EACzD,kBAAkB,kBAAkB,mBAAmB;AAAA,EACvD,qBAAqB,kBAAkB,uBAAuB;AAAA,EAC9D,iBAAiB,kBAAkB,kBAAkB;AAAA,EACrD,2BAA2B,kBAAkB,8BAA8B;AAAA,EAC3E,eAAe,kBAAkB,gBAAgB;AAAA,EACjD,0BAA0B,kBAAkB,4BAA4B;AAC5E;AAEA,SAAS,kBAAkB,YAAoB;AAC3C,SAAO,SAAS,cAAc,iBAA8B,CAAC,GAAG;AAC5D,WAAO,CAAC,EAAE,GAAG,mBAAmB,KAAK,WAAW,GAAG,GAAG,cAAc;AAAA,EACxE;AACJ;;;ACfO,IAAM,0BAAN,cAAsC,MAAM;AAAC;AAO7C,IAAM,+BAAN,cAA2C,MAAM;AAAC;AAKlD,IAAM,iCAAN,cAA6C,MAAM;AAAC;;;ACd3D,SAAS,kBAAkB;;;ACD3B,SAAS,YAAY,cAAc,SAAS,kBAAkB;AAE9D,SAAS,eAAe,SAAS,gBAAgB;AAyFtC;AAxEJ,IAAM,oBAAoB,cAAgD,IAAI;AAkBrF,IAAM,mBAAmB;AAAA,EACrB,UAAU,EAAE,KAAK,WAAW,QAAQ,QAAQ,GAAG,IAAI;AACvD;;;ADlCO,SAAS,uBAAuB;AACnC,QAAM,aAAa,WAAW,iBAAiB;AAE/C,MAAI,CAAC,YAAY;AACb,UAAM,IAAI;AAAA,MACN;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO;AACX;AAEO,SAAS,gBAA4B;AACxC,SAAO,qBAAqB,EAAE;AAClC;;;AEnBA,SAAS,cAAAC,mBAAkB;AAC3B,SAAS,gBAAgB;;;ACDzB,SAAS,iBAAAC,sBAAqB;AAIvB,IAAM,gBAAgBA,eAAkC,IAAI;;;ADE5D,SAAS,eAAkB,UAAuC;AACrE,QAAM,QAAQC,YAAW,aAAa;AACtC,MAAI,CAAC,OAAO;AACR,UAAM,IAAI;AAAA,MACN;AAAA,IACJ;AAAA,EACJ;AACA,SAAO,SAAS,OAAO,QAAQ;AACnC;;;AEPO,SAAS,oBAA0C;AACtD,SAAO,eAAe,CAAC,UAAU,MAAM,cAAc;AACzD;;;ACJO,SAAS,mBAAmB;AAC/B,QAAM,gBAAgB,eAAe,CAAC,UAAU,MAAM,aAAa;AACnE,QAAM,mBAAmB,eAAe,CAAC,UAAU,MAAM,gBAAgB;AACzE,QAAM,mBAAmB,eAAe,CAAC,UAAU,MAAM,gBAAgB;AAEzE,UAAQ,kBAAkB;AAAA,IACtB,KAAK;AACD,aAAO;AAAA,QACH;AAAA,QACA,eAAe;AAAA,QACf,gBAAgB;AAAA,QAChB,cAAc;AAAA,QACd,aAAa;AAAA,QACb,kBAAkB,CAAC;AAAA,MACvB;AAAA,IACJ,KAAK;AACD,aAAO;AAAA,QACH;AAAA,QACA,eAAe;AAAA,QACf,gBAAgB;AAAA,QAChB,cAAc;AAAA,QACd,aAAa;AAAA,QACb,kBAAkB,CAAC;AAAA,MACvB;AAAA,IACJ,KAAK,aAAa;AACd,aAAO;AAAA,QACH;AAAA,QACA;AAAA,QACA,gBAAgB;AAAA,QAChB,cAAc;AAAA,QACd,aAAa;AAAA,QACb;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;ACxCA,SAAS,aAAa;AAGtB,SAAS,mBAAmB;AAsCrB,SAAS,4BAA4B;AAAA,EACxC;AAAA,EACA,GAAG;AACP,IAAgD,CAAC,GAI/C;AACE,QAAM,EAAE,cAAc,IAAI,iBAAiB;AAC3C,QAAM,iBAAiB,kBAAkB;AAEzC,SAAO,YAAY;AAAA,IACf,aAAa,mBAAmB,yBAAyB,WAAW;AAAA,IACpE,YAAY,OAAO;AAAA,MACf;AAAA,MACA,QAAQ,eAAe,OAAO,CAAC;AAAA,MAC/B,UAAU;AAAA,IACd,MAAM;AACF,UAAI,CAAC,eAAe;AAChB,cAAM,IAAI,wBAAwB,yBAAyB;AAAA,MAC/D;AAEA,UAAI,CAAC,SAAS;AACV,cAAM,IAAI;AAAA,UACN;AAAA,QACJ;AAAA,MACJ;AAEA,YAAM,kCACF,cAAc,SAAS,+BAA+B;AAE1D,UAAI,iCAAiC;AACjC,eAAO,MAAM,gCAAgC,yBAAyB;AAAA,UAClE,SAAS,MAAM,QAAQ,OAAO,IAAI,MAAM,IAAI,WAAW,OAAO,CAAC,IAAI;AAAA,UACnE;AAAA,UACA,OAAO,SAAS,eAAe,OAAO,CAAC;AAAA,QAC3C,CAAC;AAAA,MACL;AAAA,IACJ;AAAA,IACA,GAAG;AAAA,EACP,CAAC;AACL;;;ATlBO,SAAS,6BAEd;AAAA,EACE;AAAA,EACA;AAAA,EACA,GAAG;AACP,IAAyD,CAAC,GAIxD;AACE,QAAM,EAAE,eAAe,iBAAiB,IAAI,iBAAiB;AAC7D,QAAM,iBAAiB,kBAAkB;AACzC,QAAM,SAAS,cAAc;AAC7B,QAAM,EAAE,QAAQ,yBAAyB,IAAI,4BAA4B;AAEzE,QAAM,qBAOF,YACC,OAAO,EAAE,OAAO,UAAU,MAAM;AAC7B,UAAM,EAAE,QAAQ,WAAW,IAAI,MAAM,OAAO,wBAAwB;AAAA,MAChE,kBAAkB;AAAA,MAClB;AAAA,MACA,SAAS;AAAA,QACL,gBAAgB;AAAA,MACpB;AAAA,IACJ,CAAC;AAED,WAAO;AAAA,MACH;AAAA,MACA;AAAA,MACA,SAASC,OAAM,IAAI,WAAW,UAAW,CAAC;AAAA,MAC1C;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAEJ,SAAOC,aAAY;AAAA,IACf,aAAa,mBAAmB,0BAA0B,WAAW;AAAA,IACrE,YAAY,OAAO,EAAE,aAAa,GAAG,oBAAoB,MAAuB;AAC5E,UAAI,CAAC,eAAe;AAChB,cAAM,IAAI,wBAAwB,yBAAyB;AAAA,MAC/D;AAEA,YAAM,gBAAgB,oBAAoB,WAAW;AACrD,UAAI,CAAC,eAAe;AAChB,cAAM,IAAI;AAAA,UACN;AAAA,QACJ;AAAA,MACJ;AACA,YAAM,QAAQ,oBAAoB,SAAS,eAAe,OAAO,CAAC;AAElE,UAAI,CAAC,cAAc,SAAS,sBAAsB,GAAG;AACjD,cAAM,IAAI;AAAA,UACN;AAAA,QACJ;AAAA,MACJ;AAEA,YAAM,EAAE,WAAW,MAAM,IAAI,MAAM,gBAAgB,eAAe;AAAA,QAC9D,GAAG;AAAA,QACH,aAAa;AAAA,UACT,MAAM,SAAS;AACX,mBAAO,OAAO,gBAAgB,WACxB,cACA,MAAM,YAAY,OAAO;AAAA,cACrB;AAAA,cACA;AAAA,YACJ,CAAC;AAAA,UACX;AAAA,QACJ;AAAA,QACA,SAAS;AAAA,QACT,OAAO,oBAAoB,SAAS,cAAc,OAAO,CAAC;AAAA,MAC9D,CAAC;AAED,YAAM,SAAS,MAAM,mBAAmB,EAAE,OAAO,UAAU,CAAC;AAE5D,UAAI;AAEJ,UAAI,aAAa,UAAU,OAAO,SAAS,KAAK;AAC5C,kBAAU,OAAO,QAAQ;AAAA,MAC7B,WAAW,gBAAgB,QAAQ;AAC/B,kBAAUD,OAAM,IAAI,WAAW,OAAO,UAAW,CAAC;AAAA,MACtD,OAAO;AACH,cAAM,IAAI,MAAM,kDAAkD;AAAA,MACtE;AAEA,+BAAyB,EAAE,SAAS,SAAS,eAAe,MAAM,CAAC;AAEnE,UAAI,oBAAoB,sBAAsB,YAAY,QAAQ;AAC9D,cAAM,OAAO,mBAAmB;AAAA,UAC5B,QAAQ,OAAO;AAAA,QACnB,CAAC;AAAA,MACL;AAEA,aAAO;AAAA,IACX;AAAA,IACA,GAAG;AAAA,EACP,CAAC;AACL;",
  "names": ["toB64", "useMutation", "useContext", "createContext", "useContext", "toB64", "useMutation"]
}
