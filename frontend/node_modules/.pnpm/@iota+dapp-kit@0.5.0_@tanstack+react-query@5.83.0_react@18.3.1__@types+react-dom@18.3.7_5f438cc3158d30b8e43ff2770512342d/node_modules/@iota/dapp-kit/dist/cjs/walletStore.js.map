{
  "version": 3,
  "sources": ["../../src/walletStore.ts", "../../src/utils/walletUtils.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Wallet, WalletAccount, WalletWithRequiredFeatures } from '@iota/wallet-standard';\nimport { createStore } from 'zustand';\nimport type { StateStorage } from 'zustand/middleware';\nimport { createJSONStorage, persist } from 'zustand/middleware';\n\nimport { getWalletUniqueIdentifier } from './utils/walletUtils.js';\n\ntype WalletConnectionStatus = 'disconnected' | 'connecting' | 'connected';\n\nexport type WalletActions = {\n    setAccountSwitched: (selectedAccount: WalletAccount) => void;\n    setConnectionStatus: (connectionStatus: WalletConnectionStatus) => void;\n    setWalletConnected: (\n        wallet: WalletWithRequiredFeatures,\n        connectedAccounts: readonly WalletAccount[],\n        selectedAccount: WalletAccount | null,\n        supportedIntents?: string[],\n    ) => void;\n    updateWalletAccounts: (accounts: readonly WalletAccount[]) => void;\n    setWalletDisconnected: () => void;\n    setWalletRegistered: (updatedWallets: WalletWithRequiredFeatures[]) => void;\n    setWalletUnregistered: (\n        updatedWallets: WalletWithRequiredFeatures[],\n        unregisteredWallet: Wallet,\n    ) => void;\n};\n\nexport type WalletStore = ReturnType<typeof createWalletStore>;\n\nexport type StoreState = {\n    autoConnectEnabled: boolean;\n    wallets: WalletWithRequiredFeatures[];\n    accounts: readonly WalletAccount[];\n    currentWallet: WalletWithRequiredFeatures | null;\n    currentAccount: WalletAccount | null;\n    lastConnectedAccountAddress: string | null;\n    lastConnectedWalletName: string | null;\n    connectionStatus: WalletConnectionStatus;\n    supportedIntents: string[];\n} & WalletActions;\n\ntype WalletConfiguration = {\n    autoConnectEnabled: boolean;\n    wallets: WalletWithRequiredFeatures[];\n    storage: StateStorage;\n    storageKey: string;\n};\n\nexport function createWalletStore({\n    wallets,\n    storage,\n    storageKey,\n    autoConnectEnabled,\n}: WalletConfiguration) {\n    return createStore<StoreState>()(\n        persist(\n            (set, get) => ({\n                autoConnectEnabled,\n                wallets,\n                accounts: [] as WalletAccount[],\n                currentWallet: null,\n                currentAccount: null,\n                lastConnectedAccountAddress: null,\n                lastConnectedWalletName: null,\n                connectionStatus: 'disconnected',\n                supportedIntents: [],\n                setConnectionStatus(connectionStatus) {\n                    set(() => ({\n                        connectionStatus,\n                    }));\n                },\n                setWalletConnected(\n                    wallet,\n                    connectedAccounts,\n                    selectedAccount,\n                    supportedIntents = [],\n                ) {\n                    set(() => ({\n                        accounts: connectedAccounts,\n                        currentWallet: wallet,\n                        currentAccount: selectedAccount,\n                        lastConnectedWalletName: getWalletUniqueIdentifier(wallet),\n                        lastConnectedAccountAddress: selectedAccount?.address,\n                        connectionStatus: 'connected',\n                        supportedIntents,\n                    }));\n                },\n                setWalletDisconnected() {\n                    set(() => ({\n                        accounts: [],\n                        currentWallet: null,\n                        currentAccount: null,\n                        lastConnectedWalletName: null,\n                        lastConnectedAccountAddress: null,\n                        connectionStatus: 'disconnected',\n                        supportedIntents: [],\n                    }));\n                },\n                setAccountSwitched(selectedAccount) {\n                    set(() => ({\n                        currentAccount: selectedAccount,\n                        lastConnectedAccountAddress: selectedAccount.address,\n                    }));\n                },\n                setWalletRegistered(updatedWallets) {\n                    set(() => ({ wallets: updatedWallets }));\n                },\n                setWalletUnregistered(updatedWallets, unregisteredWallet) {\n                    if (unregisteredWallet === get().currentWallet) {\n                        set(() => ({\n                            wallets: updatedWallets,\n                            accounts: [],\n                            currentWallet: null,\n                            currentAccount: null,\n                            lastConnectedWalletName: null,\n                            lastConnectedAccountAddress: null,\n                            connectionStatus: 'disconnected',\n                            supportedIntents: [],\n                        }));\n                    } else {\n                        set(() => ({ wallets: updatedWallets }));\n                    }\n                },\n                updateWalletAccounts(accounts) {\n                    const currentAccount = get().currentAccount;\n\n                    set(() => ({\n                        accounts,\n                        currentAccount:\n                            (currentAccount &&\n                                accounts.find(\n                                    ({ address }) => address === currentAccount.address,\n                                )) ||\n                            accounts[0],\n                    }));\n                },\n            }),\n            {\n                name: storageKey,\n                storage: createJSONStorage(() => storage),\n                partialize: ({ lastConnectedWalletName, lastConnectedAccountAddress }) => ({\n                    lastConnectedWalletName,\n                    lastConnectedAccountAddress,\n                }),\n            },\n        ),\n    );\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type {\n    MinimallyRequiredFeatures,\n    Wallet,\n    WalletWithFeatures,\n    WalletWithRequiredFeatures,\n} from '@iota/wallet-standard';\nimport { getWallets, isWalletWithRequiredFeatureSet } from '@iota/wallet-standard';\n\nexport function getRegisteredWallets<AdditionalFeatures extends Wallet['features']>(\n    preferredWallets: string[],\n    walletFilter?: (wallet: WalletWithRequiredFeatures) => boolean,\n) {\n    const walletsApi = getWallets();\n    const wallets = walletsApi.get();\n\n    const iotaWallets = wallets.filter(\n        (wallet): wallet is WalletWithFeatures<MinimallyRequiredFeatures & AdditionalFeatures> =>\n            isWalletWithRequiredFeatureSet(wallet) && (!walletFilter || walletFilter(wallet)),\n    );\n\n    return [\n        // Preferred wallets, in order:\n        ...(preferredWallets\n            .map((name) => iotaWallets.find((wallet) => wallet.name === name))\n            .filter(Boolean) as WalletWithFeatures<\n            MinimallyRequiredFeatures & AdditionalFeatures\n        >[]),\n\n        // Wallets in default order:\n        ...iotaWallets.filter((wallet) => !preferredWallets.includes(wallet.name)),\n    ];\n}\n\nexport function getWalletUniqueIdentifier(wallet?: Wallet) {\n    return wallet?.id ?? wallet?.name;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,qBAA4B;AAE5B,wBAA2C;;;ACG3C,6BAA2D;AA2BpD,SAAS,0BAA0B,QAAiB;AACvD,SAAO,QAAQ,MAAM,QAAQ;AACjC;;;ADaO,SAAS,kBAAkB;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ,GAAwB;AACpB,aAAO,4BAAwB;AAAA,QAC3B;AAAA,MACI,CAAC,KAAK,SAAS;AAAA,QACX;AAAA,QACA;AAAA,QACA,UAAU,CAAC;AAAA,QACX,eAAe;AAAA,QACf,gBAAgB;AAAA,QAChB,6BAA6B;AAAA,QAC7B,yBAAyB;AAAA,QACzB,kBAAkB;AAAA,QAClB,kBAAkB,CAAC;AAAA,QACnB,oBAAoB,kBAAkB;AAClC,cAAI,OAAO;AAAA,YACP;AAAA,UACJ,EAAE;AAAA,QACN;AAAA,QACA,mBACI,QACA,mBACA,iBACA,mBAAmB,CAAC,GACtB;AACE,cAAI,OAAO;AAAA,YACP,UAAU;AAAA,YACV,eAAe;AAAA,YACf,gBAAgB;AAAA,YAChB,yBAAyB,0BAA0B,MAAM;AAAA,YACzD,6BAA6B,iBAAiB;AAAA,YAC9C,kBAAkB;AAAA,YAClB;AAAA,UACJ,EAAE;AAAA,QACN;AAAA,QACA,wBAAwB;AACpB,cAAI,OAAO;AAAA,YACP,UAAU,CAAC;AAAA,YACX,eAAe;AAAA,YACf,gBAAgB;AAAA,YAChB,yBAAyB;AAAA,YACzB,6BAA6B;AAAA,YAC7B,kBAAkB;AAAA,YAClB,kBAAkB,CAAC;AAAA,UACvB,EAAE;AAAA,QACN;AAAA,QACA,mBAAmB,iBAAiB;AAChC,cAAI,OAAO;AAAA,YACP,gBAAgB;AAAA,YAChB,6BAA6B,gBAAgB;AAAA,UACjD,EAAE;AAAA,QACN;AAAA,QACA,oBAAoB,gBAAgB;AAChC,cAAI,OAAO,EAAE,SAAS,eAAe,EAAE;AAAA,QAC3C;AAAA,QACA,sBAAsB,gBAAgB,oBAAoB;AACtD,cAAI,uBAAuB,IAAI,EAAE,eAAe;AAC5C,gBAAI,OAAO;AAAA,cACP,SAAS;AAAA,cACT,UAAU,CAAC;AAAA,cACX,eAAe;AAAA,cACf,gBAAgB;AAAA,cAChB,yBAAyB;AAAA,cACzB,6BAA6B;AAAA,cAC7B,kBAAkB;AAAA,cAClB,kBAAkB,CAAC;AAAA,YACvB,EAAE;AAAA,UACN,OAAO;AACH,gBAAI,OAAO,EAAE,SAAS,eAAe,EAAE;AAAA,UAC3C;AAAA,QACJ;AAAA,QACA,qBAAqB,UAAU;AAC3B,gBAAM,iBAAiB,IAAI,EAAE;AAE7B,cAAI,OAAO;AAAA,YACP;AAAA,YACA,gBACK,kBACG,SAAS;AAAA,cACL,CAAC,EAAE,QAAQ,MAAM,YAAY,eAAe;AAAA,YAChD,KACJ,SAAS,CAAC;AAAA,UAClB,EAAE;AAAA,QACN;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,aAAS,qCAAkB,MAAM,OAAO;AAAA,QACxC,YAAY,CAAC,EAAE,yBAAyB,4BAA4B,OAAO;AAAA,UACvE;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;",
  "names": []
}
